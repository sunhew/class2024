<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 :: 데이터 실행하기</title>

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/default.min.css">
    <style>
        /* 맨 위로 올라가는 스크롤 버튼 */
        #scrollTopBtn {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: none;
            font-size: 18px;
            background-color: #555;
            color: white;
            cursor: pointer;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <header id="header">
        <h1>
            <a href="index.html">javascript</a>
        </h1>
        <nav>
            <ul>
                <li><a href="javascript01.html">데이터 저장하기</a></li>
                <li><a href="javascript02.html">데이터 불러오기</a></li>
                <li class="active"><a href="javascript03.html">데이터 실행하기</a></li>
                <li><a href="javascript04.html">데이터 제어하기</a></li>
            </ul>
            <ul>
                <li><a href="object01.html">문자열 객체</a></li>
                <li><a href="object02.html">배열 객체</a></li>
                <li><a href="object03.html">수학 객체</a></li>
                <li><a href="object04.html">숫자 객체</a></li>
                <li><a href="object05.html">브라우저 객체</a></li>
                <li><a href="object06.html">요소 객체</a></li>
                <li><a href="object07.html">이벤트 객체</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="main__menu container">
            <ul>
                <li><a href="#">01. 함수 : 선언적 함수</a></li>
                <li><a href="#">02. 함수 : 익명 함수</a></li>
                <li><a href="#">03. 함수 : 매개변수 함수</a></li>
                <li><a href="#">04. 함수 : 리턴값 함수</a></li>
                <li><a href="#">05. 함수 : 매개변수 + 리턴값 함수</a></li>


                <li><a href="#">06. 화살표 : 선언적 함수</a></li>
                <li><a href="#">07. 화살표 : 익명 함수</a></li>
                <li><a href="#">08. 화살표 : 매개변수 함수</a></li>
                <li><a href="#">09. 화살표 : 리턴값 함수</a></li>
                <li><a href="#">10. 화살표 : 매개변수 + 리턴값 함수</a></li>

                <li><a href="#">11. 함수 유형 : 함수와 매개변수를 이용한 형태</a></li>
                <li><a href="#">12. 함수 유형 : 함수와 변수를 이용한 형태</a></li>
                <li><a href="#">13. 함수 유형 : 함수와 배열을 이용한 형태</a></li>
                <li><a href="#">14. 함수 유형 : 함수와 객체를 이용한 형태</a></li>
                <li><a href="#">15. 함수 유형 : 함수와 객체및 배열을 이용한 형태</a></li>
                <li><a href="#">16. 함수 유형 : 객체안에 함수를 이용한 형태</a></li>
                <li><a href="#">17. 함수 유형 : 객체 생성자 함수</a></li>
                <li><a href="#">18. 함수 유형 : 프로토타입 함수</a></li>
                <li><a href="#">19. 함수 유형 : 객체 리터릴 함수</a></li>

                <li><a href="#">20. 함수 : 즉시 실행 함수</a></li>
                <li><a href="#">21. 함수 : 파라미터 함수</a></li>
                <li><a href="#">22. 함수 : 재귀 함수</a></li>
                <li><a href="#">23. 함수 : 콜백 함수</a></li>
                <li><a href="#">24. 함수 : 비동기 방식 : 콜백 함수</a></li>
                <li><a href="#">25. 함수 : 비동기 방식 : 프로미스</a></li>
                <li><a href="#">26. 함수 : 비동기 방식 : asyne/await</a></li>
                <li><a href="#">27. 함수 : 중첩 함수</a></li>
                <li><a href="#">28. 함수 : 클로저</a></li>

                <li><a href="#">29. 클래스 : 기본</a></li>
                <li><a href="#">30. 클래스 : 상속</a></li>
            </ul>
        </div>
        <!-- //main__menu -->

        <div class="main__sample container">
            <div id="sample01" class="sample">
                <h3>01. 함수 : 선언적 함수</h3>
                <p>
                    선언적 함수는 function 키워드를 사용하여 함수를 정의하는 방식입니다. 함수 선언식은 다음과 같은 구조를 가집니다 <br />
                    function 함수이름() {
                    // 함수 코드
                    } <br />

                    여기서 함수이름은 해당 함수를 호출할 때 사용하는 식별자입니다. 함수 본문에는 함수가 호출될 때 실행될 코드를 작성합니다.
                </p>
                <pre><code>{
        function func() {
            console.log("01 함수가 실행되었습니다.");
        }
        func();
}</code></pre>
                <p>
                    이 코드에서는 func라는 이름의 선언적 함수를 정의하고 있습니다. 함수 본문에는 console.log("01 함수가 실행되었습니다.");라는 코드가 있어, 이 함수가 호출될
                    때마다 콘솔에 "01 함수가 실행되었습니다."라는 메시지를 출력합니다. <br />
                    그리고 마지막 줄에서 func();를 통해 func 함수를 호출하고 있습니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            01 함수가 실행되었습니다.
                        </div>
                    </details>
                    <details>
                        <summary>선언적 함수의 특징</summary>
                        <div>
                            *호이스팅(Hoisting): 선언적 함수는 호이스팅의 대상이 됩니다. 이는 함수 선언 전에 함수를 호출할 수 있다는 것을 의미합니다. JavaScript 엔진은
                            코드
                            실행 전에 함수 선언을 먼저 읽어서 메모리에 저장합니다. <br />
                            *함수 스코프: 선언적 함수는 자신이 선언된 위치에서의 스코프(유효 범위)를 가집니다. 함수 내부에서 선언된 변수나 함수는 외부에서 접근할 수 없습니다. <br />
                            *재사용 가능: 함수를 정의한 후에는 언제든지 해당 함수를 호출하여 재사용할 수 있습니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->
            <div id="sample02" class="sample">
                <h3>02. 함수 : 익명 함수</h3>
                <p>
                    익명 함수란, 이름이 없는 함수를 말합니다. 익명 함수는 주로 함수 표현식으로 사용되며, 변수에 할당되거나 다른 함수의 인자로 전달될 수 있습니다. <br />

                    function () { console.log("02 함수가 실행되었습니다."); } <br />

                    위의 부분이 익명 함수입니다. 이 함수에는 이름이 지정되어 있지 않으며, func라는 변수에 할당되어 있습니다. 변수에 할당된 함수는 변수 이름을 통해 호출할 수 있습니다.
                <pre><code>{
        const func = function () {
        console.log("02 함수가 실행되었습니다.");
        };
        func();
}</code></pre>
                <p>
                    익명 함수를 호출하기 위해서는 함수가 할당된 변수를 사용합니다. <br />
                    예제에서는 func 변수에 익명 함수가 할당되어 있으므로, 다음과 같이 func()를 호출함으로써 익명 함수를 실행할 수 있습니다:
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            02 함수가 실행되었습니다.
                        </div>
                    </details>
                    <details>
                        <summary>익명 함수의 특징 및 사용 사례</summary>
                        <div>
                            *이름이 없음: 익명 함수는 이름이 없기 때문에, 직접 호출할 수 없고 변수에 할당하거나 다른 함수의 인자로 전달하여 사용됩니다. <br />
                            *즉시 실행 함수(IIFE): 익명 함수는 즉시 실행 함수 표현식(IIFE, Immediately Invoked Function Expression)으로 사용될 때
                            흔히 볼 수 있습니다. IIFE는 함수를 정의하자마자 바로 실행하는 패턴입니다. <br />
                            *콜백 함수: 익명 함수는 이벤트 핸들러나 타이머 함수(setTimeout, setInterval)의 콜백으로 자주 사용됩니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample02 -->
            <div id="sample03" class="sample">
                <h3>03. 함수 : 매개변수 함수</h3>
                <p>
                    매개변수는 함수 내에서 사용될 입력값을 정의하는 변수입니다. 함수를 호출할 때 매개변수로 전달된 실제 값을 인수(argument)라고 합니다.
                <p>
                    *명명된 함수와 매개변수* <br />
                    첫 번째 예에서 func라는 이름의 함수를 정의하고 있습니다. <br />
                    이 함수는 str이라는 이름의 매개변수를 받습니다. 함수 내부에서는 console.log(str);를 통해 매개변수 str에 저장된 값을 콘솔에 출력합니다.
                    func("03 함수가 실행되었습니다.");라는 코드로 함수를 호출할 때, "03 함수가 실행되었습니다."라는 문자열이 str 매개변수로 전달되어 함수 내에서 출력됩니다.
                </p>
                <pre><code>{
        function func(str) {
            console.log(str);
        }
        func("03 함수가 실행되었습니다.");

        //익명 함수
        const func1 = function (str) {
            console.log(str);
        }
        func1("03 함수가 실행되었습니다.");
}</code></pre>
                <p>
                    *익명 함수와 매개변수* <br />
                    두 번째 예에서는 익명 함수를 사용하고 있습니다.
                    이 함수도 str이라는 매개변수를 받으며, 함수 내부에서는 이 매개변수를 이용해 전달된 값을 콘솔에 출력하며,
                    익명 함수는 이름이 없기 때문에 직접 호출할 수 없으며, 이 예제에서는 익명 함수를 func1이라는 변수에 할당한 후 이 변수를 통해 함수를 호출합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            03 함수가 실행되었습니다.
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            *매개변수(Parameter): 함수 정의 시, 함수 내부에서 사용될 변수를 선언하는 부분입니다. 함수 호출 시 인수(Argument)를 받아 함수 내에서
                            사용됩니다. <br />
                            *인수(Argument): 함수를 호출할 때 함수에 전달되는 실제 값입니다. <br />
                            *명명된 함수(Named Function): 이름을 가진 함수로, 이름을 통해 어디서든지 호출할 수 있습니다. <br />
                            *익명 함수(Anonymous Function): 이름이 없는 함수로, 주로 변수에 할당되거나 다른 함수의 인자로 사용됩니다. 익명 함수는 직접 호출할 수 없으며
                            할당된 변수를 통해 호출할 수 있습니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample03 -->
            <div id="sample04" class="sample">
                <h3>04. 함수 : 리턴값 함수</h3>
                <p>
                    함수에서 return 키워드를 사용하면, 그 뒤에 오는 값을 함수의 호출부로 반환합니다. <br />
                    함수의 반환값은 함수를 호출한 곳에서 사용할 수 있으며, 변수에 할당하거나 다른 함수의 인자로 전달할 수 있습니다.
                    반환값이 명시적으로 지정되지 않은 경우, 함수는 기본적으로 undefined를 반환합니다.
                <pre><code>{
        //선언적 함수
        function func() {
            return "04 함수가 실행되었습니다."
        }
        console.log(func());

        //익명 함수
        {
            const func1 = function () {
                return "04 함수가 실행되었습니다."
            }
            console.log(func1())
        }
}</code></pre>
                <p>
                    이 예제는 함수가 어떻게 값을 반환할 수 있는지 보여줍니다. <br />
                    선언적 함수와 익명 함수 모두 return 키워드를 사용하여 값을 반환할 수 있으며, 이 반환값은 함수 호출부에서 사용될 수 있습니다.
                    함수의 반환값은 함수의 실행 결과를 외부로 전달하는 주요 방법 중 하나입니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            04 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample04 -->
            <div id="sample05" class="sample">
                <h3>05. 함수 : 매개변수 + 리턴값 함수</h3>
                <p>
                    함수에서 매개변수는 외부로부터 입력 값을 받는 역할을 하며,
                    함수 내에서 이 매개변수를 사용하여 특정 작업을 수행할 수 있습니다.
                <pre><code>{
        //선언적 함수
        function func(str) {
            return str;
        }
        console.log(func("05 함수가 실행되었습니다."))

        //익명 함수
        const func1 = function (str) {
            return str
        }
        console.log("05 함수가 실행되었습니다.")
}</code></pre>
                <p>
                    return 키워드를 사용하여 함수는 실행 결과를 호출한 곳으로 반환할 수 있습니다. <br />
                    이렇게 반환된 값은 다른 변수에 저장하거나, 다른 함수의 인자로 사용할 수 있습니다.
                    함수의 매개변수와 리턴값은 함수를 통해 데이터를 처리하고 그 결과를 외부로 전달하는 데 필수적인 요소입니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            05 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample05 -->
            <div id="sample06" class="sample">
                <h3>06. 화살표 : 선언적 함수</h3>
                <p>
                    첫 번째 방식은 전통적인 선언적 함수(함수 선언문)를 사용한 것이고, 두 번째 방식은 화살표 함수(arrow function)를 사용한 것입니다.
                    두 함수 모두 호출될 때 콘솔에 "06 함수가 실행되었습니다."라는 메시지를 출력합니다.
                <pre><code>{
        //선언적 함수    /아래 두 코드는 값이 같음.
        function func() {
            console.log("06 함수가 실행되었습니다.")
        }
        func();

        func1 = () => {
            console.log("06 함수가 실행되었습니다.")
        }
        func1();
}</code></pre>
                <p>
                <p>*선언적 함수* <br />
                    선언적 함수는 function 키워드를 사용하여 정의됩니다.
                    이 방식은 함수에 이름을 붙여 정의하며, 이름을 통해 함수를 호출할 수 있습니다.</p>
                <p>*화살표 함수* <br />
                    화살표 함수는 ES6(ES2015)에서 도입된 새로운 함수 정의 방법이며
                    function 키워드 대신 화살표(=>)를 사용하여 더 간결한 문법으로 함수를 정의할 수 있습니다.
                    화살표 함수는 주로 익명 함수로 사용됩니다.</p>
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            06 함수가 실행되었습니다.
                        </div>
                    </details>
                    <details>
                        <summary>화살표 함수 vs. 선언적 함수</summary>
                        <div>
                            <p>화살표 함수와 선언적 함수 사이에는 몇 가지 중요한 차이점이 있습니다</p>
                            *문법: 화살표 함수는 더 간결한 문법을 제공합니다. function 키워드 없이도 함수를 정의할 수 있어 코드가 더 간단해집니다. <br />
                            *this 바인딩: 화살표 함수는 자신을 포함하는 외부 스코프의 this를 그대로 사용합니다. 반면, 선언적 함수에서 this는 함수가 호출된 컨텍스트에 따라
                            달라집니다. 이 차이는 객체 메소드나 이벤트 핸들러 등을 작성할 때 중요한 영향을 미칩니다. <br />
                            *생성자 함수: 화살표 함수는 생성자로 사용될 수 없습니다. 즉, new 키워드를 사용하여 화살표 함수의 인스턴스를 생성할 수 없습니다.
                            반면, 선언적 함수는 생성자로 사용될 수 있습니다. <br />
                            두 함수 정의 방식은 각각의 사용 사례와 선호도에 따라 선택할 수 있으며, 상황에 맞게 적절히 사용하는 것이 중요합니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample06 -->
            <div id="sample07" class="sample">
                <h3>07. 화살표 : 익명 함수</h3>
                <p>
                    이 코드에서는 화살표(=>)를 사용하여 함수를 정의하고 있습니다. 화살표 함수는 function 키워드 없이도 함수를 정의할 수 있어 코드가 간결해집니다.
                </p>
                <pre><code>{
        //익명 함수
        const func = function () {
            console.log("07 함수가 실행되었습니다.")
        }
        func();

        //익명 함수를 화살표 함수로 바꿈
        const func1 = () => {
            console.log("07 함수가 실행되었습니다.")
        }
        func1();
}</code></pre>
                <p>
                    *화살표 함수의 특징* <br />
                    1. 간결성: 화살표 함수는 함수를 더 짧고 간결하게 표현할 수 있게 해줍니다. <br />
                    2. this 바인딩: 화살표 함수는 자신을 포함하는 외부 스코프의 this 값을 그대로 사용합니다.
                    이는 전통적인 함수에서의 this 바인딩과 다르며, 특히 콜백 함수와 같은 상황에서 유용합니다. <br />
                    3. 익명성: 화살표 함수는 항상 익명입니다. 따라서 화살표 함수를 변수에 할당하거나 다른 함수의 인수로 전달할 때 주로 사용됩니다. <br />
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            07 함수가 실행되었습니다.
                        </div>
                    </details>
                    <details>
                        <summary>주의해야 할 점</summary>
                        <div>
                            화살표 함수는 JavaScript에서 함수를 표현하는 강력하고 간결한 방법을 제공합니다. <br />
                            그러나 this 바인딩의 차이점을 이해하는 것이 중요하며, 모든 상황에 화살표 함수가 적합한 것은 아닙니다.
                            예를 들어, 객체의 메소드나 생성자 함수로 화살표 함수를 사용하는 것은 권장되지 않습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample07 -->
            <div id="sample08" class="sample">
                <h3>08. 화살표 : 매개변수 함수</h3>
                <p>
                    이 코드는 화살표 함수(arrow function)와 그 매개변수 사용법에 대해 보여주며, 화살표 함수는 익명 함수로만 사용할 수 있고 function 키워드 대신 화살표(=>)를
                    사용하여 정의합니다. <br />
                <p>*화살표 함수의 매개변수* <br />
                    화살표 함수는 매개변수(parameter)를 통해 외부로부터 값을 받을 수 있습니다.
                    매개변수는 함수의 괄호 () 안에 정의되며, 함수 내부에서 이 매개변수를 사용하여 특정 작업을 수행할 수 있습니다.
                </p>
                <pre><code>{
        //선언적 함수
        func = (str) => {
            console.log(str);
        }
        func("08 함수가 실행되었습니다.");

        //익명 함수
        const func1 = (str) => {
            console.log(str);
        }
        func1("08 함수가 실행되었습니다.");
}</code></pre>
                <p>
                <p>*선언적 함수* <br />
                    func는 변수 선언 없이 바로 화살표 함수를 할당받고 있습니다.
                    이는 전역 변수로 func를 생성하게 됩니다. 일반적으로 좋은 관행은 함수를 정의할 때 const나 let을 사용하여 변수에 할당하는 것입니다.</p>
                <p>*익명 함수* <br />
                    여기서는 func1이라는 상수에 화살표 함수를 할당하고 있습니다. 이 함수 역시 str이라는 매개변수를 받고, 그 값을 콘솔에 출력합니다.</p>
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            08 함수가 실행되었습니다.
                        </div>
                    </details>
                    <details>
                        <summary>화살표 함수 매개변수의 특징</summary>
                        <div>
                            *하나의 매개변수만 있을 경우, 괄호(())를 생략할 수 있습니다. 예: str => console.log(str) <br />
                            *매개변수가 없을 경우, 괄호는 생략할 수 없으며 빈 괄호를 사용합니다. 예: () => console.log('Hello') <br />
                            *여러 매개변수가 있을 경우, 괄호가 필요합니다. 예: (a, b) => a + b <br />
                            화살표 함수는 익명 함수의 간결한 대안으로, this 바인딩이 상위 스코프의 this를 그대로 사용한다는 점에서 함수 표현식과 차별화됩니다.
                            매개변수를 사용하는 방법은 위에서 설명한 바와 같습니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample08 -->
            <div id="sample09" class="sample">
                <h3>09. 화살표 : 리턴값(결과, 종료)</h3>
                <p>
                    화살표 함수는 다른 함수와 마찬가지로 return 문을 사용하여 값을 반환할 수 있습니다. <br />
                    함수 내에서 return 문 다음에 오는 값을 함수의 호출자(caller)에게 반환합니다.
                    만약 return 문이 없거나 함수 내부에서 return이 실행되지 않으면, 함수는 기본적으로 undefined를 반환합니다.
                <pre><code>{
        //선언적 함수
        func = () => {
            return "09 함수가 실행되었습니다."
        }
        console.log(func());

        //익명 함수
        {
            const func1 = () => {
                return "09 함수가 실행되었습니다."
            }
            console.log(func1())
        }
}</code></pre>
                <p>
                    *화살표 함수에서의 간결한 리턴* <br />
                    화살표 함수는 리턴을 더 간결하게 만들 수 있는 문법을 제공합니다.
                    함수 본문이 단일 표현식으로 구성되어 있고, 그 표현식의 결과를 바로 반환하려는 경우, 중괄호({})와 return 키워드를 생략할 수 있습니다.
                    이런 경우, 화살표(=>) 다음에 오는 표현식이 자동으로 반환값이 됩니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            09 함수가 실행되었습니다.
                        </div>
                    </details>
                    <details>
                        <summary>더욱 간결하게 작성하는 코드</summary>
                        <pre><code>{
const func = () => "09 함수가 실행되었습니다.";
console.log(func());
} </code></pre>
                        <p>이 형태는 특히 함수가 간단할 때 코드를 더욱 읽기 쉽고 간결하게 만들어 줍니다.
                            화살표 함수의 이러한 특성은 JavaScript에서 함수적 프로그래밍 스타일을 채택할 때 특히 유용합니다.</p>
                    </details>
                </div>
            </div>
            <!-- //sample09 -->
            <div id="sample10" class="sample">
                <h3>10. 화살표 : 매개변수 + 리턴값 함수 *가장 중요*</h3>
                <p>
                    함수에서 return 키워드를 사용하면, 그 뒤에 오는 값을 함수의 호출부로 반환합니다. <br />
                    함수의 반환값은 함수를 호출한 곳에서 사용할 수 있으며, 변수에 할당하거나 다른 함수의 인자로 전달할 수 있습니다.
                    반환값이 명시적으로 지정되지 않은 경우, 함수는 기본적으로 undefined를 반환합니다.
                <pre><code>{        
        //익명 함수(화살표 함수) + 매개변수 + 리턴값
        const func = (str) => {
            return str
        }
        console.log(func("10 함수가 실행되었습니다."));
}</code></pre>
                <P>*익명 함수(화살표 함수) + 매개변수 + 리턴값 <br />
                    이 함수는 str이라는 매개변수를 받아서 그대로 반환합니다.
                    화살표 함수를 사용하고 있으며, 매개변수가 괄호 () 안에 정의되어 있습니다. 함수 본문에서 return 키워드를 사용하여 매개변수로 받은 값을 반환합니다.</p>

                <pre><code>{
        //매개변수 하나이면 괄호 생략 가능
        const func2 = str => {
            return str;
        }
        console.log(func2("10 함수가 실행되었습니다."));
}</code></pre>

                <P>*매개변수 하나이면 괄호 생략 가능 <br />
                    매개변수가 하나인 경우, 괄호를 생략할 수 있습니다. 이 예제에서는 func2 함수가 str 매개변수를 받아 그대로 반환합니다.</P>
                <pre><code>{
        //리턴 생략    (자바스크립트에서만 생략 가능하지만 리액트에선 생략 불가.)
        const func3 = str => str
        console.log(func3("10 함수가 실행되었습니다."));
}</code></pre>

                <p>*리턴 생략 (자바스크립트에서만 생략 가능, 리액트에서는 JSX 문법 때문에 불가) <br />
                    함수 본문이 단일 표현식인 경우, return 키워드와 중괄호 {}를 생략할 수 있습니다.
                    이 경우, 화살표 오른쪽에 있는 표현식의 결과가 자동으로 반환값이 됩니다. 이 예제에서 func3는 매개변수 str을 받아 그대로 반환합니다. <br />
                    리액트에서 화살표 함수를 사용할 때 return을 생략할 수 없는 이유는, 리액트 컴포넌트나 JSX 요소를 반환할 때 종종 여러 줄에 걸쳐 표현해야 하기 때문입니다.
                    이런 경우, 중괄호와 return 키워드가 필요합니다.</p>
                <pre><code>{
        //선언적 함수(가독성이 좋지 않음.)
        func4 = str => str
        console.log(func4("10 함수가 실행되었습니다."));
}</code></pre>

                <p>
                    선언적 함수(가독성이 좋지 않음) <br />
                    이 예제에서는 func4를 var, let, const 없이 선언하고 있습니다.
                    이런 방식은 전역 변수를 생성할 수 있기 때문에, 일반적으로 권장되지 않습니다. func4는 매개변수를 하나 받아 그대로 반환합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            04 함수가 실행되었습니다.
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            화살표 함수는 기존의 함수 표현식보다 간결하게 함수를 정의할 수 있게 해주며, 특히 this 키워드의 바인딩 방식이 다르다는 점에서 차별화됩니다. <br />
                            *매개변수가 하나인 경우 괄호를 생략할 수 있고, 함수 본문이 단일 표현식으로만 구성된 경우 return 키워드와 중괄호를 생략할 수 있어 코드를 더 간결하게 만들
                            수 있습니다.
                            <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample10 -->
            <div id="sample11" class="sample">
                <h3>11. 함수 유형 : 함수와 매개변수를 이용한 형태 *제일 많이 쓰임*</h3>
                <p>
                    아래 코드에서 func라는 이름의 함수는 두 개의 매개변수 num과 str을 받아, 이를 이용해 문자열을 조합하고 이를 콘솔에 출력합니다.
                    여기서 num은 숫자를, str은 문자열을 의미합니다. 함수 내에서 문자열 조합과 출력은 두 가지 방식으로 이루어집니다.
                </p>
                <pre><code>{        
        function func(num, str) {
            console.log(num + ". " + str);          //이전 방식
            console.log(`${num}. ${str}`);           //최신 방식  . 대신 다른 문자 대체 가능.
        }
        func(11, "함수가 실행되었습니다.");
}</code></pre>
                <P>*이전 방식* <br />
                    첫 번째 console.log 구문에서는 전통적인 문자열 연결 방식을 사용합니다. + 연산자를 통해 숫자와 문자열, 그리고 추가 문자열을 연결합니다.
                    여기서는 숫자 num 뒤에 점(.)과 공백을 추가하고, 그 뒤에 문자열 str을 연결하여 최종적으로 num. str 형태의 문자열을 만들어 콘솔에 출력합니다.
                </p>
                <P>*최신 방식 (템플릿 리터럴)* <br />
                    두 번째 console.log 구문에서는 ES6(ES2015)에서 도입된 템플릿 리터럴(template literals)을 사용합니다.
                    템플릿 리터럴은 백틱(``)을 사용하여 문자열을 표현하며, ${} 구문을 통해 직접 변수를 문자열 안에 삽입할 수 있게 해주면서
                    코드를 더 깔끔하게 만들며, 변수와 문자열을 더 쉽게 결합할 수 있게 해줍니다. 특히, 여러 줄에 걸친 문자열을 생성할 때도 유용합니다. <br />
                    또한, 템플릿 리터럴을 사용하면, . 대신 다른 문자 대체 가능.이라는 부분에서 언급된 것처럼, 구문 내에서 다양한 문자를 자유롭게 조합하여 사용할 수 있습니다.
                    예를 들어, 점(.) 대신에 다른 구분자를 사용하고 싶다면, 템플릿 리터럴 내에서 바로 변경하여 사용할 수 있습니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            11. 함수가 실행되었습니다.
                        </div>
                    </details>
                    <details>
                        <summary>함수와 매개변수</summary>
                        <div>
                            이 코드에서 func 함수는 매개변수를 이용하여 유연하게 문자열을 조합하고 출력하는 역할을 합니다.
                            함수와 매개변수를 사용하는 방식은 프로그래밍에서 매우 중요한 개념으로, 코드의 재사용성을 높이고,
                            유지 보수를 용이하게 하며, 코드의 가독성을 향상시키는 데 기여합니다. 매개변수를 통해 함수에 입력을 제공하면, 함수는 이를 처리하여 필요한 작업을 수행할 수
                            있습니다. <br />
                            이 예제에서는 간단한 문자열 조합과 출력을 통해 함수와 매개변수의 활용을 보여주고 있으며,
                            템플릿 리터럴을 사용하여 보다 현대적이고 효율적인 방식으로 문자열을 처리하는 방법을 강조하고 있습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample11 -->
            <div id="sample12" class="sample">
                <h3>12. 함수 유형 : 함수와 변수를 이용한 형태</h3>
                <p>*변수 선언* <br />
                    const 키워드를 사용해 num과 str이라는 두 개의 상수를 선언하고 있습니다.
                    num은 숫자 12를, str은 문자열 "함수가 실행되었습니다."를 각각 저장합니다. const는 ES6(ES2015)에서 도입된 키워드로, 선언된 변수의 값을 재할당할 수 없게
                    합니다.
                    이는 코드의 가독성과 안정성을 높이는 데 도움이 됩니다.
                </p>
                <pre><code>{        
        const num = 12;
        const str = "함수가 실행되었습니다.";

        function func(num, str) {
            console.log(`${num}. ${str}`)
        }
        func(num, str);
}</code></pre>
                <P>*함수 정의 및 호출* <br />
                    func라는 이름의 함수를 정의하고 있습니다. 이 함수는 두 개의 매개변수 num과 str을 받아,
                    이를 템플릿 리터럴을 사용하여 문자열로 조합하고, console.log를 통해 이를 콘솔에 출력합니다. 템플릿 리터럴은 백틱(````)으로 문자열을 감싸고,
                    ${}를 사용하여 변수의 값을 문자열 안에 직접 삽입할 수 있게 하는 ES6의 기능입니다. <br />
                    마지막 줄에서는 앞서 선언한 num과 str 변수를 func 함수에 인자로 전달하며 함수를 호출합니다.
                    이때 함수 내부에서 사용된 num, str 매개변수는 함수 외부에서 선언된 동일한 이름의 변수와는 별개로 동작합니다.
                    함수 내부에서 매개변수는 함수 호출 시 전달된 인자의 값으로 초기화되며, 함수의 로컬 스코프 내에서만 유효합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            12. 함수가 실행되었습니다.
                        </div>
                    </details>
                    <details>
                        <summary>함수와 변수를 이용한 형태의 중요성</summary>
                        <div>
                            위 코드에서 볼 수 있듯이, 변수를 사용하여 데이터를 저장하고, 함수를 통해 이 데이터를 처리하는 방식은 프로그래밍에서 매우 일반적입니다.
                            함수는 재사용 가능한 코드 블록을 만들어, 코드의 중복을 줄이고, 프로그램의 구조를 개선할 수 있게 합니다.
                            변수를 함수에 인자로 전달함으로써, 함수는 보다 유연하게 데이터를 처리할 수 있으며, 다양한 상황에 적용할 수 있습니다. <br />
                            이러한 방식은 프로그램의 유지 보수성을 높이고, 코드의 가독성을 개선하며, 개발 과정에서의 오류 가능성을 줄이는 데 중요한 역할을 하며 함수와 변수를 적절히
                            사용함으로써, 더 효과적이고 효율적인 코드 작성이 가능해집니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample12 -->
            <div id="sample13" class="sample">
                <h3>13. 함수 유형 : 함수와 배열을 이용한 형태</h3>
                <p>배열은 여러 데이터를 순서대로 저장하는 자료 구조이며, 함수는 특정 작업을 수행하는 코드의 묶음입니다.
                    이 코드는 함수를 이용하여 배열의 각 요소에 접근하고, 그 값을 활용하는 예를 보여줍니다.</p>
                <pre><code>{        
        const num = [13, 14];
        const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."];

        function func(num, str) {
            console.log(`${num}. ${str}`)
        }
        func(num[0], str[0]);
        func(num[1], str[1]);
}</code></pre>
                <P>#배열(Array) <br />
                    *num과 str 두 배열이 선언되어 있습니다. <br />
                    *num 배열에는 숫자 13과 14가 저장되어 있습니다. <br />
                    *str 배열에는 문자열 "함수가 실행되었습니다."가 두 번 저장되어 있습니다.
                </p>
                <P>#함수(Function) <br />
                    *func라는 이름의 함수가 선언되어 있으며, 두 개의 매개변수 num과 str을 받습니다.
                    *함수 내부에서는 템플릿 리터럴을 사용하여 입력받은 num과 str 값을 하나의 문자열로 결합하고, 이를 콘솔에 출력합니다.
                    템플릿 리터럴은 백틱(```)으로 감싸진 문자열 안에서 ${}를 사용하여 변수나 표현식의 값을 문자열 안에 직접 삽입할 수 있게 합니다.
                </p>
                <P>#함수 호출 <br />
                    *func 함수를 두 번 호출하고 있습니다. <br />
                    첫 번째 호출에서는 num 배열의 첫 번째 요소(13)와 str 배열의 첫 번째 요소("함수가 실행되었습니다.")를 매개변수로 전달합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            13. 함수가 실행되었습니다. <br />
                            14. 함수가 실행되었습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>코드의 의미</summary>
                        <div>
                            이 코드의 핵심은 함수를 통해 배열의 각 요소를 처리하는 방법을 보여주는 것입니다.
                            배열에서 요소를 선택하여 함수의 인자로 전달하고, 함수에서는 이 인자를 사용하여 특정 작업(여기서는 콘솔에 출력)을 수행합니다.
                            이러한 방식은 데이터의 집합을 순회하며 각 요소에 대해 동일한 작업을 반복적으로 수행할 때 유용합니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample13 -->
            <div id="sample14" class="sample">
                <h3>14. 함수 유형 : 함수와 객체를 이용한 형태</h3>
                <p>이 코드는 JavaScript에서 함수와 객체를 함께 사용하는 방법을 보여줍니다. 객체는 여러 속성을 하나의 단위로 그룹화하여 저장하는 자료 구조입니다.
                    함수는 특정 작업을 수행하는 코드의 묶음입니다. 이 코드는 객체의 속성 값을 함수의 인자로 전달하여, 함수에서 이 값을 활용하는 방법을 보여줍니다.
                </p>
                <pre><code>{        
        const info = {
            num: 15,
            str: "함수가 실행되었습니다."
        }
        function func(num, str) {
            console.log(`${num}. ${str}`);
        }
        func(info.num, info.str);
}</code></pre>
                <P>#객체(Object) <br />
                    *info라는 이름의 객체가 선언되어 있습니다. <br />
                    *이 객체는 num과 str 두 속성을 가지고 있습니다. <br />
                    *num 속성의 값은 숫자 15입니다. <br />
                    *str 속성의 값은 문자열 "함수가 실행되었습니다."입니다. <br />
                </p>
                <P>#함수(Function) <br />
                    *func라는 이름의 함수가 선언되어 있으며, 두 개의 매개변수 num과 str을 받습니다. <br />
                    *함수 내부에서는 템플릿 리터럴을 사용하여 입력받은 num과 str 값을 하나의 문자열로 결합하고, 이를 콘솔에 출력합니다.
                    템플릿 리터럴은 백틱(```)으로 감싸진 문자열 안에서 ${}를 사용하여 변수나 표현식의 값을 문자열 안에 직접 삽입할 수 있게 합니다. <br />
                </p>
                <P>#함수 호출 <br />
                    *func 함수를 호출하면서 info 객체의 num 속성 값과 str 속성 값을 인자로 전달합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            15. 함수가 실행되었습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>코드의 의미</summary>
                        <div>
                            이 코드의 핵심은 객체의 속성 값을 함수의 인자로 활용하는 방법을 보여주는 것입니다.
                            객체 내부에 저장된 데이터를 함수에 전달하여 작업을 수행할 수 있으며, 이는 데이터를 구조화하고 관리하는 데 유용합니다.
                            함수와 객체를 함께 사용함으로써, 코드의 가독성과 재사용성을 높이고, 데이터와 그 데이터를 처리하는 로직을 더욱 명확하게 연결할 수 있습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample14 -->
            <div id="sample15" class="sample">
                <h3>15. 함수 유형 : 함수와 객체및 배열을 이용한 형태</h3>
                <p>
                    배열 안에 객체를 포함시켜 여러 데이터를 구조화하고 관리하는 방법, 그리고 이러한 데이터 구조를 함수와 함께 사용하여 특정 작업을 수행하는 방법을 다룹니다.
                </p>
                <pre><code>{        
        const info = [
        { num: 16, str: "함수가 실행되었습니다." },
        { num: 17, str: "함수가 실행되었습니다." }
        ]

        function func(num, str) {
            console.log(`${num}. ${str}`)
        }
        func(info[0].num, info[0].str);
        func(info[1].num, info[1].str);
}</code></pre>
                <P>#객체와 배열의 조합 <br />
                    *info라는 이름의 배열이 선언되어 있으며, 이 배열은 두 개의 객체를 요소로 가지고 있습니다. <br />
                    *각 객체는 num과 str이라는 두 속성을 가지고 있습니다. <br />
                    *첫 번째 객체의 num 속성 값은 16, str 속성 값은 "함수가 실행되었습니다."입니다. <br />
                    *두 번째 객체의 num 속성 값은 17, str 속성 값은 "함수가 실행되었습니다."입니다.
                </p>
                <P>#함수(Function) <br />
                    *func라는 이름의 함수가 선언되어 있으며, 두 개의 매개변수 num과 str을 받습니다. <br />
                    *함수 내부에서는 템플릿 리터럴을 사용하여 입력받은 num과 str 값을 하나의 문자열로 결합하고, 이를 콘솔에 출력합니다.
                </p>
                <P>#함수 호출 <br />
                    *func 함수를 두 번 호출하며, 각 호출에서 info 배열의 첫 번째 객체와 두 번째 객체의 num과 str 속성 값을 인자로 전달합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            16. 함수가 실행되었습니다. <br />
                            17. 함수가 실행되었습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>코드의 의미</summary>
                        <div>
                            이 코드는 배열 내 객체를 활용하여 데이터를 구조화하고, 이러한 구조화된 데이터를 함수를 통해 처리하는 방식을 보여줍니다.
                            각 객체는 관련된 데이터를 묶어서 관리하며, 배열은 이러한 객체들의 집합을 순서대로 저장합니다.
                            함수는 이 데이터를 인자로 받아 특정 작업(여기서는 콘솔에 출력)을 수행하게 되는데,
                            이러한 방식은 데이터를 체계적으로 관리하고, 코드의 유지보수성과 가독성을 높이는 데 도움을 줍니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample15 -->
            <div id="sample16" class="sample">
                <h3>16. 함수 유형 : 객체안에 함수를 이용한 형태</h3>
                <p>아래 코드는 JavaScript에서 객체 내부에 함수를 포함시키는 방법을 보여줍니다.
                    이와 같이 객체의 속성으로 함수를 설정할 때, 해당 함수를 메서드(method)라고 합니다.
                </p>
                <pre><code>{        
        const info = {
            num: 18,
            str: "함수가 실행되었습니다.",
            result: () => {
                console.log(`${info.num}. ${info.str}`)
            }
        }
        info.result();
}</code></pre>
                <P>#객체 내 함수(메서드) 정의 <br />
                    *info라는 이름의 객체가 선언되어 있습니다.
                    *이 객체는 num, str, 그리고 result라는 세 개의 속성을 가지고 있습니다.
                    *num 속성의 값은 숫자 18입니다.
                    *str 속성의 값은 문자열 "함수가 실행되었습니다."입니다.
                    *result 속성은 화살표 함수(() => {})를 값으로 가지고 있으며, 이 함수가 객체 내 메서드로 작동합니다. 이 메서드는 객체 내 다른 속성인 num과 str을 활용하여
                    콘솔에 문자열을 출력합니다.
                </p>
                <P>#메서드 호출 <br />
                    *객체의 result 메서드를 호출합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            18. 함수가 실행되었습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>코드의 의미</summary>
                        <div>
                            이 코드는 객체의 속성과 메서드를 활용하여 데이터와 이 데이터를 처리하는 로직을 한 곳에 모아 관리하는 방법을 보여줍니다.
                            메서드는 객체의 다른 속성에 접근할 수 있으며, 이를 통해 객체가 가진 정보를 활용하여 특정 작업을 수행할 수 있습니다.
                            이러한 방식은 데이터와 기능을 캡슐화하여 관련된 정보와 동작을 객체라는 단위로 묶어 관리할 수 있게 해줍니다.
                            결과적으로, 코드의 구조를 명확하게 하고, 재사용성 및 유지보수성을 높일 수 있습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample16 -->
            <div id="sample17" class="sample">
                <h3>17. 함수 유형 : 객체 생성자 함수</h3>
                <p>
                    자바스크립트에서 객체 생성자 함수는 객체를 생성하기 위해 사용되는 특별한 유형의 함수입니다.
                    이 방식을 사용하면 동일한 구조를 가진 객체를 여러 개 생성할 때 코드의 중복을 줄이고, 관리를 용이하게 할 수 있으며
                    객체 생성자 함수는 일반적으로 PascalCase(파스칼 케이스)를 사용하여 이름을 지정합니다. 그러나 여기서는 Func라는 이름이 사용되었습니다.
                </p>
                <pre><code>{        
        //함수 정의
        function Func(num, str) {
            this.num = num;
            this.str = str;
            this.result = () => {
                console.log(`${this.num}. ${this.str}`)
            }
        }

        //인스턴스 생성
        const info1 = new Func(19, "함수가 실행되었습니다.");
        const info2 = new Func(20, "함수가 실행되었습니다.");

        //호출
        info1.result();
        info2.result();
}</code></pre>
                <P>#객체 생성자 함수 정의 <br />
                    *위의 코드 예제에서 Func 함수는 객체 생성자 역할을 합니다. <br />
                    *이 함수는 두 개의 매개변수 num과 str을 받아서, 생성될 객체의 속성으로 할당합니다. <br />
                    *this 키워드는 생성될 객체를 가리키며, this.num과 this.str을 통해 각각의 매개변수 값을 객체의 속성으로 설정하며,
                    this.result는 화살표 함수를 객체의 메소드로 할당하는데, 이 메소드는 객체의 num과 str 속성을 이용하여 문자열을 출력합니다.
                </p>
                <P>#인스턴스 생성 <br />
                    *new 키워드를 사용하여 Func 생성자 함수의 인스턴스를 생성합니다.
                    이때, new Func(19, "함수가 실행되었습니다.") 구문은 Func 생성자 함수를 호출하면서 새로운 객체를 생성합니다. <br />
                    *이 객체는 num 속성으로 19를, str 속성으로 "함수가 실행되었습니다." 문자열을 가지게 됩니다.
                    info1과 info2 변수는 각각 Func 생성자 함수로부터 생성된 독립적인 객체를 참조합니다.
                </p>
                <P>#메소드 호출 <br />
                    *info1.result()와 info2.result()는 각 인스턴스의 result 메소드를 호출합니다.
                    이 메소드는 해당 인스턴스의 num과 str 속성을 사용하여 정의된 문자열을 콘솔에 출력합니다. 따라서 결과는 다음과 같이 나타납니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            19. 함수가 실행되었습니다. <br />
                            20. 함수가 실행되었습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>객체 생성자 함수의 장점</summary>
                        <div>
                            *재사용성: 동일한 속성을 가진 객체를 여러 개 생성할 때 코드의 중복을 줄일 수 있습니다. <br />
                            *구조화: 속성과 메소드를 포함하는 복잡한 객체를 쉽게 구조화할 수 있습니다. <br />
                            *명확성: new 키워드를 사용함으로써 어떤 함수가 생성자 함수로 사용되는지 명확하게 할 수 있습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>주의사항</summary>
                        <div>
                            *생성자 함수 내에서 화살표 함수(=>)를 사용할 경우, 화살표 함수는 자신만의 this를 가지지 않기 때문에, 외부의 this(여기서는 생성자 함수의 this)를
                            그대로 사용합니다. 이는 때때로 의도한 바와 다르게 작동할 수 있으니 사용에 주의가 필요합니다. <br />
                            *생성자 함수의 이름은 일반적으로 파스칼 케이스를 사용합니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample17 -->
            <div id="sample18" class="sample">
                <h3>18. 함수 유형 : 프로토타입 함수</h3>
                <p>
                    #프로토타입 함수란? <br />
                    JavaScript는 클래스 기반 언어가 아닌 프로토타입 기반 언어입니다.
                    이는 객체의 "프로토타입"이라는 개념을 사용하여 상속과 재사용성을 구현합니다.
                    각각의 객체는 다른 객체를 그들의 프로토타입으로 가질 수 있으며,
                    이를 통해 프로토타입 객체의 속성과 메서드를 상속받습니다.
                </p>
                <pre><code>{        
        //함수 정의
        function Func(num, str) {
            this.num = num;
            this.str = str;
        }

        //메서드 추가
        Func.prototype.result = function () {
            console.log(`${this.num}. ${this.str}`);
        }

        //인스턴스 생성
        const info1 = new Func(21, "함수가 실행되었습니다.");
        const info2 = new Func(22, "함수가 실행되었습니다.");

        //호출
        info1.result();
        info2.result();
}</code></pre>
                <P>#함수 정의 <br />
                    Func라는 함수(생성자)를 정의합니다. 이 함수는 new 키워드와 함께 호출될 때마다 새로운 객체를 생성합니다.
                    이 객체는 num과 str이라는 두 개의 속성을 가지며, 이 속성들은 함수에 전달된 인자로 초기화됩니다.
                </p>
                <P>#메서드 추가 <br />
                    Func 함수의 프로토타입에 result라는 메서드를 추가합니다.
                    이 메서드는 해당 함수를 통해 생성된 모든 객체에서 사용할 수 있습니다.
                    result 메서드는 객체의 num과 str 속성을 사용하여 문자열을 콘솔에 출력합니다.
                </p>
                <P>#인스턴스 생성 <br />
                    *Func 생성자 함수를 사용하여 info1과 info2라는 두 개의 새로운 객체를 생성합니다.
                    각 객체는 고유한 num과 str 속성 값을 가집니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            21. 함수가 실행되었습니다. <br />
                            22. 함수가 실행되었습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>결론</summary>
                        <div>
                            프로토타입을 사용한 함수 유형은 JavaScript에서 객체 간의 상속을 구현하는 핵심적인 방법입니다.
                            이 방식을 통해 생성자 함수를 정의하고, 이 생성자의 프로토타입에 메서드를 추가하여,
                            해당 생성자를 통해 생성된 모든 객체가 이 메서드를 공유하고 사용할 수 있게 됩니다.
                            이는 코드의 재사용성과 유지보수성을 높이는 데 도움을 줍니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample18 -->
            <div id="sample19" class="sample">
                <h3>19. 함수 유형 : 객체 리터릴 함수</h3>
                <p>
                    자바스크립트에서 객체 리터럴은 중괄호({})를 사용하여 객체를 직접 생성하는 방법입니다.
                    객체 리터럴 내에서는 속성과 메서드를 정의할 수 있습니다. 이 코드에서는 Func.prototype에
                    객체 리터럴을 할당하여 Func 생성자 함수로 생성된 객체들이 공통으로 사용할 메서드를 정의하고 있습니다.
                </p>
                <pre><code>{        
        //함수 정의
        function Func(num, str) {
            this.num = num;
            this.str = str;
        }

        //메서드 추가
        Func.prototype = {
            result1: function () {
                console.log(`${this.num}. ${this.str}`);
            },
            result2: function () {
                console.log(`${this.num}. ${this.str}`);
            },
        }

        //인스턴스 생성
        const info1 = new Func(23, "함수가 실행되었습니다.");
        const info2 = new Func(24, "함수가 실행되었습니다.");

        //호출
        info1.result1();
        info2.result2();
}</code></pre>
                <P>#함수 정의 <br />
                    Func 함수는 생성자 함수로, 새로운 객체를 생성할 때 사용됩니다.
                    이 함수를 new 키워드와 함께 호출하면, 함수 내부에서 this 키워드를 사용하여 객체의 속성을 설정할 수 있습니다.
                </p>
                <P>#메서드 추가 <br />
                    Func.prototype을 객체 리터럴로 재정의하여 result1과 result2라는 두 메서드를 추가합니다.
                    이 메서드들은 Func 생성자 함수를 통해 생성된 모든 인스턴스가 공유합니다. 프로토타입을 사용하는 이유는 모든 인스턴스가
                    메모리에 동일한 함수의 복사본을 갖지 않고, 같은 메서드를 공유할 수 있도록 하기 위함입니다.
                </p>
                <P>#인스턴스 생성 및 호출 <br />
                    new Func(23, "함수가 실행되었습니다.")를 통해 Func 생성자 함수로부터 info1 인스턴스를 생성하고,
                    num과 str 속성을 초기화합니다. info2에 대해서도 동일한 과정을 거칩니다.
                    이후 result1과 result2 메서드를 각각 호출하여, 각 인스턴스의 num과 str 속성을 콘솔에 출력합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            23. 함수가 실행되었습니다. <br />
                            24. 함수가 실행되었습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>결론</summary>
                        <div>
                            이 코드는 생성자 함수와 프로토타입을 사용하여 객체 지향적인 방식으로 자바스크립트에서
                            클래스와 비슷한 구조를 구현하는 방법을 보여줍니다. 객체 리터럴을 사용하여 프로토타입에 메서드를
                            추가함으로써, 생성된 모든 인스턴스가 메서드를 공유할 수 있게 됩니다.
                            이는 메모리 사용을 최적화하고, 코드의 재사용성을 높이는 효과적인 방법입니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample19 -->
            <div id="sample20" class="sample">
                <h3>20. 함수 : 즉시 실행 함수</h3>
                <p>
                    # 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)는 정의되자마자 즉시 실행되는 함수 표현식입니다. 이러한 함수는 다음과 같은
                    특징을 가지고 있습니다 <br />
                    1. 독립적인 실행 환경: 즉시 실행 함수는 자신만의 독립적인 실행 환경을 생성합니다. 이는 변수나 함수 등이 전역 공간에 노출되지 않도록 하여, 코드 충돌을 방지하는 데
                    유용합니다. <br />
                    2. 캡슐화: 함수 내부에 선언된 변수나 함수는 외부에서 접근할 수 없습니다. 이는 코드의 캡슐화를 통해 정보를 은닉하고, 외부 영향으로부터 보호합니다. <br />
                    3. 즉시 실행: 함수가 정의되는 즉시 실행되므로, 초기화 작업이나 설정 등을 즉시 수행할 수 있습니다. <br />
                </p>
                <pre><code>{        
        (function () {
            console.log("25-1. 실행되었습니다.")
        })();

        (() => {
            console.log("25-2. 실행되었습니다.")
        })();
}</code></pre>
                <P>전통적인 함수 표현식을 사용한 즉시 실행 함수 : 이 형태는 익명 함수를 괄호 ()로 감싸고, 함수 정의 바로 뒤에 ()를 추가하여 함수를 즉시 실행합니다. <br />
                <P>화살표 함수를 사용한 즉시 실행 함수 : 이 형태는 ES6에서 도입된 화살표 함수(=>)를 사용하여 더 간결한 문법으로 즉시 실행 함수를 작성합니다. 마찬가지로, 함수를 괄호로
                    감싸고 함수 정의 바로 뒤에 실행을 위한 ()를 추가합니다. <br />

                    즉시 실행 함수는 주로 초기화 코드, 설정, 라이브러리 코드의 스코프를 제한하는 등의 용도로 사용됩니다. 이러한 패턴은 자바스크립트에서 매우 유용하게 활용됩니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            25-1. 실행되었습니다. <br />
                            25-2. 실행되었습니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample20 -->
            <div id="sample21" class="sample">
                <h3>21. 함수 : 파라미터 함수</h3>
                <p>
                    #첫 번째 함수: func <br />
                    *str은 이 함수의 매개변수입니다. <br />
                    *= "26-1. 실행되었습니다."는 str 매개변수에 기본값을 할당하는 부분입니다. 이는 func 함수가 호출될 때 str 매개변수에 아무런 값도 전달되지 않았을 경우 사용될
                    기본값을 지정합니다. <br />
                    *console.log(str)는 매개변수 str의 값을 콘솔에 출력합니다. <br />
                    func();라고 호출했을 때, str 매개변수에 아무런 값도 전달되지 않으므로 기본값인 "26-1. 실행되었습니다."가 사용되어 이 문자열이 콘솔에 출력됩니다.
                </p>
                <pre><code>{        
        function func(str = "26-1. 실행되었습니다.") {
            console.log(str)
        }
        func();     //01
        
        const func1 = (str = "26-2. 실행되었습니다.") => {
            console.log(str)
        }
        func1();    //02
}</code></pre>
                <P>#두 번째 함수: func1 <br />
                    *여기서도 str 매개변수에 기본값 "26-2. 실행되었습니다."가 할당됩니다. <br />
                    *화살표(=>) 뒤에 오는 {} 안의 코드가 함수의 본문입니다. <br />
                    *console.log(str)로 str 매개변수의 값을 콘솔에 출력합니다. <br />
                    func1();라고 호출했을 때, 마찬가지로 str 매개변수에 아무런 값도 전달되지 않으므로 기본값인 "26-2. 실행되었습니다."가 사용되어 이 문자열이 콘솔에 출력됩니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            26-1. 실행되었습니다. <br />
                            26-2. 실행되었습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            이 코드는 두 가지 방식(전통적인 함수 선언과 화살표 함수 표현식)으로 함수를 정의하고, 매개변수에 기본값을 할당하는 방법을 보여줍니다.
                            함수가 호출될 때 매개변수에 값이 전달되지 않으면 기본값이 사용됩니다.
                            이러한 기능을 사용하면 함수를 더 유연하게 작성할 수 있으며, 매개변수의 기본값을 통해 함수가 예상치 못한 입력값으로 인해
                            오류를 발생시키는 것을 방지할 수 있습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample21 -->
            <div id="sample22" class="sample">
                <h3>22. 함수 : 재귀 함수</h3>
                <p>
                    재귀 함수는 자기 자신을 호출하는 함수입니다. 재귀 함수를 사용하면 복잡한 문제를 간단하게 풀거나 코드를 더 깔끔하게 작성할 수 있습니다. 하지만 재귀 함수를 사용할 때는 종료
                    조건을 반드시 정의해야 합니다.
                    그렇지 않으면 함수가 무한히 자기 자신을 호출하게 되어 프로그램이 멈추거나 오류를 발생시킬 수 있습니다.
                </p>

                <pre><code>{        
        //01 반복문을 사용하는 경우
        function func(num) {
            for (let i = 0; i &lt; num; i++) {
                console.log("27-1. 실행되었습니다.")
            }
        }
        func(10)

        //02 재귀함수를 사용하기
        function func1(num) {
            if (num &lt; 1) return;

            console.log("27-2. 실행되었습니다.")
            func1(num - 1); //재귀 호출
        }
        func1(10)
}</code></pre>
                <p>
                    #01 반복문을 사용하는 경우 <br />
                    이 코드는 func라는 함수를 정의하고, 이 함수는 매개변수 num을 받아서 그 수만큼 반복하여 "27-1. 실행되었습니다."라는 메시지를 콘솔에 출력합니다. 여기서는 for
                    반복문을 사용하여 이 작업을 수행합니다. func(10)을 호출하면, 메시지가 10번 콘솔에 출력됩니다.
                </p>
                <p>
                    #02 재귀함수를 사용하기 <br />
                    이 코드에서 func1은 재귀 함수입니다. 이 함수는 자기 자신(func1)을 호출하는데, 호출할 때마다 num 매개변수의 값을 1씩 감소시킵니다. <br />
                    *종료 조건: if (num &lt; 1) return; 이 부분이 종료 조건입니다. num이 1 미만이 되면 함수는 더 이상 자기 자신을 호출하지 않고 종료됩니다. 이는 재귀
                    함수가 무한히 실행되는 것을 방지합니다. <br />
                    *재귀 호출: func1(num - 1);는 현재 함수를 다시 호출하면서 num의 값을 1 감소시킨 값으로 전달합니다. 이렇게 자기 자신을 호출하는 과정을 반복하면서 문제를
                    해결합니다. <br />

                    func1(10)을 호출하면, "27-2. 실행되었습니다."라는 메시지가 콘솔에 10번 출력됩니다. 각 호출마다 num 값이 1씩 감소하고, num이 0이 되면 함수는 더 이상
                    자기 자신을 호출하지 않고 종료됩니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            27-1. 실행되었습니다. <br />
                            27-2. 실행되었습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            재귀 함수는 복잡한 반복 작업을 단순화할 수 있는 강력한 도구입니다.
                            그러나 재귀 함수를 사용할 때는 반드시 종료 조건을 명시해야 하며, 재귀의 깊이가 너무 깊어지지 않도록 주의해야 합니다.
                            너무 깊은 재귀는 스택 오버플로우를 일으킬 수 있으므로, 재귀 함수의 사용은 적절한 상황에서 신중하게 이루어져야 합니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample22 -->
            <div id="sample23" class="sample">
                <h3>23. 함수 : 콜백 함수</h3>
                <p>
                    콜백 함수(callback function)란 다른 함수의 인자로 전달되어, 그 함수 내부에서 실행되는 함수를 말합니다. 콜백 함수는 자바스크립트에서 비동기 처리, 이벤트 처리,
                    반복 작업 수행 등 다양한 곳에서 활용됩니다.
                </p>

                <pre><code>{        
        //01 이벤트
        function func() {
            console.log("28-1. 실행되었습니다.")
        }
        // btn.addEventListener("click", func)

        //02 함수를 다른 함수의 인자로 전달
        function func1() {
            console.log("28-2. 실행되었습니다.")
        }
        function func2(callback) {
            callback()
        }
        func2(func1)

        //03 반복문을 사용하는 경우
        function func3(num) {
            console.log(num + ". 실행되었습니다.")
        }
        function func4(callback) {
            for (let i = 23; i &lt; 28; i++) {
                callback(i)
            }
        }
        func4(func3)
}</code></pre>
                <p>
                    #01 이벤트 <br />
                    위 코드에서 func 함수는 이벤트 리스너에 콜백 함수로 전달됩니다. 사용자가 버튼(btn)을 클릭하면, func 함수가 호출되어 "28-1. 실행되었습니다."를 콘솔에
                    출력합니다. 이 경우, func 함수는 직접 호출하지 않고, 이벤트 발생 시 자동으로 호출됩니다.
                </p>
                <p>
                    #02 함수를 다른 함수의 인자로 전달 <br />
                    여기서 func1 함수는 func2 함수에 인자로 전달되며, func2의 내부에서 callback()을 통해 func1이 호출됩니다. 즉, func1이 콜백 함수로 작동하는
                    것입니다. 이 방식을 통해 func2 함수는 어떤 구체적인 작업을 수행할지를 func1을 통해 유연하게 결정할 수 있습니다
                </p>
                <p>
                    #03 반복문을 사용하는 경우 <br />
                    func4 함수는 반복문을 포함하고 있으며, 반복문의 각 반복에서 callback 함수를 호출합니다. func3 함수가 func4에 콜백 함수로 전달되었기 때문에, 23부터
                    27까지의 숫자를 인자로 받아 콘솔에 출력합니다. 이러한 방식으로, 콜백 함수는 반복적인 작업을 수행할 때 유용하게 사용할 수 있습니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            01. 28-1. 실행되었습니다. (버튼을 눌렀을 경우) <br />
                            02. 28-2. 실행되었습니다. <br />
                            03. 23. 실행되었습니다. <br />
                            03. 24. 실행되었습니다. <br />
                            03. 25. 실행되었습니다. <br />
                            03. 26. 실행되었습니다. <br />
                            03. 27. 실행되었습니다. <br />
                        </div>
                    </details>
                    <details>
                        <summary>콜백 함수의 특징 및 활용</summary>
                        <div>
                            비동기 처리: 콜백 함수는 주로 비동기 작업(예: 네트워크 요청, 파일 I/O 등)의 결과를 처리할 때 사용됩니다.<br />
                            이벤트 처리: 사용자 입력, DOM 이벤트 등에 응답하기 위해 콜백 함수를 사용할 수 있습니다.<br />
                            고차 함수: 함수를 인자로 받거나 함수를 반환하는 함수(고차 함수)를 구현할 때 콜백 함수가 활용됩니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample23 -->
            <div id="sample24" class="sample">
                <h3>23. 함수 : 콜백 함수</h3>
                <p>
                    비동기 프로그래밍은 JavaScript와 같은 언어에서 매우 중요한 개념입니다. 특히 웹 개발에서, 네트워크 요청, 파일 I/O, 타이머 등과 같이 시간이 걸리는 작업들을 처리할
                    때 유용합니다. 이러한 작업들을 동기적으로 처리하면, 작업이 완료될 때까지 코드의 실행이 멈추게 되어 애플리케이션의 반응성이 떨어질 수 있습니다. 반면, 비동기 방식을 사용하면
                    이러한 작업들을 백그라운드에서 실행시키고, 작업이 완료되면 콜백 함수를 통해 결과를 처리할 수 있습니다. 이를 통해 애플리케이션의 반응성을 향상시킬 수 있습니다.
                </p>

                <pre><code>{        
        // 동기 : 작업이 순서대로 코드는 위에서 아래로 순차적으로 진행, 한 작업이 끝나면 다음 작업이 시작.

        //비동기 : 작업이 순서와 관계없이 여러 작업 처리 가능. (콜백 함수, 프로미스, asyns/await 등을 사용하여 작업이 완료될 때까지 대기하지 않고 다른 작업을 진행할 수 있음.)

        //01 동기적인 함수 호출
        function func1() {
            console.log("29-1. 실행되었습니다")
        }
        function func2() {
            console.log("29-2. 실행되었습니다")
        }
        func2();
        func1();

        // //02 비동기적인 함수 호출
        function func3() {
            setTimeout(() => {
                console.log("29-3. 실행되었습니다");
            }, 1000)

        }
        function func4() {
            console.log("29-4. 실행되었습니다");
        }
        func3();
        func4();

        // //03 콜백 함수 비동기 호출

        function func5(callback) {
            setTimeout(() => {
                console.log("29-5. 실행되었습니다")
                callback();
            }, 1000)
        }
        function func6() {
            console.log("29-6. 실행되었습니다")
        }

        func5(function () {
            func6();
        });
}</code></pre>
                <p>
                    #01 동기적인 함수 호출 <br />
                    이 예제에서는 func2()가 호출된 후 func1()이 호출됩니다. 각 함수의 로그는 호출 순서대로 출력됩니다. 이는 동기적인 실행의 예입니다.
                </p>
                <p>
                    #02 비동기적인 함수 호출 <br />
                    여기서 func1 함수는 func2 함수에 인자로 전달되며, func2의 내부에서 callback()을 통해 func1이 호출됩니다. 즉, func1이 콜백 함수로 작동하는
                    것입니다. 이 방식을 통해 func2 함수는 어떤 구체적인 작업을 수행할지를 func1을 통해 유연하게 결정할 수 있습니다
                </p>
                <p>
                    #03 콜백 함수 비동기 호출 <br />
                    func5()는 비동기적으로 동작하는 함수로, 내부에서 setTimeout을 사용하여 1초 후에 로그를 출력하고, 이후 콜백 함수를 호출합니다. func5()에 func6을
                    콜백으로 전달하면, "29-5. 실행되었습니다"가 출력된 후 1초 뒤에 "29-6. 실행되었습니다"가 출력됩니다. 이는 비동기 작업이 완료된 후 특정 작업을 수행하고자 할 때 콜백
                    함수를 사용하는 방식입니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            29-1. 실행되었습니다 <br />
                            29-2. 실행되었습니다 <br />
                            29-3. 실행되었습니다 <br />
                            29-4. 실행되었습니다 <br />
                            29-5. 실행되었습니다 <br />
                            29-6. 실행되었습니다 <br />
                        </div>
                    </details>
                    <details>
                        <summary>정리</summary>
                        <div>
                            비동기 방식은 코드의 실행 흐름을 제어할 수 있게 해주며, 특히 웹 애플리케이션에서 사용자 경험을 크게 향상시킬 수 있습니다. 그러나 콜백 지옥(callback
                            hell)과 같은 문제를 일으킬 수 있기 때문에, 현대 JavaScript에서는 Promise와 async/await 같은 더 강력하고 효율적인 비동기 처리 패턴을
                            제공합니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample23 -->
            <div id="sample26" class="sample">
                <h3>26. 함수 : 비동기 방식 : asyne/await</h3>
                <p>
                    JavaScript에서 비동기 프로그래밍을 구현하기 위해 async/await 문법을 사용할 수 있습니다. 이는 비동기 코드를 동기 코드처럼 보이고 작동하게 만들어, 코드의
                    가독성과 유지보수성을 크게 향상시킵니다.
                </p>

                <pre><code>{        
        //01
        function func() {
            console.log("31-1. 실행되었습니다.")
        }
        func();
        //02 : 함수(비동기방식)
        async function func2() {
            console.log("31-2. 실행되었습니다.")
        }
        func2();
        //03 : 비동기 방식(fetch)
        async function func3() {
            const result = await fetch("https://sunhew.github.io/class2024/json/gineungsaJC2005_05.json");
            const data = await result.json();
            console.log(data);
        }
        func3()

        //04 : 비동기 + 에러
        async function func4() {
            try {
                const result = await fetch("https://sunhew.github.io/class2024/json/gineungsaJC2005_05.json");
                const data = await result.json();
                console.log(data);
            } catch (error) {
                console.error(error);
            }
        }
        func4();
}</code></pre>
                <p>
                    #01 기본 함수 실행 <br />
                    func 함수는 단순히 문자열 "31-1. 실행되었습니다."를 콘솔에 출력하는 기본적인 동기 함수입니다. 호출 시 즉시 실행됩니다.
                </p>
                <p>
                    #02 비동기 함수 (async 함수) <br />
                    async 키워드를 사용해 func2 함수를 비동기 함수로 선언합니다. async 함수 내부에서는 비동기 작업을 동기적으로 표현할 수 있습니다. 여기서는 비동기 작업이 없지만,
                    async 함수이기 때문에 func2를 호출하면 프로미스(Promise)를 반환합니다. 함수 내부에서 비동기 작업이 없으므로 즉시 "31-2. 실행되었습니다."를 출력합니다.
                </p>
                <p>
                    #03 비동기 처리 (fetch 사용) <br />
                    func3 함수는 fetch API를 사용해 비동기적으로 데이터를 요청하고, 그 결과를 처리합니다. await 키워드는 fetch 함수 호출이 완료될 때까지 JavaScript
                    런타임에게 기다리라고 지시합니다. fetch의 결과(응답)가 도착하면, 그 결과를 JSON 형태로 변환하고, 최종 데이터를 콘솔에 출력합니다.
                </p>
                <p>
                    #03 비동기 처리 및 에러 처리 <br />
                    func4 함수는 func3와 유사하지만, 여기에는 try/catch 구문을 추가하여 에러 처리를 구현하고 있습니다. await 키워드를 사용하는 비동기 호출이 실패하거나 예외를
                    발생시킬 경우, catch 블록이 실행되어 에러를 콘솔에 출력합니다. 이렇게 함으로써 비동기 작업 중 발생할 수 있는 예외 상황을 안전하게 처리할 수 있습니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            31-1. 실행되었습니다 <br />
                            31-2. 실행되었습니다 <br />
                            json 파일속 내용이 배열에 감싸져 나옴 <br />
                        </div>
                    </details>
                    <details>
                        <summary>정리</summary>
                        <div>
                            async/await는 JavaScript의 비동기 프로그래밍을 간결하고 직관적으로 만들어주는 강력한 기능입니다. async로 함수를 선언하면 해당 함수는 항상
                            프로미스를 반환하며, 함수 내부에서 await를 사용해 프로미스의 결과가 준비될 때까지 기다릴 수 있습니다. 이를 통해 비동기 로직을 마치 동기 코드처럼 쉽게
                            작성하고 이해할 수 있습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample26 -->
        </div>
        <!-- //main__sample -->

    </main>
    <!-- //main -->

    <footer id="footer">

    </footer>
    <!-- //footer -->

    <button onclick="topFunction()" id="scrollTopBtn" title="Go to top">목록</button>
    <script src="assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>
        //01. 함수 : 선언적 함수
        {
            function func() {
                console.log("01. 함수")
            }
            func();
        }

        //02. 함수 : 익명 함수
        {
            const func = function () {
                console.log("02. 함수")
            }
            func();
        }

        //03. 함수 : 매개변수 함수
        {
            function func(str) {
                console.log(str)
            }
            func("03.매개변수");
        }
        {
            const func = function (str) {
                console.log(str)
            }
            func("03-2.매개변수");
        }

        //04. 함수 : 리턴값 함수
        {
            function func() {
                return "04.리턴"
            }
            console.log(func())
        }
        {
            const func = function () {
                return "04-2.리턴"
            }
            console.log(func())
        }

        //05. 함수 : 매개변수 + 리턴값 함수
        {
            function func(srt) {
                return srt
            }
            console.log(func("05.매개함수"))
        }
        {
            const func = function (srt) {
                return srt
            }
            console.log(func("05-2.매개함수"))
        }

        //06. 화살표 : 선언적 함수
        {
            func = () => {
                console.log("06. 화살표 : 선언적 함수")
            }
            func();
        }

        //07. 화살표 : 익명 함수
        {
            const func = () => {
                console.log("07. 화살표 : 익명 함수")
            }
            func();
        }

        //08. 화살표 : 매개변수 함수
        {
            func = (str) => {
                console.log(str)
            }
            func("08. 화살표 : 매개변수 함수");
        }
        {
            const func = (str) => {
                console.log(str)
            }
            func("08-2. 화살표 : 매개변수 함수");
        }

        //09. 화살표 : 리턴값(결과, 종료)
        {
            func = () => {
                return "09. 화살표 : 리턴값"
            }
            console.log(func())
        }
        {
            const func = () => {
                return "09-2. 화살표 : 리턴값"
            }
            console.log(func())
        }

        //10. 화살표 : 매개변수 + 리턴값 함수  *가장 중요*
        {
            func = (srt) => {
                return srt
            }
            console.log(func("10. 화살표 : 매개변수 + 리턴값 함수"))
        }
        {
            const func = (srt) => {
                return srt
            }
            console.log(func("10-2. 화살표 : 매개변수 + 리턴값 함수"))
        }

        //11. 함수 유형 : 함수와 매개변수를 이용한 형태   (제일 많이 쓰임)
        {
            function func(x, y) {
                console.log(x, y)
            }
            func("11.", "실행되었습니다.")
        }

        //12. 함수 유형 : 함수와 변수를 이용한 형태    //퀴즈게임 4번에서 사용했음.
        {
            const x = "12", y = "실행되었습니다."

            function func(x, y) {
                console.log(x, y)
            }
            func(x, y)
        }
        //13. 함수 유형 : 함수와 배열을 이용한 형태    //퀴즈게임 4번에서 사용했음.
        {
            const x = ["13", "14"];
            const y = "실행되었습니다."

            function func(x, y) {
                console.log(x, y);
            }
            func(x[0], y)
            func(x[1], y)
        }
        //14. 함수 유형 : 함수와 객체를 이용한 형태
        {
            const x = {
                a: "15",
                b: "실행되었습니다."
            }
            function func(x, y) {
                console.log(x, y);
            }
            func(x.a, x.b)
        }
        //15. 함수 유형 : 함수와 객체및 배열을 이용한 형태
        {
            const info = [
                { a: "16", b: "실행되었습니다." },
                { c: "17", d: "실행되었습니다." }
            ]
            function func(x, y) {
                console.log(x, y);
            }
            func(info[0].a, info[0].b)
            func(info[1].c, info[1].d)
        }
        //16. 함수 유형 : 객체안에 함수를 이용한 형태           //가장 중요함
        {
            const info = {
                num: "18",
                str: "실행되었습니다.",
                result: () => {
                    console.log(`${info.num}.${info.str}`)
                }
            }
            info.result();
        }
        //17. 함수 유형 : 객체 생성자 함수
        {
            function Func(num, str) {
                this.num = num;
                this.str = str;
                this.result = function () {
                    console.log(`${this.num}.${this.str}`);
                }
            }
            // 인스턴스 생성
            const info1 = new Func("19", "실행되었습니다.");
            const info2 = new Func("20", "실행되었습니다.");

            // 호출
            info1.result();
            info2.result();
        }
        //18. 함수 유형 : 프로토타입 함수
        {
            //함수 정의
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }

            //메서드 추가
            Func.prototype.result = function () {
                console.log(`${this.num}.${this.str}`)
            }

            //인스턴스생성
            const info1 = new Func("21", "실행되었습니다.")
            const info2 = new Func("22", "실행되었습니다.")

            // 호출
            info1.result();
            info2.result();
        }
        //19. 함수 유형 : 객체 리터릴 함수
        {
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }

            //메서드 추가
            Func.prototype = {
                result1: function () {
                    console.log(`${this.num}.${this.str}`)
                },
                result2: function () {
                    console.log(`${this.num}.${this.str}`)
                },
            }

            //인스턴스생성
            const info1 = new Func("23", "실행되었습니다.")
            const info2 = new Func("24", "실행되었습니다.")

            // 호출
            info1.result1();
            info2.result2();
        }
        //20. 함수 : 즉시 실행 함수
        {
            (function () {
                console.log("25-1. 실행되었습니다.")
            })();
            (() => {
                console.log("25-2. 실행되었습니다.")
            })();
        }
        //21. 함수 : 파라미터 함수
        {
            function func(str = "26-1. 실행되었습니다.") {
                console.log(str)
            }
            func();
            const func1 = (str = "26-2. 실행되었습니다.") => {
                console.log(str)
            }
            func1();
        }
        //22. 함수 : 재귀 함수
        {
            //01 반복문을 사용하는 경우
            function func(num) {
                for (let i = 0; i < num; i++) {
                    console.log("27-1. 실행되었습니다.")
                }
            }
            func(10)

            //02 재귀함수를 사용하기
            function func1(num) {
                if (num < 1) return;

                console.log("27-2. 실행되었습니다.")
                func1(num - 1); //재귀 호출
            }
            func1(10)
        }
        //23. 함수 : 콜백 함수
        {
            //01 이벤트
            function func() {
                console.log("28-1. 실행되었습니다.")
            }
            // btn.addEventListener("click", func)

            //02 함수를 다른 함수의 인자로 전달
            function func1() {
                console.log("28-2. 실행되었습니다.")
            }
            function func2(callback) {
                callback()
            }
            func2(func1)

            //03 반복문을 사용하는 경우
            function func3(num) {
                console.log(num + ". 실행되었습니다.")
            }
            function func4(callback) {
                for (let i = 23; i < 28; i++) {
                    callback(i)
                }
            }
            func4(func3)
        }
        //24. 함수 : 비동기 방식 : 콜백 함수
        {
            // 동기 : 작업이 순서대로 코드는 위에서 아래로 순차적으로 진행, 한 작업이 끝나면 다음 작업이 시작.

            //비동기 : 작업이 순서와 관계없이 여러 작업 처리 가능. (콜백 함수, 프로미스, asyns/await 등을 사용하여 작업이 완료될 때까지 대기하지 않고 다른 작업을 진행할 수 있음.)

            //01 동기적인 함수 호출
            function func1() {
                console.log("29-1. 실행되었습니다")
            }
            function func2() {
                console.log("29-2. 실행되었습니다")
            }
            func2();
            func1();

            // //02 비동기적인 함수 호출
            function func3() {
                setTimeout(() => {
                    console.log("29-3. 실행되었습니다");
                }, 1000)

            }
            function func4() {
                console.log("29-4. 실행되었습니다");
            }
            func3();
            func4();

            // //03 콜백 함수 비동기 호출

            function func5(callback) {
                setTimeout(() => {
                    console.log("29-5. 실행되었습니다")
                    callback();
                }, 1000)
            }
            function func6() {
                console.log("29-6. 실행되었습니다")
            }

            func5(function () {
                func6();
            });
        }
        //25. 함수 : 비동기 방식 : 프로미스
        //26. 함수 : 비동기 방식 : asyne/await
        {
            //01
            function func() {
                console.log("31-1. 실행되었습니다.")
            }
            func();
            //02 : 함수(비동기방식)
            async function func2() {
                console.log("31-2. 실행되었습니다.")
            }
            func2();
            //03 : 비동기 방식(fetch)
            async function func3() {
                const result = await fetch("https://sunhew.github.io/class2024/json/gineungsaJC2005_05.json");
                const data = await result.json();
                console.log(data);
            }
            func3()

            //04 : 비동기 + 에러
            async function func4() {
                try {
                    const result = await fetch("https://sunhew.github.io/class2024/json/gineungsaJC2005_05.json");
                    const data = await result.json();
                    console.log(data);
                } catch (error) {
                    console.error(error);
                }
            }
            func4();
        }
        //27. 함수 : 중첩 함수

        //28. 함수 : 클로저

        //29. 클래스 : 기본

        //30. 클래스 : 상속



        //목록 클릭시 해당 본문으로 이동
        document.addEventListener("DOMContentLoaded", function () {
            // 메뉴 아이템 클릭 이벤트 리스너 추가
            document.querySelectorAll('.main__menu a').forEach(item => {
                item.addEventListener('click', function (e) {
                    e.preventDefault(); // 기본 이벤트 동작 방지

                    // 클릭된 메뉴 항목에 해당하는 샘플 섹션으로 이동
                    // 메뉴 항목 텍스트에서 숫자 추출
                    const itemText = this.innerText;
                    const match = itemText.match(/\d+/); // 숫자만 추출
                    if (match) {
                        const sampleId = `sample${match[0].padStart(2, '0')}`; // ID 형식에 맞춤
                        const sampleElement = document.getElementById(sampleId);
                        if (sampleElement) {
                            sampleElement.scrollIntoView({ behavior: 'smooth' }); // 스무스 스크롤
                        }
                    }
                });
            });
        })
        // 스크롤 감지해서 버튼 표시
        window.onscroll = function () { scrollFunction() };

        function scrollFunction() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                document.getElementById("scrollTopBtn").style.display = "block";
            } else {
                document.getElementById("scrollTopBtn").style.display = "none";
            }
        }

        // 맨 위로 스크롤
        function topFunction() {
            document.body.scrollTop = 0; // 사파리 브라우저를 위함
            document.documentElement.scrollTop = 0; // 크롬, 파이어폭스, IE, 오페라
        }
    </script>
    <!-- //공부 -->
</body>

</html>