<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 :: 데이터 저장하기</title>

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/default.min.css">
    <style>
        /* 맨 위로 올라가는 스크롤 버튼 */
        #scrollTopBtn {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: none;
            font-size: 18px;
            background-color: #555;
            color: white;
            cursor: pointer;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <header id="header">
        <h1>
            <a href="index.html">javascript</a>
        </h1>
        <nav>
            <ul>
                <li class="active"><a href="javascript01.html">데이터 저장하기</a></li>
                <li><a href="javascript02.html">데이터 불러오기</a></li>
                <li><a href="javascript03.html">데이터 실행하기</a></li>
                <li><a href="javascript04.html">데이터 제어하기</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="main__menu container">
            <ul>
                <li><a href="#">01 : 연산자(논리, 산술, 비교, 조건 등)</a></li>
                <li><a href="#">02 : 자료형</a></li>

                <li><a href="#">03. 변수 : 데이터 저장</a></li>
                <li><a href="#">04. 변수 : 데이터 저장 + 데이터 변경</a></li>
                <li><a href="#">05. 변수 : 데이터 저장 + 데이터 변경 + 데이터 추가</a></li>

                <li><a href="#">06. 상수 : 데이터 저장 + 데이터 변경(x)</a></li>

                <li><a href="#">07. 배열 : 데이터 저장(여러개) : 표현방법1 : 배열 선언</a></li>
                <li><a href="#">08. 배열 : 데이터 저장(여러개) : 표현방법2 : 배열 선언과 동시에 초깃값 설정</a></li>
                <li><a href="#">09. 배열 : 데이터 저장(여러개) : 표현방법3 : 리터럴 방식으로 배열 선언</a></li>
                <li><a href="#">10. 배열 : 데이터 저장(여러개) : 표현방법4 : 리터럴 방식으로 배열 선언과 동시에 초깃값</a></li>
                <li><a href="#">11. 배열 : 데이터 저장(여러개) : 표현방법5 : PUSH() 매서드를 이용한 데이터 저장</a></li>
                <li><a href="#">12. 배열 : 데이터 저장(여러개) : 표현방법6 : 다차원 배열</a></li>
                <li><a href="#">13. 배열 : 데이터 저장(여러개) : 표현방법7 : 배열 구조 분해 할당</a></li>
                <li><a href="#">14. 배열 : 데이터 저장(여러개) : 표현방법7 : 배열 펼침 연산자</a></li>

                <li><a href="#">15. 객체 : 데이터 저장(키와값) : 표현방법1 : 객체 선언 후 배열방식으로 데이터 입력</a></li>
                <li><a href="#">16. 객체 : 데이터 저장(키와값) : 표현방법2 : 객체 선언 후 객체방식으로 데이터 입력</a></li>
                <li><a href="#">17. 객체 : 데이터 저장(키와값) : 표현방법3 : 리터럴 방식으로 객체 선언</a></li>
                <li><a href="#">18. 객체 : 데이터 저장(키와값) : 표현방법4 : 리터럴 방식으로 객체 선언과 동시에 초깃값 설정</a></li>
                <li><a href="#">19. 객체 : 데이터 저장(키와값) : 표현방법5 : 배열안에 객체가 있는 방식</a></li>
                <li><a href="#">20. 객체 : 데이터 저장(키와값) : 표현방법6 : 객체안에 배열이 있는 방식</a></li>
                <li><a href="#">21. 객체 : 데이터 저장(키와값) : 표현방법7 : 객체안에 객체가 있는 방식</a></li>
                <li><a href="#">22. 객체 : 데이터 저장(키와값) : 표현방법8 : 객체안에 함수가 있는 방식</a></li>
                <li><a href="#">23. 객체 : 데이터 저장(키와값) : 표현방법9 : 객체 구조 분해 할당</a></li>
                <li><a href="#">24. 객체 : 데이터 저장(키와값) : 표현방법10 : 객체 펼침 연산자</a></li>

                <li><a href="#">25. 파일 : 데이터 교환(JSON)</a></li>
            </ul>
        </div>
        <!-- //main__menu -->

        <div class="main__sample container">
            <div id="sample01" class="sample">
                <h3>01 : 연산자(논리, 산술, 비교, 조건 등)</h3>
                <p>자바스크립트에서 사용되는 다양한 연산자에 대해 코드 예제를 통해 자세히 알아보겠습니다.
                    연산자는 크게 논리 연산자, 산술 연산자, 비교 연산자, 조건(삼항) 연산자 등으로 구분할 수 있습니다.</p>
                <p>1. 산술 연산자 <br />
                    산술 연산자는 수학적 계산을 위해 사용됩니다.</p>
                <pre><code>{
        let a = 10;
        let b = 5;
        
        console.log(a + b); // 15 (더하기)
        console.log(a - b); // 5  (빼기)
        console.log(a * b); // 50 (곱하기)
        console.log(a / b); // 2  (나누기)
        console.log(a % b); // 0  (나머지)
}</code></pre>
                <p>2. 비교 연산자 <br />
                    비교 연산자는 두 값을 비교하고, 그 결과로 true 또는 false를 반환합니다.</p>
                <pre><code>{
        let c = 10;
        let d = "10";
        
        console.log(c == d);  // true  (동등 비교, 값만 비교)
        console.log(c === d); // false (일치 비교, 값과 타입 모두 비교)
        console.log(c != d);  // false (부등 비교)
        console.log(c !== d); // true  (불일치 비교)
        console.log(c &gt; d);   // false (크다)
        console.log(c &lt; d);   // false (작다)
        console.log(c &gt;= d);  // true  (크거나 같다)
        console.log(c &lt;= d);  // true  (작거나 같다)
}</code></pre>
                <p>3. 논리 연산자<br />
                    논리 연산자는 논리적 조합을 평가할 때 사용됩니다.</p>
                <pre><code>{
        let e = true;
        let f = false;
        
        console.log(e && f); // false (논리적 AND)
        console.log(e || f); // true  (논리적 OR)
        console.log(!e);     // false (논리적 NOT)
}</code></pre>
                <p>4. 조건(삼항) 연산자<br />
                    삼항 연산자는 조건에 따라 두 개의 값을 반환할 수 있는 유일한 연산자입니다.</p>
                <pre><code>{
        let age = 20;

        console.log(age >= 18 ? "성인" : "미성년자"); // "성인"
}</code></pre>
                <p>5. 할당 연산자<br />
                    할당 연산자는 변수에 값을 할당할 때 사용됩니다.</p>
                <pre><code>{
        let g = 10;
        g += 5; // g = g + 5와 동일
        console.log(g); // 15
        
        g *= 2; // g = g * 2와 동일
        console.log(g); // 30
}</code></pre>
                <p>6. 증가 및 감소 연산자<br />
                    변수의 값을 1씩 증가시키거나 감소시킵니다.</p>
                <pre><code>{
        let h = 10;
        console.log(h++); // 10 (후위 증가 연산자, 출력 후 증가)
        console.log(++h); // 12 (전위 증가 연산자, 증가 후 출력)
        
        let i = 10;
        console.log(i--); // 10 (후위 감소 연산자, 출력 후 감소)
        console.log(--i); // 8  (전위 감소 연산자, 감소 후 출력)
}</code></pre>
                <p>7. 문자열 연결 연산자<br />
                    + 연산자는 두 문자열을 연결할 때도 사용됩니다.</p>
                <pre><code>{
        let firstName = "홍";
        let lastName = "길동";
        
        console.log(firstName + " " + lastName); // "홍 길동"
}</code></pre>
            </div>
            <!-- //sample01 -->
            <div id="sample02" class="sample">
                <h3>02 : 자료형</h3>
                <p>자바스크립트에서는 크게 원시 자료형(Primitive data types)과 객체 자료형(Object data types)으로 분류할 수 있습니다.</p>
                <h4>*원시 자료형 (Primitive data types) </h4>
                <p>1. Number: 숫자를 표현하는 자료형입니다. 정수와 실수 구분 없이 하나의 숫자 자료형만 존재합니다.</p>
                <pre><code>{
        let num = 123; // 정수
        let floatNum = 12.34; // 실수
        console.log(num, floatNum);
}</code></pre>
                <p>2. String: 문자열을 표현하는 자료형입니다. 작은따옴표('), 큰따옴표("), 백틱(``` `)으로 묶어 표현합니다.</p>
                <pre><code>{
        let str = "Hello, world!"; // 큰따옴표 문자열
        let char = 'A'; // 작은따옴표 문자열
        let templateLiteral = `Template literal`; // 백틱 문자열
        console.log(str, char, templateLiteral);
}</code></pre>
                <p>3. Boolean: 참(true) 또는 거짓(false)을 표현하는 자료형입니다.</p>
                <pre><code>{
        let isTrue = true;
        let isFalse = false;
        console.log(isTrue, isFalse);
}</code></pre>
                <p>4. Undefined: 값이 할당되지 않은 상태를 나타내는 자료형입니다.</p>
                <pre><code>{
        let notAssigned;
        console.log(notAssigned); // undefined
}</code></pre>
                <p>5. Null: '아무것도 없음'을 명시적으로 표현하는 자료형입니다.<br />
                    할당 연산자는 변수에 값을 할당할 때 사용됩니다.</p>
                <pre><code>{
        let empty = null;
        console.log(empty); // null
}</code></pre>
                <p>6. Symbol: ES6에서 추가된 자료형으로, 고유하고 변경할 수 없는 값을 생성할 때 사용합니다.</p>
                <pre><code>{
        let symbol1 = Symbol("id");
        let symbol2 = Symbol("id");
        console.log(symbol1 === symbol2); // false, 심볼은 각각 고유합니다.
}</code></pre>
                <p>7. BigInt: ES2020에서 도입된 자료형으로, 매우 큰 정수를 표현할 때 사용합니다.</p>
                <pre><code>{
        let bigInt = 1234567890123456789012345678901234567890n;
        console.log(bigInt);
}</code></pre>
                <!-- //원시 자료형 -->
                <h4>*객체 자료형 (Object data types)</h4>
                <p>1. Object: 여러 값을 하나의 복합 데이터로 그룹핑할 수 있으며, key-value 쌍으로 데이터를 저장합니다.</p>
                <pre><code>{
        let person = {
            name: "John",
            age: 30
        };
        console.log(person);
}</code></pre>
                <p>2. Array: 여러 개의 값을 순서대로 저장하는데 사용되는 자료형입니다.</p>
                <pre><code>{
        let numbers = [1, 2, 3, 4, 5];
        console.log(numbers);
}</code></pre>
                <p>3. Function: 함수를 정의할 때 사용되는 자료형입니다.</p>
                <pre><code>{
        function greet() {
            console.log("Hello, world!");
        }
        greet(); // 함수 호출
}</code></pre>
            </div>
            <!-- //sample02 -->
            <div id="sample03" class="sample">
                <h3>03. 변수 : 데이터 저장</h3>
                <p>
                    자바스크립트에서 변수는 값을 저장하고 창조하는데 사용합니다.
                    변수를 사용하면 데이터를 저장하고 나중에 해당 데이터를 재사용 할 수 있습니다. <br />
                    let 키워드를 사용하여 선언됩니다. 각 변수는 선언된 후에 특정 값을 저장할 수 있고, 이 값은 나중에 참조하거나 변경할 수 있습니다.
                </p>
                <pre><code>{
        let x = 100;
        let y = 200;
        let z = "javascript";

        console.log(x);
        console.log(y);
        console.log(z);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample03 -->
            <div id="sample04" class="sample">
                <h3>04. 변수 : 데이터 저장 + 데이터 변경</h3>
                <p>
                <p>변수의 데이터 저장<br />
                    코드의 첫 부분에서는 x, y, z라는 이름의 세 변수를 선언하고 각각 초기값을 할당합니다. <br /></p>

                <p>변수의 데이터 변경 <br />
                    변경 기호인 '='가 붙으면 x는 300, y는 400, z는 "jquery"라는 새로운 값을 갖게 됩니다.
                    이렇게 변수에 저장된 데이터는 새로운 값으로 업데이트할 수 있으며, 이전에 저장된 값은 덮어쓰기 됩니다.
                </p>
                </p>
                <pre><code>{
        let x = 100;
        let y = 200;
        let z = "javascript";
                    
        x = 300;
        y = 400;
        z = "jquery";
                    
        console.log(x);
        console.log(y);
        console.log(z);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            300 <br />
                            400 <br />
                            jquery <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample04 -->
            <div id="sample05" class="sample">
                <h3>05. 변수 : 데이터 저장 + 데이터 변경 + 데이터 추가</h3>
                <p>
                    변수에 초기값을 저장한 후, 해당 변수에 저장된 데이터는 산술 연산이나 문자열 결합 등을 통해 변경하거나 추가할 수 있습니다.
                    숫자형 변수의 경우 산술 연산을 통해 값이 업데이트되며, 문자열 변수의 경우 += 연산자를 사용하여 기존 문자열에 새로운 문자열을 추가할 수 있습니다.
                </p>
                <pre><code>{
        let x = 100;
        let y = 200;
        let z = "javascript";

        x += 300;
        y += 400;
        z += "jquery";

        console.log(x);
        console.log(y);
        console.log(z);
}</code></pre>
                <p>
                <p> 1.산술 연산자: 이들은 수학적인 계산을 수행하는데 사용됩니다. <br />
                    예시: + (덧셈), - (뺄셈), * (곱셈), / (나눗셈), % (나머지), ++ (1 증가), -- (감소) 등 <br /> </p>

                <p> 2.할당 연산자: 이들은 변수에 값을 할당하는데 사용됩니다. <br />
                    예시: = (할당), += (덧셈 후 할당), -= (뺄셈 후 할당), *= (곱셈 후 할당), /= (나눗셈 후 할당) 등 <br /> </p>

                <p> 3.비교 연산자: 이들은 두 값의 비교를 위해 사용됩니다. <br />
                    예시: == (동등), != (부등), > (초과), &lt; (미만),>= (이상),
                    &lt;= (이하),===(일치), !==(불일치) 등 <br />
                </p>

                <P> 4.논리 연산자: 이들은 논리적인 연산을 수행하는데 사용됩니다. <br />
                    예시: && (논리곱), || (논리합), ! (부정) <br /> </P>

                <p> 5.대입 연산자: 변수에 값을 할당하는 데 사용되는 연산자입니다. <br />
                    =: 할당, +=: 더하기 후 할당, -=: 빼기 후 할당, *=: 곱하기 후 할당, /=: 나누기 후 할당 <br /> </p>

                <p> 6.삼항 연산자: 이 연산자는 세 개의 피연산자를 가지며, 조건에 따라 다른 결과를 반환합니다. <br />
                    이름에서 알 수 있듯이 세 가지 부분으로 구성되어 있습니다: 조건, 참일 때의 값, 그리고 거짓일 때의 값입니다. <br />
                    (예시: 조건 ? 값1 : 값2) 조건이 참이면 값1이 반환되고, 거짓이면 값2가 반환됩니다.
                    위의 예제에서는 age가 21 이상인지 확인하는 조건을 삽입했습니다. <br />
                    이 조건이 참이면 "Beer"를 반환하고, 그렇지 않으면 "Juice"를 반환합니다. <br />
                    이 경우 age는 15이므로 조건은 거짓이며, 따라서 "Juice"가 반환됩니다. <br />
                    삼항 연산자는 간단한 if-else 문을 한 줄로 줄일 수 있어 코드를 간결하게 만드는 데 유용합니다. <br /> </p>


                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            400 <br />
                            600 <br />
                            javascriptjquery <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample05 -->
            <div id="sample06" class="sample">
                <h3>06. 상수 : 데이터 저장 + 데이터 변경(X)</h3>
                <p>
                    상수는 한 번 초기화(값을 할당)하면 그 값을 변경할 수 없는 변수를 말합니다.
                    JavaScript에서는 const 키워드를 사용하여 상수를 선언합니다. <br />
                    이 값들은 상수로 선언되었기 때문에, 초기화 이후에는 변경할 수 없습니다.
                </p>
                <pre><code>{
        const x = 100;
        const y = 200;
        const z = "javascript";

        //x += 300;
        //y += 400;
        //z += "jquery";

        console.log(x);
        console.log(y);
        console.log(z);
}</code></pre>
                <p>
                    코드에서는 다음과 같은 부분이 주석 처리되어 있습니다. <br />
                    만약 이 코드가 주석 처리되지 않고 실행되었다면, x, y, z의 값 변경을 시도하는 코드입니다. <br />
                    하지만 x, y, z는 const 키워드를 사용하여 상수로 선언되었기 때문에, 이러한 변경 시도는 JavaScript에서 오류를 발생시킵니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            const 키워드를 사용하여 상수를 선언하면, 그 상수에 할당된 값은 변경할 수 없습니다. <br />
                            상수는 프로그램에서 변하지 않는 값을 표현할 때 유용하며, 값을 변경할 수 없다는 특성 덕분에 코드의 안정성을 높여줍니다. <br />
                            만약 상수에 다시 값을 할당하려고 시도하면, JavaScript는 오류를 발생시켜 개발자가 실수로 중요한 값을 변경하는 것을 방지합니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample06 -->
            <div id="sample07" class="sample">
                <h3>07 배열 : 데이터 저장(여러개) : 표현방법 1 : 배열 선언</h3>
                <p>
                    JavaScript에서 배열을 선언하는 방법은 여러 가지가 있지만, 이 코드에서는 new Array() 생성자를 사용하여 빈 배열을 선언하는 방식을 보여줍니다. <br />
                    const 키워드를 사용하여 arr이라는 이름의 상수에 배열을 할당합니다. <br />
                    이 배열은 new Array() 생성자를 통해 생성되며, 초기에는 비어 있습니다.
                    const를 사용했기 때문에 arr 변수 자체에 다른 배열이나 다른 타입의 값을 재할당하는 것은 불가능하지만, 배열 내의 요소를 변경하거나 추가하는 것은 가능합니다. <br />
                </p>
                <pre><code>{
        const arr = new Array();

        arr[0] = 100;
        arr[1] = 200;
        arr[2] = "javascript";

        console.log(arr[0]);
        console.log(arr[1]);
        console.log(arr[2]);
}</code></pre>
                <p>
                    *배열 요소의 추가 및 접근* <br />
                    배열에 요소를 추가할 때는 인덱스를 사용합니다. 인덱스는 배열 내 위치를 나타내는 0부터 시작하는 숫자입니다. <br />
                    위 코드는 arr 배열의 첫 번째 위치(인덱스 0)에 숫자 100을, 두 번째 위치(인덱스 1)에 숫자 200을, 세 번째 위치(인덱스 2)에 문자열 "javascript"를 각각
                    할당합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            JavaScript에서 배열을 선언하는 방법 중 하나는 new Array() 생성자를 사용하는 것입니다. <br />
                            이 방식으로 생성된 배열은 초기에 비어 있으며, 배열의 인덱스를 사용하여 요소를 추가하거나 접근할 수 있습니다.
                            배열에 추가된 요소는 숫자, 문자열 등 다양한 타입이 될 수 있으며, 배열에 저장된 요소들은 인덱스를 통해 접근할 수 있습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample07 -->
            <div id="sample08" class="sample">
                <h3>08 배열 : 데이터 저장(여러개) : 표현방법 2 : 배열 선언과 동시에 초깃값 설정</h3>
                <p>
                    이 코드는 JavaScript에서 배열을 선언하고 초기화하는 또 다른 방법을 보여줍니다.
                    new Array() 생성자 함수를 사용하여 배열을 생성하되, 이번에는 생성자 함수에 초기 값을 직접 전달하는 방식입니다. <br />
                <p>
                    *배열 선언 및 초기화* <br />
                    여기서 arr은 const 키워드를 사용하여 선언된 상수이며, new Array() 생성자 함수는 괄호 안에 전달된 값들(100, 200, "javascript")을 포함하는
                    새로운 배열을 생성합니다.
                    이 방법을 사용하면, 배열을 선언함과 동시에 여러 개의 초기 요소를 추가할 수 있습니다. <br />
                </p>
                </p>
                <pre><code>{
        const arr = new Array(100, 200, "javascript");

        console.log(arr[0]);
        console.log(arr[1]);
        console.log(arr[2]);
}</code></pre>
                <p>
                    *배열 요소의 접근 및 출력* <br />
                    배열의 각 요소에는 인덱스를 사용해 접근할 수 있습니다.
                    인덱스는 0부터 시작합니다. 따라서 arr[0]은 배열의 첫 번째 요소, arr[1]은 두 번째 요소, arr[2]는 세 번째 요소에 해당합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            JavaScript에서 new Array() 생성자 함수를 사용하여 배열을 선언하고, 동시에 초기값을 전달하여 초기화할 수 있습니다. <br />
                            이 방식은 배열을 생성하는 동시에 초기 요소를 여러 개 추가할 때 편리합니다. 배열의 요소에 접근할 때는 인덱스를 사용하며, 인덱스는 0부터 시작합니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample08 -->
            <div id="sample09" class="sample">
                <h3>09 배열 : 데이터 저장(여러개) : 표현방법 3 : 리터럴 방식으로 배열 선언</h3>
                <p>
                    배열 리터럴은 대괄호 []를 사용하여 배열을 선언하는 방법입니다.
                    이 방식은 new Array() 생성자 함수를 사용하는 것보다 더 간결하고 일반적으로 선호되는 방법입니다. 위 코드에서 arr은 빈 배열로 초기화됩니다.
                </p>
                <pre><code>{
        const arr = [];

        arr[0] = 100;
        arr[1] = 200;
        arr[2] = "javascript";

        console.log(arr[0]);
        console.log(arr[1]);
        console.log(arr[2]);
}</code></pre>
                <p>
                    *배열 요소의 추가* <br />
                    이를 통해 배열의 첫 번째 위치(인덱스 0)에는 숫자 100, 두 번째 위치(인덱스 1)에는 숫자 200, 세 번째 위치(인덱스 2)에는 문자열 "javascript"가
                    저장됩니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            JavaScript에서 배열 리터럴([])을 사용하여 배열을 선언하고 초기화하는 방법은 매우 간편하고 효율적입니다. 대괄호 내에 초기에 포함시킬 요소들을 적고, 각
                            요소는 콤마(,)로 구분합니다. <br />
                            이 방식을 통해 개발자는 쉽고 빠르게 초기값을 가진 배열을 생성할 수 있으며, 이후 인덱스를 통해 배열의 각 요소에 접근하고 이를 활용할 수 있습니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample09 -->
            <div id="sample10" class="sample">
                <h3>10 배열 : 데이터 저장(여러개) : 표현방법 4 : 리터럴 방식으로 배열 선언과 동시에 초깃값 설정</h3>
                <p>
                    배열 리터럴 방식은 대괄호 [] 내에 원하는 요소들을 콤마로 구분하여 직접 넣음으로써 배열을 선언하고 초기화하는 방법입니다. <br />
                    아래 코드에서 arr 배열은 숫자 100, 숫자 200, 문자열 "javascript" 세 개의 요소로 초기화됩니다.
                    이 방법은 배열을 생성할 때 가장 간단하고 직관적인 방법 중 하나로, 초기 요소가 있는 배열을 쉽게 만들 수 있습니다.
                </p>
                <pre><code>{
        const arr = [100, 200, "javascript"];

        console.log(arr[0]);
        console.log(arr[1]);
        console.log(arr[2]);
}</code></pre>
                <p>

                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            JavaScript에서 배열 리터럴([])을 사용하여 배열을 선언하고 초기화하는 방법은 매우 간편하고 효율적입니다. <br />
                            대괄호 내에 초기에 포함시킬 요소들을 적고, 각 요소는 콤마(,)로 구분합니다.
                            이 방식을 통해 개발자는 쉽고 빠르게 초기값을 가진 배열을 생성할 수 있으며, 이후 인덱스를 통해 배열의 각 요소에 접근하고 이를 활용할 수 있습니다. <br />
                            배열 리터럴 방식은 JavaScript에서 배열을 다룰 때 기본적이면서도 매우 중요한 방법 중 하나입니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample10 -->
            <div id="sample11" class="sample">
                <h3>11 배열 : 데이터 저장(여러개) : 표현방법 5 : push() 매서드를 이용한 배열 방법</h3>
                <p>
                    push() 메서드는 배열의 끝에 하나 이상의 요소를 추가하고, 변경된 배열의 새로운 길이를 반환합니다.
                    이 메서드는 배열의 크기를 동적으로 조정할 수 있게 해주며, 매우 유용하게 사용됩니다.
                </p>
                <pre><code>{
        const arr = [100, 200, "javascript"];

        arr.push(400);

        console.log(arr[0]);
        console.log(arr[1]);
        console.log(arr[2]);
        console.log(arr[3]);
}</code></pre>
                <p>
                    push() 메서드를 사용하여 배열 arr의 끝에 숫자 400을 추가합니다. 이로 인해 arr 배열은 이제 4개의 요소를 갖게 됩니다. <br />
                    arr[3]은 push() 메서드로 추가된 네 번째 요소 400에 해당합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                            400 <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            push() 메서드는 배열의 맨 끝에 새로운 요소(들)를 추가하는 데 사용되며, 변경된 배열의 길이를 반환합니다. <br />
                            이 메서드를 통해 배열의 크기를 쉽게 확장할 수 있으며, 동적으로 데이터를 관리하는 데 매우 유용합니다. <br />
                            JavaScript에서 배열을 다룰 때 push() 메서드는 자주 사용되는 중요한 메서드 중 하나입니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample11 -->
            <div id="sample12" class="sample">
                <h3>12 배열 : 데이터 저장(여러개) : 표현방법 6 : 다차원 배열</h3>
                <p>
                <p>다차원 배열은 기본적으로 배열의 요소 중 일부 또는 전부가 다시 배열인 구조를 말합니다. <br /></p>
                <p>
                    *코드 설명* <br />
                    이 코드에서 arr는 3개의 요소를 가진 배열입니다. <br />
                    첫 번째 요소는 숫자 100, 두 번째 요소는 [200, 300]으로 구성된 배열, 그리고 세 번째 요소는 ["javascript", "jquery"]로 구성된 배열입니다.
                    <br />
                    여기서 두 번째와 세 번째 요소가 배열을 포함하고 있기 때문에 arr는 다차원 배열입니다.
                </p>

                </p>
                <pre><code>{
        const arr = [100, [200, 300], ["javascript", "jquery"]];

        console.log(arr[0]);
        console.log(arr[1][0]);
        console.log(arr[1][1]);
        console.log(arr[2][0]);
        console.log(arr[2][1]);
}</code></pre>
                <p>
                    *배열 요소의 접근 및 출력* <br />
                    이 코드에서는 다차원 배열의 각 요소에 접근하여 그 값을 콘솔에 출력합니다. <br />

                    arr[0]은 첫 번째 요소 100을 나타냅니다. <br />
                    arr[1][0]은 두 번째 요소인 배열 [200, 300]의 첫 번째 요소 200을 나타냅니다. <br />
                    arr[1][1]은 두 번째 요소인 배열 [200, 300]의 두 번째 요소 300을 나타냅니다. <br />
                    arr[2][0]은 세 번째 요소인 배열 ["javascript", "jquery"]의 첫 번째 요소 "javascript"를 나타냅니다. <br />
                    arr[2][1]은 세 번째 요소인 배열 ["javascript", "jquery"]의 두 번째 요소 "jquery"를 나타냅니다. <br />
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            javascript <br />
                            jquery <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            다차원 배열은 JavaScript에서 복잡한 데이터 구조를 다루는 데 매우 유용합니다. <br />
                            인덱스를 겹쳐 사용함으로써 다차원 배열의 각 요소에 접근할 수 있으며, 이를 통해 행렬, 테이블 또는 그밖에 더 복잡한 데이터 구조를 효율적으로 표현하고 관리할 수
                            있습니다. <br />
                            다차원 배열의 이해와 활용은 데이터를 구조화하고 처리하는 데 있어 중요한 기술 중 하나입니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample12 -->
            <div id="sample13" class="sample">
                <h3>13 배열 : 데이터 저장(여러개) : 표현방법 7 : 배열 구조 분해 할당</h3>
                <p>
                <p>*첫번째 코드* <br />
                    이 코드에서 arr 배열은 세 개의 요소를 포함하고 있습니다: 100, 200, 그리고 또 다른 배열 [300, 400]. 구조 분해 할당을 통해, 첫 번째 요소 100은 변수
                    a에, 두 번째 요소 200은 변수 b에 할당됩니다.
                    마지막으로, 세 번째 요소인 배열 [300, 400]은 구조 분해를 통해 그 내부 요소 300과 400이 각각 변수 x와 y에 할당됩니다.</p>
                <p>*두 번째 코드 분석* <br />
                    arr 배열은 세 개의 요소를 포함하고 있지만, 모든 요소가 단일 값입니다 (100, 200, "javascript"). 여기서도 구조 분해 할당을 사용하여 각 요소를 변수 a,
                    b, c에 각각 할당합니다.
                    이 경우에는 내부 배열이나 복잡한 구조가 없으므로, 각 변수에는 배열의 직접적인 요소가 할당됩니다.</p>
                </p>
                <pre><code>{
        const arr = [100, 200, "javascript"];

        const [a, b, c] = arr;

        console.log(a);
        console.log(b);
        console.log(c);
}</code></pre>
                <pre><code>{
        const arr = [100, 200, [300, 400]];
        const [a, b, [x, y]] = arr;

        console.log(a);
        console.log(b);
        console.log(x);
        console.log(y);
}</code></pre>
                <p>
                    *두 코드의 차이점* <br />
                    첫 번째 코드에서는 배열의 마지막 요소가 또 다른 배열이며, 이 내부 배열의 요소를 더 작은 단위로 구조 분해하여 변수에 할당하는 과정이 포함됩니다. <br />
                    두 번째 코드는 모든 배열 요소가 단일 값이고, 이들을 직접적으로 변수에 할당하는 더 단순한 형태의 구조 분해 할당을 사용합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>첫번째 결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>두번째 결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            400 <br />
                        </div>
                    </details>
                    <details>
                        <summary>배열 구조 분해 할당에 대하여</summary>
                        <div>
                            배열 구조 분해 할당은 복잡한 배열 구조에서 필요한 요소만을 선택하여 변수에 쉽게 할당할 수 있는 효율적인 방법을 제공합니다. <br />
                            이는 코드의 가독성을 높이고, 필요한 데이터에 더 직접적으로 접근할 수 있게 해줍니다. <br />
                            복잡한 데이터 구조에서 원하는 정보를 추출하거나, 함수에서 여러 값을 반환할 때 유용하게 사용됩니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample13 -->
            <div id="sample14" class="sample">
                <h3>14 배열 : 데이터 저장(여러개) : 표현방법 8 : 배열 펼침 연산자(Spread Operator)</h3>
                <p>
                    배열 펼침 연산자(Spread Operator)는 ... 기호를 사용하여 배열이나 문자 같은 이터러블(iterable) 객체의 요소를 개별 요소로 펼치는 데 사용됩니다.
                    <br />
                    이 연산자는 함수의 인자로 배열을 전달하거나, 배열을 병합하고 복사할 때 유용하게 사용될 수 있습니다.
                </p>
                <pre><code>{
        const arr1 = [100, 200];
        const arr2 = [300, 400];
        const merge1 = [...arr1, ...arr2];
        const merge2 = [...arr1, "javascript", ...arr2, "jquery"];

        console.log(arr1)  //[100, 200]
        console.log(...arr1);   //100 200
        console.log(...arr1, ...arr2);   // 100 200 300 400
        console.log(merge1)     //[100, 200, 300, 400]
        console.log(merge2)    // [100, 200, 'javascript', 300, 400, 'jquery']
}</code></pre>
                <p>
                    *const merge1 = [...arr1, ...arr2];* <br />
                    arr1과 arr2 배열의 모든 요소를 펼쳐 새로운 배열 merge1을 생성합니다. 결과적으로 merge1은 [100, 200, 300, 400]이 됩니다. <br />
                    *const merge2 = [...arr1, "javascript", ...arr2, "jquery"];* <br />
                    arr1 배열의 모든 요소를 펼치고, 문자열 "javascript"를 추가한 다음,
                    arr2 배열의 모든 요소를 펼쳐 그 뒤에 문자열 "jquery"를 추가하여 새로운 배열 merge2를 생성합니다.
                    결과적으로 merge2는 [100, 200, 'javascript', 300, 400, 'jquery']가 됩니다. <br />
                </p>
                <div class="result">
                    <details>
                        <summary>정답</summary>
                        <div>
                            [100, 200] <br />
                            100 200 <br />
                            100 200 300 400 <br />
                            [100, 200, 300, 400] <br />
                            [100, 200, 'javascript', 300, 400, 'jquery'] <br />
                        </div>
                    </details>
                    <details>
                        <summary>배열 펼침 연산자의 활용</summary>
                        <div>
                            +배열 펼침 연산자를 사용함으로써 코드의 가독성을 높이고, 배열 작업을 보다 쉽고 효율적으로 처리할 수 있습니다.+ <br />
                            *배열 복사: const arrCopy = [...arr];와 같이 원본 배열을 새 배열에 복사할 수 있습니다. <br />
                            *배열 병합: const mergedArr = [...arr1, ...arr2];와 같이 두 배열을 병합하여 새 배열을 생성할 수 있습니다. <br />
                            *함수 인자: Math.max(...arr);와 같이 배열의 요소를 함수의 인자로 전달할 수 있습니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample14 -->
            <div id="sample15" class="sample">
                <h3>15. 객체 : 데이터 저장(키와값) : 표현방법 1 : 객체 선언 : 객체 선언 후 배열 방식으로 데이터 입력</h3>
                <p>
                    이 코드는 JavaScript에서 객체를 선언하고, 배열 인덱스 방식을 이용해 데이터를 입력하는 방법을 보여줍니다. <br />
                <p>*객체 선언* <br />
                    Object 생성자를 사용하여 새로운 빈 객체 obj를 생성합니다.
                    JavaScript에서 객체는 키-값 쌍으로 데이터를 저장하는 복합 데이터 타입입니다. new Object()는 객체를 생성하는 가장 기본적인 방법 중 하나입니다.
                </p>
                </p>
                <pre><code>{
        const obj = new Object();   //객체 선언

        obj[0] = 100;               //obj 변수에 숫자 100을 저장
        obj[1] = 200;               //obj 변수에 숫자 200 저장
        obj[2] = "javascript";     //obj 변수에 숫자 javascript 저장

        console.log(obj[0]);
        console.log(obj[1]);
        console.log(obj[2]);
}</code></pre>
                <p>
                <p>*배열 방식으로 데이터 입력* <br />
                    이 코드는 객체에 속성을 추가하는데, 배열 인덱스와 같은 숫자를 키로 사용하여 데이터를 할당합니다.
                    JavaScript에서 객체의 속성 이름은 문자열 또는 심볼이어야 하지만, 여기서 숫자를 사용하면 자동으로 문자열로 변환됩니다.
                    따라서 obj[0] = 100;은 실제로는 '0': 100처럼 처리되며, 객체 obj는 다음과 같이 됩니다:</p>
                <p>*콘솔 출력* <br />
                    이 코드는 앞서 객체에 추가한 속성 값을 차례로 콘솔에 출력합니다. 객체에서 속성에 접근할 때도 배열과 유사한 방식을 사용할 수 있습니다.
                </p>
                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            이 코드는 new Object()를 통해 빈 객체를 생성하고, 배열 인덱스 방식을 모방하여 숫자를 키로 사용해 객체에 데이터를 추가하는 방식을 보여줍니다.
                            이 방식을 통해 객체에 데이터를 저장하고, 배열 인덱스처럼 접근하여 값을 조회할 수 있음을 알 수 있습니다. <br />
                            그러나 일반적으로 객체는 키-값 쌍의 구조를 더 잘 활용할 수 있도록 문자열 키를 사용하는 것이 권장됩니다.
                            숫자 키를 사용하는 것은 특별한 경우를 제외하고는 일반적이지 않으며, 배열과 같은 순서가 중요한 데이터 구조가 필요한 경우에는 배열을 사용하는 것이 더 적합합니다.
                            <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample15 -->
            <div id="sample16" class="sample">
                <h3>16. 객체 : 데이터 저장(키와값) : 표현방법 2 : 객체 선언 : 객체 선언 후 객체 방식으로 데이터 입력</h3>
                <p>
                    *객체 선언* <br />
                    이 코드는 new Object()를 사용하여 새로운 객체를 생성하고, 이를 obj라는 상수에 할당합니다.
                    new Object()는 JavaScript에서 제공하는 기본 객체 생성자를 이용해 빈 객체를 만드는 방법입니다. 만들어진 객체는 아직 아무런 속성도 갖고 있지 않습니다.
                </p>
                <pre><code>{
        const obj = new Object();     //객체 선언

        obj.a = 100;
        obj.b = 200;
        obj.c = "javascript";

        console.log(obj.a)
        console.log(obj.b)
        console.log(obj.c)
}</code></pre>
                <p>
                    *객체에 데이터 입력* <br />
                    'obj.a = 100'은 obj 객체에 a라는 이름의 속성을 추가하고, 그 값을 100으로 설정합니다. <br />
                    마찬가지로, obj.b = 200;과 obj.c = "javascript";는 각각 obj 객체에 b와 c라는 속성을 추가하고, 그 값을 각각 200과 "javascript"으로
                    설정합니다. <br />

                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>객체 불러오기</summary>
                        <div>
                            이 코드를 통해 JavaScript에서 new Object() 생성자를 사용하여 객체를 생성하고, 점 표기법(dot notation)을 이용해 객체에 속성을
                            추가하며,
                            그 값을 할당하는 방법을 알 수 있습니다. 점 표기법은 객체의 속성에 접근하고, 속성 값을 읽거나 수정할 때 사용되는 매우 일반적인 방법입니다. <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample16 -->
            <div id="sample17" class="sample">
                <h3>17. 객체 : 데이터 저장(키와값) : 표현방법 3 : 리터럴 방식으로 객체 선언</h3>
                <p>
                    코드는 객체를 먼저 빈 객체 리터럴 {}로 선언한 후, 이후에 속성을 추가하는 방식으로 객체를 구성하는 예이며,
                    객체 리터럴 방식은 {}를 사용하여 객체를 직접 선언하는 방법입니다. 이 방식을 사용하면 객체를 생성하는 동시에 속성과 값을 초기화할 수 있습니다.
                </p>
                <pre><code>{
        const obj = {};

        obj.a = 100;
        obj.b = 200;
        obj.c = "javascript";

        console.log(obj.a)
        console.log(obj.b)
        console.log(obj.c)
}</code></pre>
                <p>
                    *객체 리터럴 방식의 구조* <br />
                <p>
                    const 객체명 = {}; <br />
                    속성명1: 값1, <br />
                    속성명2: 값2, <br />
                    속성명3: 값3, <br />
                    ... <br />

                </p>
                객체명: 생성할 객체의 이름입니다. <br />
                {}: 객체 리터럴을 나타내며, 객체의 속성과 그 값들을 포함합니다. <br />
                속성명: 객체가 가질 속성의 이름입니다. 속성 이름은 문자열로 표현되며, 속성 간에는 쉼표(,)로 구분됩니다. <br />
                값: 속성에 할당할 값입니다. 값은 숫자, 문자열, 배열, 또 다른 객체 등 JavaScript에서 사용할 수 있는 어떤 데이터 타입도 가능합니다. <br />
                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample17 -->
            <div id="sample18" class="sample">
                <h3>18. 객체 : 데이터 저장(키와값) : 표현방법 4 : 리터럴 방식으로 객체 선언과 동시에 초깃값을 설정</h3>
                <p>
                    객체 리터럴은 중괄호 {}를 사용하여 객체를 직접 선언하며, 이 방식을 통해 객체의 속성과 그 속성의 초기 값을 쉽고 직관적으로 설정할 수 있습니다.
                    이 방법은 코드의 가독성을 높이고, 객체를 생성하고 초기화하는 과정을 간결하게 만들어 줍니다.
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }

        console.log(obj.a);
        console.log(obj.b);
        console.log(obj.c);
}</code></pre>
                <p>
                    obj라는 이름의 새 객체를 생성합니다. 여기서 const 키워드는 obj가 상수임을 나타내며, obj의 값을 재할당할 수 없음을 의미합니다. 하지만 obj 내의 속성 값은 변경할
                    수 있습니다. <br />
                    { a: 100, b: 200, c: "javascript" }: 객체 obj는 세 개의 속성을 가지며, 각 속성에는 초기 값이 할당되어 있습니다. <br />
                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample18 -->
            <div id="sample19" class="sample">
                <h3>19. 객체 : 데이터 저장(키와값) : 표현방법 5 : 배열안에 객체가 있는 방식</h3>
                <p>
                    이 코드에서 obj는 객체를 요소로 가지는 배열입니다. 각 객체는 중괄호 {}로 둘러싸여 있으며, 객체 내부에는 키-값 쌍으로 데이터가 저장됩니다. obj 배열은 두 개의 객체를
                    포함하고 있으며, 각 객체는 a, b, c라는 세 개의 속성을 가지고 있습니다.
                </p>
                <pre><code>{
        const obj = [
            {
                a: 100,
                b: 200,
                c: "javascript"
            }, {
                a: 300,
                b: 400,
                c: "jquery"
            }
        ];

        console.log("17 객체 : 표현방법");
        //console.log(obj[0].a);
        //console.log(obj[0].b);
        //console.log(obj[0].c);
        console.log(obj[1].a);
        console.log(obj[1].b);
        console.log(obj[1].c);
}</code></pre>
                <p>
                    *객체와 배열 불러오는 방법* <br />
                <p>
                    *객체 속성 접근하기* <br />
                    객체의 속성에 접근하기 위해서는 점 표기법(dot notation) 또는 대괄호 표기법(bracket notation)을 사용할 수 있습니다. <br />
                    객체 불러오기: 객체명.속성명 <br />
                    배열 불러오기: 객체명['속성명'] <br />
                </p>
                <p>
                    *배열 내 객체 접근하기* <br />
                    배열 내의 객체에 접근하기 위해서는 배열의 인덱스를 통해 접근해야 합니다. 배열의 인덱스는 0부터 시작합니다. <br />

                    첫 번째 객체 접근: 배열명[0] <br />
                    두 번째 객체 접근: 배열명[1] <br />
                </p>
                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            300 <br />
                            400 <br />
                            jquery <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample19 -->
            <div id="sample20" class="sample">
                <h3>20. 객체 : 데이터 저장(키와값) : 표현방법 6 : 객체안에 배열이 있는 방식</h3>
                <p>
                    이 예시에서 obj는 세 개의 속성을 가진 객체입니다. a와 c는 각각 숫자와 문자열 값을 가지고, b는 배열을 값으로 가집니다. 이 배열은 두 개의 숫자 요소, 200과 300을
                    포함합니다.
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: [200, 300],
            c: "javascript"
        };

        console.log(obj.a)
        console.log(obj.b)
        console.log(obj.b[0])
        console.log(obj.b[1])
        console.log(obj.c)
}</code></pre>
                <p>
                <p>*객체의 속성 접근* <br />
                    객체의 속성에 접근하기 위해 점 표기법(dot notation)을 사용합니다. 예를 들어, obj.a는 객체 obj의 a 속성에 접근합니다. <br /></p>
                <p>*배열 내 요소 접근* <br />
                    배열 내의 요소에 접근하기 위해서는 대괄호 표기법(bracket notation)을 사용합니다. 예를 들어, obj.b[0]은 obj 객체의 b 속성(배열) 내 첫 번째 요소에
                    접근합니다.</p>
                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            100 <br />
                            200, 300 <br />
                            200 <br />
                            300 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            이 코드는 객체 내 배열을 사용하여 데이터를 구조화하는 방법을 보여줍니다. 객체 obj의 b 속성은 배열을 값으로 가지며, 이 배열은 각각 200, 300이라는
                            요소를 포함합니다.
                            이런 방식을 통해 복잡한 데이터 구조를 효율적으로 표현하고 관리할 수 있습니다. 데이터에 접근하기 위해서는 점 표기법을 사용해 객체의 속성에
                            접근하고, 대괄호 표기법을 사용해 배열 내 요소에 접근합니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample20 -->
            <div id="sample21" class="sample">
                <h3>21. 객체 : 데이터 저장(키와값) : 표현방법 7 : 객체 안에 객체가 있는 방식</h3>
                <p>
                    아래 코드에서 obj는 세 개의 속성을 가진 객체입니다. 여기서 a와 d는 각각 숫자와 문자열 값을 가지고 있고, b는 또 다른 객체를 값으로 가집니다. 이 내부 객체는 x와
                    y라는 두 개의 속성을 가지며, 이 속성들은 각각 200, 300이라는 숫자 값을 가집니다.
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: { x: 200, y: 300 },
            d: "javascript"
        }

        console.log(obj.a)
        console.log(obj.b.x)
        console.log(obj.b.y)
        console.log(obj.d)
}</code></pre>
                <p>
                <p>*객체의 속성 접근* <br />
                    객체의 속성에 접근할 때는 점 표기법(dot notation)을 사용합니다. 예를 들어, obj.a는 객체 obj의 a 속성에 접근합니다.</p>
                <p>*내부 객체의 속성 접근* <br />
                    내부 객체의 속성에 접근할 때도 점 표기법을 사용합니다. 예를 들어, obj.b.x는 obj 객체의 b 속성(내부 객체) 내 x 속성에 접근합니다.</p>
                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            이 코드는 객체 내부에 또 다른 객체를 포함하여 데이터를 구조화하는 방법을 보여줍니다. obj 객체의 b 속성은 또 다른 객체를 값으로 가지고 있으며, 이 내부
                            객체는 x와 y라는 자체 속성을 가집니다. 이런 방식은 데이터를 더욱 세분화하여 관리할 수 있게 해주며, 복잡한 데이터 구조를 보다 명확하게 표현할 수 있습니다.
                            데이터에 접근하기 위해서는 점 표기법을 사용해 객체의 속성 또는 내부 객체의 속성에 접근할 수 있습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample21 -->
            <div id="sample22" class="sample">
                <h3>22. 객체 : 데이터 저장(키와값) : 표현방법 8 : 객체 + 함수가 있는 방식</h3>
                <p>
                    이 코드는 객체 내에 속성 뿐만 아니라 함수도 포함하는 방식을 보여줍니다. 이러한 구조는 객체 지향 프로그래밍의 기본적인 아이디어 중 하나로, 데이터(속성)와 그 데이터를 처리하는
                    로직(메소드 또는 함수)을 하나의 단위(객체)로 묶어 관리합니다. 이를 통해 코드의 재사용성과 유지보수성을 높일 수 있습니다.<br />
                <P>
                    *객체에 함수 포함하기* <br />
                    위 코드에서 obj 객체는 숫자, 배열, 문자열 등의 속성과 함께 세 개의 함수 e, f, g를 포함하고 있습니다. 이 함수들은 객체의 다른 속성에 접근하거나 특정 작업을 수행하는
                    로직을 담고 있습니다.
                </P>
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: [200, 300],
            c: { x: 400, y: 500 },
            d: "javascript",
            e: function () {
                console.log("javascript가 실행되었습니다.");
            },
            f: function () {
                console.log(obj.d + "가 실행되었습니다.");
            },
            g: function () {
                (this.d + "가 실행되었습니다.");
            }
        }

        console.log(obj.a);
        console.log(obj.b[0]);
        console.log(obj.b[1]);
        console.log(obj.c.x);
        console.log(obj.c.y);
        console.log(obj.d);
        obj.e()      //함수 실행
        obj.f()
        obj.g()
}</code></pre>
                <p>
                    *함수의 실행* <br />
                    obj.e()는 단순히 "javascript가 실행되었습니다."라는 메시지를 콘솔에 출력합니다. <br />
                    obj.f()는 객체 obj의 d 속성(문자열 "javascript")을 직접 참조해 "javascript가 실행되었습니다."라는 메시지를 콘솔에 출력합니다. <br />
                    obj.g()는 this 키워드를 사용하여 현재 객체(obj)의 d 속성에 접근합니다. 이 방식은 함수가 속한 객체의 다른 속성에 접근할 때 많이 사용됩니다. 이 경우에도
                    "javascript가 실행되었습니다"라는 메시지를 출력합니다. <br />
                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            400 <br />
                            00 <br />
                            javascript <br />
                            javascript가 실행되었습니다. <br />
                            javascript가 실행되었습니다. <br />
                            javascript가 실행되었습니다 <br />
                        </div>
                    </details>
                    <details>
                        <summary>this 키워드의 중요성</summary>
                        <div>
                            this 키워드는 현재 실행 컨텍스트의 객체를 가리킵니다. <br />
                            이 코드에서 this는 obj.f() 함수가 호출될 때 obj 객체를 참조합니다. 따라서 this.c는
                            obj.c와 같은 값을 가리키게 됩니다. this의 사용은 함수가 속한 객체의 다른 속성이나 함수에 접근할 때 매우 유용하며, 객체 내부에서의 함수 호출이나 속성
                            접근에 널리 쓰입니다.
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            이 코드 예시는 객체 내에 데이터와 함수를 함께 포함하는 방식을 보여주며, 객체 지향 프로그래밍의 한 형태를 설명합니다. 함수를 객체의 일부로 포함시키는 것은 해당
                            객체와 관련된 로직을 그룹화하고, 코드의 구조를 개선하며, 재사용성과 유지보수성을 높이는 데 도움이 됩니다. this 키워드의 사용은 객체 내부에서의 함수 호출과
                            속성 접근을 보다 유연하게 만들어 줍니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample22 -->
            <div id="sample23" class="sample">
                <h3>23. 객체 : 데이터 저장(키와값) : 표현방법 9 : 객체구조분해할당</h3>
                <p>
                <p>이 코드는 객체 구조 분해 할당(Object Destructuring)을 사용하여 객체 obj의 속성을 개별 변수로 추출하는 방법을 보여줍니다. 객체 구조 분해 할당은
                    ES6(ES2015)에서 도입된 JavaScript의 편리한 기능 중 하나로, 객체 내부의 속성을 좀 더 간결하게 접근할 수 있게 해줍니다.</p>
                <p>
                    *객체 구조 분해 할당* <br />
                    객체 구조 분해 할당을 사용하면 객체의 속성을 변수로 직접 할당할 수 있습니다. 이는 코드를 더 깔끔하게 만들고, 필요한 속성만을 선택적으로 추출할 수 있는 이점이 있습니다.
                </p>
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript",
        }

        const { a, b, c } = obj;

        console.log(a)
        console.log(b)
        console.log(c)
}</code></pre>
                <p>
                <p>const { a, b, c } = obj; <br />
                    위 코드에서 { a, b, c } = obj;는 obj 객체에서 a, b, c 속성을 각각 변수 a, b, c에 할당합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>요약</summary>
                        <div>
                            객체 구조 분해 할당은 객체의 속성을 변수에 직접 할당하는 간결하고 효율적인 방법을 제공합니다. 이 기능을 사용하면 코드의 가독성과 유지보수성이 향상되며, 필요한
                            객체 속성만을 선택적으로 추출할 수 있습니다. 위 예제에서는 obj 객체의 모든 속성을 개별 변수에 할당하고 이를 콘솔에 출력하여, 구조 분해 할당의 기본적인
                            사용법과 그 결과를 보여줍니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample23 -->
            <div id="sample24" class="sample">
                <h3>24. 객체 : 데이터 저장(키와값) : 표현방법 10 : 객체펼침연산자</h3>
                <p>
                    객체 펼침 연산자(Spread Operator)는 ES6(ES2015)에 도입된 문법으로, 객체 리터럴 내에서 다른 객체의 속성을 쉽게 복사할 수 있는 기능을 제공합니다.
                    이 연산자는 세 개의 점(...)으로 표시되며, 객체의 모든 열거 가능한 속성을 새 객체로 "펼쳐" 복사합니다.
                </p>
                <pre><code>{
        const obj1 = { a: 100, b: 200, }
        const obj2 = { c: 300, d: 400, }
        const merge1 = { ...obj1, ...obj2 }
        const merge2 = { ...obj1, x: "javascript", ...obj2, y: "jquery" }

        console.log(obj1)         //{ a: 100, b: 200, }
        console.log(merge1)   //{ a: 100, b: 200, c: 300, d: 400,}
        console.log(merge2)   //{ a: 100, b: 200, javascript, c: 300, d: 400, jquery}
}</code></pre>
                <p>
                    객체 펼침 연산자를 사용하면, 하나 이상의 객체를 쉽게 결합(병합)하거나,
                    기존 객체를 기반으로 새 객체를 만들 때 기존 속성을 유지하면서 새로운 속성을 추가할 수 있습니다.
                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            { a: 100, b: 200, } <br />
                            { a: 100, b: 200, c: 300, d: 400,} <br />
                            { a: 100, b: 200, x: "javascript", c: 300, d: 400, y: "jquery" } <br />
                        </div>
                    </details>
                    <details>
                        <summary>정리</summary>
                        <div>
                            객체 펼침 연산자를 사용하면, 객체의 속성을 쉽게 복사하거나, 여러 객체를 결합하여 새 객체를 생성할 수 있습니다.
                            이는 코드를 더 간결하고 읽기 쉽게 만들어주며, JavaScript에서 객체를 다룰 때 매우 유용한 기능입니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample24 -->
            <div id="sample25" class="sample">
                <h3>25. 파일 : 데이터 교환(JSON)</h3>
                <p>
                <p>JSON 데이터 --&gt; 객체 변환</p>
                <p>
                    JSON(JavaScript Object Notation)은 경량의 데이터 교환 형식으로, 사람이 읽고 쓰기 쉽고 기계가 파싱하고 생성하기 쉽게 설계되어 있습니다.
                    JavaScript에서는 JSON.parse() 메서드를 사용하여 JSON 형식의 문자열을 JavaScript 객체로 변환할 수 있습니다. <br />
                    첫 번째 코드 예제에서는 JSON 형식의 문자열을 JavaScript 객체로 변환하고 있습니다.
                </p>
                </p>
                <pre><code>{
        //01 JSON 데이터 --&gt; 객체 변환
        const jsonString = '{"name":"Hwang", "age":30}';
        const jsonObject = JSON.parse(jsonString);

        console.log(jsonString.name);   //Hwang
        console.log(jsonString.age);    //30
    
        //02 객체 파일 --&gt; JSON 데이터
        const person = { name: "Hwang", age: 30 };
        const jsonString = JSON.stringify(person);

        console.log(jsonString)  //{ name: "Hwang", age: 30 }
}</code></pre>
                <p>
                <p>객체 --&gt; JSON 데이터 <br /> </p>
                JavaScript 객체를 JSON 형식의 문자열로 변환할 때는 JSON.stringify() 메서드를 사용합니다. 이 메서드는 객체, 배열 등 JavaScript의 값을 JSON
                문자열로 변환합니다.
                두 번째 코드 예제에서는 객체를 JSON 문자열로 변환하고 있습니다. <br />
                JSON.stringify() 메서드의 결과로 얻은 jsonString은 JSON 형식의 문자열로, 객체의 구조를 유지하면서도 문자열 형태로 표현합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>정답 확인하기</summary>
                        <div>
                            {"name":"Hwang","age":30}
                        </div>
                    </details>
                    <details>
                        <summary>결론</summary>
                        <div>
                            JSON과 JavaScript 객체 간의 변환은 JSON.parse()와 JSON.stringify() 메서드를 통해 수행되며, 이를 통해 데이터를 쉽게 저장하고
                            교환할 수 있습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample25 -->
        </div>
    </main>
    <!-- //main -->

    <footer id="footer">

    </footer>
    <!-- //footer -->

    <button onclick="topFunction()" id="scrollTopBtn" title="Go to top">목록</button>
    <script src="assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>
        // 01. 변수 : 데이터 저장
        {
            let x = 100;
            let y = 200;
            let z = "javascript";

            console.log("01-------");
            console.log(x);
            console.log(y);
            console.log(z);
        }
        // 02. 변수 : 데이터 저장 + 데이터 변경
        {
            let x = 100;
            let y = 200;
            let z = "javascript";

            x = 300;
            y = 400;
            z = "jquery";

            console.log("02-------");
            console.log(x);
            console.log(y);
            console.log(z);
        }
        // 03. 변수 : 데이터 저장 + 데이터 변경 + 데이터 추가
        {
            let x = 100;
            let y = 200;
            let z = "javascript";

            x += 300;
            y += 400;
            z += "jquery";

            console.log("03-------");
            console.log(x);
            console.log(y);
            console.log(z);
        }

        // 04. 상수 : 데이터 저장 + 데이터 변경(x)
        {
            const x = 100;
            const y = 200;
            const z = "javascript";

            //x += 300;
            //y += 400;
            //z += "jquery";

            console.log("04-------");
            console.log(x);
            console.log(y);
            console.log(z);
        }

        // 05. 배열 : 데이터 저장(여러개) : 표현방법 1
        {
            const arr = new Array();

            arr[0] = 100;
            arr[1] = 200;
            arr[2] = "javascript";

            console.log("05-------");
            console.log(arr[0]);
            console.log(arr[1]);
            console.log(arr[2]);
        }
        // 06. 배열 : 데이터 저장(여러개) : 표현방법 2
        {
            const arr = new Array(100, 200, "javascript");

            console.log("06-------");
            console.log(arr[0]);
            console.log(arr[1]);
            console.log(arr[2]);
        }
        // 07. 배열 : 데이터 저장(여러개) : 표현방법 3
        {
            const arr = [];

            arr[0] = 100;
            arr[1] = 200;
            arr[2] = "javascript";

            console.log("07-------");
            console.log(arr[0]);
            console.log(arr[1]);
            console.log(arr[2]);
        }
        // 08. 배열 : 데이터 저장(여러개) : 표현방법 4
        {
            const arr = [100, 200, "javascript"];

            console.log("08-------");
            console.log(arr[0]);
            console.log(arr[1]);
            console.log(arr[2]);
        }
        // 09. 배열 : 데이터 저장(여러개) : 표현방법 5 : PUSH() 매서드를 이용한 데이터 저장
        {
            const arr = [100, 200, "javascript"];

            arr.push(400);

            console.log("09-------");
            console.log(arr[0]);
            console.log(arr[1]);
            console.log(arr[2]);
        }
        // 10. 배열 : 데이터 저장(여러개) : 표현방법 6 : 다차원 배열
        {
            const arr = [100, [200, 300], ["javascript", "jquery"]];

            console.log("10-------");
            console.log(arr[0]);
            console.log(arr[1][0]);
            console.log(arr[1][1]);
            console.log(arr[2][0]);
            console.log(arr[2][1]);
        }
        // 11. 배열 : 데이터 저장(여러개) : 표현방법 7 : 배열 구조 분해 할당 (Destructuring ass)
        {
            const arr = [100, 200, "javascript"];

            const [a, b, c] = arr;

            console.log("11-------");
            console.log(a);
            console.log(b);
            console.log(c);
        }
        // 12. 배열 : 데이터 저장(여러개) : 표현방법 8 : 배열 펼침 연산자(Spread Operator)
        {
            const arr1 = [100, 200];
            const arr2 = [300, 400];
            const merge1 = [...arr1, ...arr2];
            const merge2 = [...arr1, "javascript", ...arr2, "jquery"];

            console.log(arr1)  //[100, 200]
            console.log(...arr1);   //100 200
            console.log(...arr1, ...arr2);   // 100 200 300 400
            console.log(merge1)     //[100, 200, 300, 400]
            console.log(merge2)    // [100, 200, 'javascript', 300, 400, 'jquery']
        }

        // 13. 객체 : 데이터 저장(키와값) : 표현방법 1 : 객체 선언 : 객체 선언 후 배열 방식으로 데이터 입력
        {
            const obj = new Object();   //객체 선언

            obj[0] = 100;     //obj 변수에 숫자 100을 저장
            obj[1] = 200;     //obj 변수에 숫자 200 저장
            obj[2] = "javascropt";     //obj 변수에 숫자 javascropt 저장

            console.log("13 객체 : 표현방법1")
            console.log(obj[0]);
            console.log(obj[1]);
            console.log(obj[2]);
        }
        // 14. 객체 : 데이터 저장(키와값) : 표현방법 2 : 객체 선언 : 객체 선언 후 객체 방식으로 데이터 입력
        {
            const obj = new Object();     //객체 선언

            obj.a = 100;
            obj.b = 200;
            obj.c = "javascript";

            console.log("14 객체 : 표현방법")
            console.log(obj.a)
            console.log(obj.b)
            console.log(obj.c)
        }
        // 15. 객체 : 데이터 저장(키와값) : 표현방법 3 : 리터럴 방식으로 객체 선언
        {
            const obj = {};

            obj.a = 100;
            obj.b = 200;
            obj.c = "javascript";

            console.log("15 객체 : 표현방법")
            console.log(obj.a)
            console.log(obj.b)
            console.log(obj.c)
        }
        // 16. 객체 : 데이터 저장(키와값) : 표현방법 4 : 리터럴 방식으로 객체 선언과 동시에 초깃값을 설정
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log("16 객체 : 표현방법");
            console.log(obj.a);
            console.log(obj.b);
            console.log(obj.c);
        }
        // 17. 객체 : 데이터 저장(키와값) : 표현방법 5 : 배열안에 객체가 있는 방식
        {
            const obj = [
                { a: 100, b: 200, c: "javascript" },
                { a: 300, b: 400, c: "jquery" }
            ]

            console.log("17 객체 : 표현방법");
            console.log(obj[0].a)
            console.log(obj[0].b)
            console.log(obj[0].c)
            console.log(obj[1].a)
            console.log(obj[1].b)
            console.log(obj[1].c)
        }
        // 18. 객체 : 데이터 저장(키와값) : 표현방법 6 : 객체안에 배열이 있는 방식
        {
            const obj = {
                a: 100,
                b: [200, 300],
                c: "javascript"
            };

            console.log("18 객체 : 표현방법");
            console.log(obj.a)
            console.log(obj.b[0])
            console.log(obj.b[1])
            console.log(obj.c)
        }
        // 19. 객체 : 데이터 저장(키와값) : 표현방법 7 : 객체 안에 객체가 있는 방식
        {
            const obj = {
                a: 100,
                b: { x: 200, y: 300 },
                d: "javascript"
            }

            console.log("19 객체 : 표현방법");
            console.log(obj.a)
            console.log(obj.b.x)
            console.log(obj.b.y)
            console.log(obj.d)
        }
        // 20. 객체 : 데이터 저장(키와값) : 표현방법 8 : 객체 + 함수가 있는 방식

        // 변수 : 데이터 저장 : 숫자, 문자, 함수(실행문), 객체, 배열, 특수값(undefined, null) : 자료형
        {
            const obj = {
                a: 100,
                b: [200, 300],
                c: { x: 400, y: 500 },
                d: "javascript",
                e: function () {
                    console.log("javascript가 실행되었습니다.");
                },
                f: function () {
                    console.log(obj.d + "가 실행되었습니다.");
                },
                g: function () {
                    (this.d + "가 실행되었습니다.");
                }
            }

            console.log("20 객체 : 표현방법");
            console.log(obj.a);
            console.log(obj.b[0]);
            console.log(obj.b[1]);
            console.log(obj.c.x);
            console.log(obj.c.y);
            console.log(obj.d);
            obj.e()      //함수 실행
            obj.f()
            obj.g()
        }
        // 21. 객체 : 데이터 저장(키와값) : 표현방법 9 : 객체구조분해할당
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript",
            }

            const { a, b, c } = obj;

            console.log("21 객체 : 표현방법");
            console.log(a)
            console.log(b)
            console.log(c)
        }
        // 22. 객체 : 데이터 저장(키와값) : 표현방법 10 : 객체펼침연산자
        {
            const obj1 = { a: 100, b: 200, }
            const obj2 = { c: 300, d: 400, }
            const merge1 = { ...obj1, ...obj2 }
            const merge2 = { ...obj1, x: "javascript", ...obj2, y: "jquery" }

            console.log("22 객체 : 표현방법");
            console.log(obj1)         //{ a: 100, b: 200, }
            console.log(merge1)   //{ a: 100, b: 200, c: 300, d: 400,}
            console.log(merge2)   //{ a: 100, b: 200, javascript, c: 300, d: 400, jquery}
        }

        //23. 파일 : 데이터 교환(JSON)
        {
            //01 JSON 데이터 --&gt; 객체 변환
            const jsonString = '{"name":"Hwang", "age":30}';
            const jsonObject = JSON.parse(jsonString);

            console.log(jsonString.name);   //Hwang
            console.log(jsonString.age);    //30
        }
        {
            //02 객체 파일 --&gt; JSON 데이터
            const person = { name: "Hwang", age: 30 };
            const jsonString = JSON.stringify(person);

            console.log(jsonString)  //{ name: "Hwang", age: 30 }
        }



        //목록 클릭시 해당 본문으로 이동
        document.addEventListener("DOMContentLoaded", function () {
            // 메뉴 아이템 클릭 이벤트 리스너 추가
            document.querySelectorAll('.main__menu a').forEach(item => {
                item.addEventListener('click', function (e) {
                    e.preventDefault(); // 기본 이벤트 동작 방지

                    // 클릭된 메뉴 항목에 해당하는 샘플 섹션으로 이동
                    // 메뉴 항목 텍스트에서 숫자 추출
                    const itemText = this.innerText;
                    const match = itemText.match(/\d+/); // 숫자만 추출
                    if (match) {
                        const sampleId = `sample${match[0].padStart(2, '0')}`; // ID 형식에 맞춤
                        const sampleElement = document.getElementById(sampleId);
                        if (sampleElement) {
                            sampleElement.scrollIntoView({ behavior: 'smooth' }); // 스무스 스크롤
                        }
                    }
                });
            });
        })
        // 스크롤 감지해서 버튼 표시
        window.onscroll = function () { scrollFunction() };

        function scrollFunction() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                document.getElementById("scrollTopBtn").style.display = "block";
            } else {
                document.getElementById("scrollTopBtn").style.display = "none";
            }
        }

        // 맨 위로 스크롤
        function topFunction() {
            document.body.scrollTop = 0; // 사파리 브라우저를 위함
            document.documentElement.scrollTop = 0; // 크롬, 파이어폭스, IE, 오페라
        }
    </script>
    <!-- //공부 -->
</body>

</html>