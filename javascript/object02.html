<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 :: 배열 객체</title>

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/default.min.css">
    <style>
        /* 맨 위로 올라가는 스크롤 버튼 */
        #scrollTopBtn {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: none;
            font-size: 18px;
            background-color: #555;
            color: white;
            cursor: pointer;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <header id="header">
        <h1>
            <a href="index.html">javascript</a>
        </h1>
        <nav>
            <ul>
                <li><a href="javascript01.html">데이터 저장하기</a></li>
                <li><a href="javascript02.html">데이터 불러오기</a></li>
                <li><a href="javascript03.html">데이터 실행하기</a></li>
                <li><a href="javascript04.html">데이터 제어하기</a></li>
            </ul>
            <ul>
                <li><a href="object01.html">문자열 객체</a></li>
                <li class="active"><a href="object02.html">배열 객체</a></li>
                <li><a href="object03.html">수학 객체</a></li>
                <li><a href="object04.html">숫자 객체</a></li>
                <li><a href="object05.html">브라우저 객체</a></li>
                <li><a href="object06.html">요소 객체</a></li>
                <li><a href="object07.html">이벤트 객체</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="main__menu container">
            <ul>
                <li><a href="sample01">01. <em>at()</em> 메서드는 지정한 숫자(index)를 받아, 배열에서 해당 되는 인덱스의 요소를 반환합니다.</a></li>
                <li><a href="sample02">02. <em>concat()</em> 메서드는 둘 이상의 배열을 결합하여, 새로운 배열을 반환합니다.</a></li>
                <li><a href="sample03">03. <em>copyWithin()</em> 메서드는 배열의 일부를 얕게 복사한 뒤, 동일한 배열의 다른 위치에 덮어쓰고 그 배열을
                        반환합니다.</a></li>
                <li><a href="sample04">04. <em>entries()</em> 메서드는 배열의 각 인덱스에 대한 속성 값을 반환합니다.</a></li>
                <li><a href="sample05">05. <em>keys()</em> 메서드는 배열의 각 인덱스에 대한 키 값을 반환합니다.</a></li>
                <li><a href="sample06">06. <em>fill()</em> 메서드는 배열의 시작 인덱스부터 끝 인덱스까지 하나의 값으로 반환합니다.</a></li>
                <li><a href="sample07">07. <em>find()</em>💙💙 메서드는 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환합니다.</a></li>
                <li><a href="sample08">08. <em>findIndex()</em> 메서드는 주어진 판별 함수를 만족하는 첫 번째 요소의 인덱스를 반환합니다.</a></li>
                <li><a href="sample09">09. <em>findLast()</em> 메서드는 주어진 판별 함수를 만족하는 마지막 요소의 값을 반환합니다.</a></li>
                <li><a href="sample10">10. <em>findLastIndex()</em> 메서드는 주어진 판별 함수를 만족하는 마지막 요소의 인덱스를 반환합니다.</a></li>
                <li><a href="sample11">11. <em>flat()</em> 메서드는 중첩된 배열을 하나의 배열로 평탄화합니다.</a></li>
                <li><a href="sample12">12. <em>flatMap()</em> 메서드는 먼저 매핑함수를 사용해 각 엘리먼트에 대해 map 수행 후, 결과를 새로운 배열로
                        평탄화합니다.</a></li>
                <li><a href="sample13">13. <em>forEach()</em>💙💙💙 메서드는 주어진 함수 조건을 배열 요소 각각에 대해 실행하고, 그 결과를 반환합니다.</a>
                </li>
                <li><a href="sample14">14. <em>filter()</em>💙 메서드는 주어진 함수 조건에 맞는 모든 요소를 새로운 배열로 반환합니다.</a></li>
                <li><a href="sample15">15. <em>every()</em> 메서드는 주어진 함수를 모든 요소가 통과하는지 확인하고, 불린(true, false)로 반환합니다.</a>
                </li>
                <li><a href="sample16">16. <em>map()</em>💙💙💙 메서드는 주어진 함수를 호출하여 각 요소에 대한 결과를 모아 새로운 배열을 만듭니다.</a></li>
                <li><a href="sample17">17. <em>some()</em> 메서드는 주어진 판별 함수를 하나라도 통과하는지 테스트하여, 그 결과를 불린(true, false)로
                        반환합니다.</a></li>
                <li><a href="sample18">18. <em>includes()</em>💙 메서드는 배열 내에 특정 요소가 포함되어 있는지를 검색하여, 불린(true, false)을
                        반환합니다.</a></li>
                <li><a href="sample19">19. <em>indexOf()</em>💙 메서드는 배열을 검색하고, 주어진 값과 일치하는 첫 번째 인덱스를 반환합니다.</a></li>
                <li><a href="sample20">20. <em>lastIndexOf()</em> 메서드는 배열을 역순으로 검색하여, 주어진 값과 일치하는 첫 번째 인덱스를 반환합니다.</a>
                </li>
                <li><a href="sample21">21. <em>join()</em>💙💙 메서드는 배열의 요소를 연결하여 하나의 문자열로 반환합니다.</a></li>
                <li><a href="sample22">22. <em>pop()</em> 메서드는 배열 마지막 요소를 제거하고, 그 요소를 반환합니다.</a></li>
                <li><a href="sample23">23. <em>push()</em>💙💙 메서드는 배열 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환합니다.</a></li>
                <li><a href="sample24">24. <em>reduce()</em>💙 메서드는 배열의 각 요소에 주어진 리듀서 함수를 실행하고, 하나의 결과값을 반환합니다.</a></li>
                <li><a href="sample25">25. <em>reduceRight()</em> 메서드는 배열의 각 요소를 마지막부터 실행하고, 하나의 결과값을 반환합니다.</a></li>
                <li><a href="sample26">26. <em>reverse()</em>💙 메서드는 배열 요소의 순서를 반대로 하고, 그 결과로 변경된 배열을 반환합니다.</a></li>
                <li><a href="sample27">27. <em>shift()</em> 메서드는 배열 처음 요소를 제거하고, 그 요소를 반환합니다.</a></li>
                <li><a href="sample28">28. <em>unshift()</em> 메서드는 배열 앞에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환합니다.</a></li>
                <li><a href="sample29">29. <em>slice()</em>💙💙 메서드는 배열의 지정된 부분을 새로운 배열로 반환합니다.</a></li>
                <li><a href="sample30">30. <em>splice()</em>💙💙 메서드는 배열에서 하나 이상의 요소를 추가하거나 제거하고, 변경된 배열을 반환합니다.</a>
                </li>
                <li><a href="sample31">31. <em>sort()</em>💙💙 메서드는 배열의 요소를 적절한 위치에 정렬하고, 그 배열을 반환합니다.</a></li>
                <li><a href="sample32">32. <em>toLocaleString()</em> 메서드는 배열의 요소를 로케일에 맞게 문자열로 변환하고, 그 문자열을 반환합니다.</a>
                </li>
                <li><a href="sample33">33. <em>toString()</em> 메서드는 배열의 요소를 문자열로 변환하고, 그 문자열을 반환합니다.</a></li>
                <li><a href="sample34">34. <em>values()</em> 메서드는 배열의 각 요소에 대한 값을 순차적으로 반환합니다.</a></li>
            </ul>
            </ul>
        </div>
        <!-- //main__menu -->

        <div class="main__sample container">
            <div id="sample01" class="sample">
                <h3>01. .at()</h3>
                <p class="notics">arr.at(index)</p>
                <ul>
                    <li>인자로 받은 인덱스에 해당하는 배열의 요소를 반환합니다.</li>
                    <li>음수 인덱스도 처리할 수 있으며, 이 경우 배열의 끝에서부터 요소를 찾습니다.</li>
                    <li>-1은 배열의 마지막 요소를 가리킵니다.</li>
                    <li>음수 인덱스를 사용할경우 length 속성과 인덱스 계산을 사용하지 않고도, 직관적으로 배열의 마지막 요소나 마지막 요소들에 접근할 수 있게 해줍니다.</li>
                    <li>배열의 길이를 넘어서는 인덱스에 대해서는 undefined를 반환합니다.</li>
                    <li>구형 브라우저나 환경에서는 사용하기 전에 호환성을 확인해야 합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const array = [10, 20, 30, 40, 50];

        // 양수 인덱스를 사용하여 요소에 접근
        console.log(array.at(0)); // 10을 출력
        console.log(array.at(2)); // 30을 출력
        console.log(array.at(10)); // undefined
        
        // 음수 인덱스를 사용하여 요소에 접근
        console.log(array.at(-1)); // 50을 출력
        console.log(array.at(-3)); // 30을 출력
}</code></pre>
            </div>
            <!-- //sample01 -->
            <div id="sample02" class="sample">
                <h3>02. .concat()</h3>
                <p class="notics">arr.concat(결합할 배열)</p>
                <ul>
                    <li>두 개 이상의 배열을 결합하여 새로운 배열을 생성합니다.</li>
                    <li>원본 배열을 변경하지 않고, 기존의 배열들을 이어 붙인 새로운 배열을 반환합니다.</li>
                    <li>배열뿐만 아니라, 배열로 취급할 수 있는 객체나 단일 값들도 인자로 받을 수 있습니다. </li>
                    <li>배열을 인자로 전달할 때, 해당 배열은 하나의 요소로 추가됩니다.</li>
                </ul>
                <pre class="javascript"><code>{
        var array1 = ['a', 'b', 'c'];
        var array2 = ['d', 'e', 'f'];
        var newArray = array1.concat(array2);  //['a', 'b', 'c', 'd', 'e', 'f']

        var array1 = [1, 2, 3];
        var newArray = array1.concat(4, 5, 6);
        console.log(newArray); // [1, 2, 3, 4, 5, 6]

        array1 = [1, 2, 3];
        var array2 = [4, [5, 6]];
        var newArray = array1.concat(array2);
        console.log(newArray); // [1, 2, 3, 4, [5, 6]]
}</code></pre>
            </div>
            <!-- //sample02 -->
            <div id="sample03" class="sample">
                <h3>03. .copyWithin()</h3>
                <p class="notics">arr.copyWithin(target, start, end)</p>
                <ul>
                    <li>target: 복사한 요소를 덮어쓸 대상 위치의 인덱스입니다. 음수 인덱스가 지정되면 배열의 끝에서부터 위치를 계산합니다.</li>
                    <li>start (선택적): 복사를 시작할 위치의 인덱스입니다. 기본값은 0입니다. 음수 인덱스가 지정되면 배열의 끝에서부터 위치를 계산합니다.</li>
                    <li>end (선택적): 복사를 끝낼 위치의 인덱스로, 이 인덱스에 해당하는 요소는 복사되지 않습니다. </li>
                </ul>
                <ul>
                    <li>배열 내에서 요소들의 위치를 변경하고자 할 때 사용되는 JavaScript의 배열 메서드입니다.</li>
                    <li>배열의 일부분을 얕게(Shallow) 복사한 다음, 동일한 배열 내에서 다른 위치에 덮어쓰고, 수정된 배열을 반환합니다.</li>
                    <li>원본 배열이 변경되며, 새로운 배열을 생성하지 않습니다. 즉 배열의 길이를 변경하지 않습니다.</li>
                </ul>
                <pre class="javascript"><code>{
        var array = ['a', 'b', 'c', 'd', 'e'];

        // 첫 번째 위치부터 'c', 'd'를 복사하여 두 번째 위치에 덮어쓰기
        array.copyWithin(1, 2, 4);
        
        console.log(array); // 결과: ['a', 'c', 'd', 'd', 'e']
}</code></pre>
                <ul>
                    <li>이 예에서 array.copyWithin(1, 2, 4) 는 인덱스 2('c')부터 인덱스 4('e') 이전까지, 즉 'c', 'd'를 인덱스 1의 위치부터 덮어쓰므로,
                        최종적으로 배열은 ['a', 'c', 'd', 'd', 'e']가 됩니다.</li>
                </ul>
            </div>
            <!-- //sample03 -->
            <div id="sample04" class="sample">
                <h3>04. .entries()</h3>
                <p class="notics">arr.entries()</p>
                <ul>
                    <li>배열의 각 인덱스에 대한 키-값 쌍을 포함하는 새로운 Array Iterator 객체를 반환합니다.</li>
                    <li>배열 내 각 요소의 인덱스와 값에 쉽게 접근할 수 있으며, 반복문과 함께 사용하여 배열 요소를 순회할 때 유용합니다.</li>
                    <li>각 배열 요소의 인덱스와 값을 포함하는 배열을 순서대로 반환합니다.</li>
                    <li>entries() 메서드는 for...of 루프 뿐만 아니라 Array.from() 메서드나 구조 분해 할당(destructuring assignment)과 함께 사용할 수
                        있어 유연성을 제공합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const array = ['a', 'b', 'c'];
        const iterator = array.entries();
        
        for (let e of iterator) {
            console.log(e);
        }
        //[0, 'a']
        //[1, 'b']
        //[2, 'c']

        const array = ['a', 'b', 'c'];
        const iterator = array.entries();

        // Array.from()으로 Array Iterator를 배열로 변환
        const entriesArray = Array.from(iterator);
        console.log(entriesArray);
        // 출력: [[0, 'a'], [1, 'b'], [2, 'c']]

        // 구조 분해 할당으로 각 쌍의 인덱스와 값을 분리하여 출력
        for (let [index, value] of array.entries()) {
        console.log(`Index: ${index}, Value: ${value}`);
        }
}</code></pre>
            </div>
            <!-- //sample04 -->
            <div id="sample05" class="sample">
                <h3>05. .keys()</h3>
                <p class="notics">arr.keys()</p>
                <ul>
                    <li>열의 각 인덱스를 키로 하는 새로운 Array Iterator 객체를 반환합니다.</li>
                    <li>배열의 인덱스에 접근하거나, 배열을 순회하면서 인덱스를 사용해야 할 때 유용합니다.</li>
                    <li>배열의 모든 인덱스에 대한 키(즉, 인덱스 자체)를 순차적으로 얻을 수 있습니다. </li>
                    <li>다른 반복 가능한 프로토콜을 사용하는 경우에도 유용합니다. 예를 들어, Array.from() 메서드를 사용하여 Array Iterator를 배열로 변환할 수 있습니다
                    </li>
                </ul>
                <pre class="javascript"><code>{
        const array = ['a', 'b', 'c'];
        const iterator = array.keys();
        
        for (let key of iterator) {
            console.log(key);
        }
        // 0
        // 1
        // 2

        const array = ['a', 'b', 'c'];
        const keysArray = Array.from(array.keys());
        console.log(keysArray); // [0, 1, 2]
}</code></pre>
            </div>
            <!-- //sample05 -->
            <div id="sample06" class="sample">
                <h3>06. .fill()</h3>
                <p class="notics">arr.fill(value, start, end)</p>
                <ul>
                    <li>value: 배열에 채울 값입니다.</li>
                    <li>start (선택적): 값으로 채우기 시작할 인덱스입니다. 기본값은 0입니다. 만약 음수가 주어지면, 배열의 끝에서부터의 인덱스로 계산됩니다.</li>
                    <li>end (선택적): 값으로 채우기를 멈출 인덱스입니다. end 인덱스의 바로 앞까지 채워집니다. 기본값은 배열의 길이입니다. 이 값 역시 음수가 주어질 수 있으며, 이 경우
                        배열의 끝에서부터의 인덱스로 계산됩니다.</li>
                </ul>
                <ul>
                    <li>배열의 일부분 또는 전체를 정해진 값으로 채우는 데 사용됩니다.</li>
                    <li>원본 배열을 변경하며, 변경된 배열을 반환합니다. 새로운 배열을 생성하지 않습니다.</li>
                    <li>fill() 메서드는 최대 세 개의 매개변수를 받을 수 있습니다</li>
                    <li>배열의 모든 요소를 초기화하거나 특정 값으로 빠르게 채우고 싶을 때 유용합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const array = [1, 2, 3, 4, 5];
        // 배열의 1번 인덱스부터 3번 인덱스 전까지 'a'로 채웁니다.
        array.fill('a', 1, 3);
        console.log(array); // [1, 'a', 'a', 4, 5]

        const array = new Array(5).fill(0);
        console.log(array); // [0, 0, 0, 0, 0]
}</code></pre>
            </div>
            <!-- //sample06 -->
            <div id="sample07" class="sample">
                <h3>07. .find()</h3>
                <p class="notics">arr.find(callback(element[, index[, array]])[, thisArg])</p>
                <ul>
                    <li>callback: 각 요소에 대해 실행할 함수로, 세 가지 인자를 받습니다</li>
                    <li>element: 배열 내 현재 처리 중인 요소.</li>
                    <li>index (선택적): 배열 내 현재 처리 중인 요소의 인덱스.</li>
                    <li>array (선택적): find 메서드가 호출된 배열.</li>
                    <li>thisArg (선택적): callback 함수 내에서 this로 사용할 값.</li>
                </ul>
                <ul>
                    <li>배열 내의 요소를 순회하면서 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환합니다.</li>
                    <li>판별 함수를 만족하는 첫 번째 요소의 값. 만약 해당하는 요소가 없다면 undefined가 반환됩니다.</li>
                    <li>객체의 배열에서 특정 속성을 기준으로 객체를 찾거나, 특정 범위의 값을 가진 요소를 찾는 등의 작업에 활용할 수 있습니다.</li>
                    <li>배열 내부를 검색할 때 특정 조건을 만족하는 첫 번째 요소를 찾기 위해 유용하게 사용됩니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const array = [5, 12, 8, 130, 44];

        const found = array.find(element => element > 10);
        
        console.log(found); // 출력: 12
}</code></pre>
                <ul>
                    <li>이 예제에서 array.find() 메서드는 배열 array를 순회하면서 각 요소가 element > 10이라는 조건을 만족하는지 확인합니다. 12는 이 조건을 만족하는 첫
                        번째 요소이므로 12가 반환됩니다.</li>
                </ul>
            </div>
            <!-- //sample07 -->
            <div id="sample08" class="sample">
                <h3>08. .findIndex()</h3>
                <p class="notics">arr.findIndex(callback(element[, index[, array]])[, thisArg])</p>
                <ul>
                    <li>callback: 각 요소에 대해 실행할 함수로, 세 가지 인자를 받을 수 있습니다.</li>
                    <li>element: 배열에서 현재 처리 중인 요소입니다.</li>
                    <li>index(선택적): 배열에서 현재 처리 중인 요소의 인덱스입니다.</li>
                    <li>array(선택적): findIndex()가 호출된 배열입니다.</li>
                    <li>thisArg(선택적): callback을 실행할 때 this로 사용할 값입니다.</li>
                </ul>
                <ul>
                    <li>배열 내 각 요소에 대해 주어진 판별 함수를 실행하고, 그 함수를 만족하는 첫 번째 요소(즉, 판별 함수가 true를 반환하는 요소)의 인덱스를 반환합니다.</li>
                    <li> 어떤 요소도 판별 함수를 만족시키지 못하면, -1을 반환합니다.</li>
                    <li>배열에서 특정 조건을 만족하는 요소의 위치를 찾을 때 유용합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const array = [5, 12, 8, 130, 44];

        const isLargeNumber = (element) => element > 13;
        
        console.log(array.findIndex(isLargeNumber)); // 3
}</code></pre>
                <ul>
                    <li>이 예제에서 isLargeNumber 함수는 각 요소가 13보다 큰지를 판별합니다. array.findIndex(isLargeNumber)는 배열의 각 요소에 대해
                        isLargeNumber 함수를 실행하고, 첫 번째로 이 조건을 만족하는 요소인 130의 인덱스인 3을 반환합니다.</li>
                </ul>
            </div>
            <!-- //sample08 -->
            <div id="sample09" class="sample">
                <h3>09. .findLast()</h3>
                <p class="notics">findLast(arr, callback)</p>
                <ul>
                    <li>배열을 역순으로 검사하여 주어진 판별 함수를 만족하는 첫 번째 (즉, 원래 배열의 관점에서는 마지막) 요소의 값을 반환합니다. </li>
                    <li>만약 어떤 요소도 주어진 함수를 만족시키지 않는다면, undefined를 반환합니다.</li>
                    <li>배열에서 특정 조건을 만족하는 요소의 위치를 찾을 때 유용합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        function findLast(arr, callback) {
            for (let i = arr.length - 1; i >= 0; i--) {
                if (callback(arr[i], i, arr)) {
                return arr[i];
                }
            }
            return undefined;
        }

        const numbers = [5, 12, 8, 130, 44];

        const lastLargeNumber = findLast(numbers, (element) => element > 20);

        console.log(lastLargeNumber); // 44
}</code></pre>
                <ul>
                    <li> 예시에서 findLast() 함수는 배열 numbers에서 20보다 큰 마지막 요소를 찾아 44를 반환합니다.
                </ul>
            </div>
            <!-- //sample09 -->
            <div id="sample10" class="sample">
                <h3>10. .findLastIndex()</h3>
                <p class="notics">findLastIndex(arr, callback)</p>
                <ul>
                    <li>배열을 역순으로 검색하여 주어진 판별 함수를 만족하는 마지막 요소의 인덱스를 반환하도록 설계되어 있습니다.</li>
                    <li>어떤 요소도 판별 함수를 만족하지 않는다면, -1을 반환합니다.</li>
                    <li>아래와 같은 방식으로 findLastIndex() 메서드의 기능을 직접 구현할 수 있으며, 이는 배열을 역순으로 탐색하여 특정 조건을 만족하는 마지막 요소의 위치를 찾을 때
                        유용합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        function findLastIndex(arr, callback) {
            for (let i = arr.length - 1; i >= 0; i--) {
                if (callback(arr[i], i, arr)) {
                return i;
                }
            }
            return -1; // 요소를 찾지 못했을 때
        }

        const numbers = [5, 12, 8, 130, 44, 10];

        const lastIndex = findLastIndex(numbers, (element) => element > 13);
        
        console.log(lastIndex); // 4
}</code></pre>
                <ul>
                    <li>이 예시에서 findLastIndex() 함수는 numbers 배열에서 13보다 큰 마지막 요소의 인덱스를 찾습니다. 여기서는 값이 44인 요소가 조건을 만족하므로, 그
                        인덱스인 4가 반환됩니다.</li>
                </ul>
            </div>
            <!-- //sample10 -->
            <div id="sample11" class="sample">
                <h3>11. .flat()</h3>
                <p class="notics">var newArray = arr.flat([depth])</p>
                <ul>
                    <li>depth (선택적): 평탄화할 깊이를 지정하는 숫자입니다. 기본값은 1입니다. 이 값이 0이면, 원본 배열의 얕은 복사본이 반환됩니다. Infinity를 사용하면 모든
                        중첩 배열을 평탄화할 수 있습니다.</li>
                </ul>
                <ul>
                    <li>중첩된 배열을 지정된 깊이까지 재귀적으로 평탄화하여 새로운 배열을 생성합니다.</li>
                    <li>중첩된 배열 구조를 단순화할 때 유용하게 사용됩니다.</li>
                    <li>중첩된 배열을 지정된 깊이까지 평탄화한 새로운 배열을 반환합니다. 원본 배열은 변경되지 않습니다.</li>
                    <li>배열 내에서 빈 요소를 제거하는 부수적인 효과도 있습니다. 이는 데이터를 정제할 때 유용하게 활용될 수 있습니다.</li>
                </ul>
                <pre class="javascript"><code>{
        //기본 사용법
        const arr1 = [1, 2, [3, 4]];
        arr1.flat();   // 결과: [1, 2, 3, 4]

        //깊이 지정하기
        const arr2 = [1, 2, [3, 4, [5, 6]]];
        arr2.flat();   // 기본 깊이 1 결과: [1, 2, 3, 4, [5, 6]]
        
        arr2.flat(2);  // 깊이 2 결과: [1, 2, 3, 4, 5, 6]

        //빈 요소를 제거하기
        const arr3 = [1, 2, , 4, 5];
        arr3.flat();   // 결과: [1, 2, 4, 5]
}</code></pre>
            </div>
            <!-- //sample11 -->
            <div id="sample12" class="sample">
                <h3>12. .flatMap()</h3>
                <p class="notics">let newArray = arr.flatMap(function callback(currentValue[, index[, array]]) {
                    // 반환값으로 새 배열의 요소를 생성
                    }[, thisArg]);</p>
                <ul>
                    <li>currentValue: 처리할 현재 요소입니다.</li>
                    <li>callback: 각 배열 요소에 대해 실행할 함수로, 최대 세 개의 인자(currentValue, index, array)를 받습니다.</li>
                    <li>index (선택적): 처리할 현재 요소의 인덱스입니다.</li>
                    <li>array (선택적): flatMap이 호출된 배열입니다.</li>
                    <li>thisArg (선택적): callback 함수 내에서 this로 사용될 값입니다.</li>
                </ul>
                <ul>
                    <li>배열의 각 요소에 매핑 함수를 적용한 후 결과를 평탄화(flatten)하는 작업을 한 번의 연산으로 수행합니다.</li>
                    <li>이 메소드는 map() 메소드와 flat() 메소드의 조합으로 생각할 수 있으며, 중첩 배열을 처리하고 결과를 단일 배열로 평탄화할 때 유용합니다.</li>
                    <li>새로운 평탄화된 배열을 반환합니다.</li>
                    <li>원본 배열을 변경하지 않고 새 배열을 반환합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        //기본 사용법
        let arr = [1, 2, 3, 4];

        let mappedAndFlattened = arr.flatMap(x => [x, x * 2]);
        console.log(mappedAndFlattened);  // [1, 2, 2, 4, 3, 6, 4, 8]

        //중첩 배열 평탄화
        let arr = [1, 2, [3, 4]];

        let flattened = arr.flatMap(x => [x]);
        console.log(flattened);  // [1, 2, [3, 4]] -> `flatMap`의 기본 평탄화 깊이는 1이므로 한 단계만 평탄화됩니다.
}</code></pre>
                <p>기본 사용법</p>
                <ul>
                    <li>매핑 함수 x => [x, x * 2]를 각 배열 요소 x에 적용합니다. 이 함수는 주어진 요소 x를 취하여, 요소 x와 x의 두 배를 포함하는 새 배열을 생성합니다.
                    </li>
                    <li>1. 배열의 첫 번째 요소인 1에 대해 함수를 적용하면, [1, 2] (1의 두 배는 2)를 얻습니다.</li>
                    <li>2. 배열의 두 번째 요소인 2에 대해 함수를 적용하면, [2, 4] (2의 두 배는 4)를 얻습니다.</li>
                    <li>같은 방식으로 배열의 세 번째 요소인 3에 대해 함수를 적용하면, [3, 6]을 얻고, 네 번째 요소인 4에 대해 함수를 적용하면 [4, 8]을 얻습니다.</li>
                </ul>
            </div>
            <!-- //sample12 -->
            <div id="sample13" class="sample">
                <h3>13. .forEach()</h3>
                <p class="notics">arr.forEach(callback(currentValue[, index[, array]])[, thisArg])</p>
                <ul>
                    <li>callback: 각 요소에 대해 실행할 함수로, 세 가지 인자를 받습니다</li>
                    <li>currentValue: 배열에서 처리 중인 현재 요소입니다.</li>
                    <li>index (선택적): 배열 내 현재 처리 중인 요소의 인덱스.</li>
                    <li>array (선택적): forEach() 메서드가 호출된 배열.</li>
                    <li>thisArg (선택적): callback 함수 내에서 this로 사용할 값.</li>
                </ul>
                <ul>
                    <li>배열의 각 요소에 대해 주어진 함수를 실행하는 메서드입니다.</li>
                    <li>forEach() 메서드 자체는 어떠한 값도 반환하지 않습니다(undefined를 반환).</li>
                    <li>주요 목적은 배열의 각 요소에 대해 부작용(side effect)을 일으키는 함수를 실행하는 것입니다.</li>
                    <li>주로 배열의 각 요소를 콘솔에 출력하거나, 배열의 각 요소를 기반으로 다른 작업을 수행하는 경우에 사용</li>
                </ul>
                <pre class="javascript"><code>{
        const array = ['사과', '바나나', '체리'];

        array.forEach(function(element, index) {
            console.log(`Element at ${index}: ${element}`);
        });
}</code></pre>
                <ul>
                    <li>이 예시에서는 array 배열의 각 요소에 대해 주어진 콜백 함수를 실행합니다. 콘솔에는 배열의 각 요소와 그 인덱스가 출력됩니다.</li>
                </ul>
            </div>
            <!-- //sample13 -->
            <div id="sample14" class="sample">
                <h3>14. .filter()</h3>
                <p class="notics">const newArray = array.filter(function(element, index, arr), thisArg)</p>
                <ul>
                    <li>function(element, index, arr): 각 요소에 대해 실행할 함수입니다. 이 함수는 최대 세 개의 인자를 받을 수 있습니다.</li>
                    <li>element: 처리 중인 현재 요소입니다.</li>
                    <li>index (선택적): 처리 중인 현재 요소의 인덱스입니다.</li>
                    <li>arr (선택적): filter 메서드가 호출된 배열입니다.</li>
                    <li>thisArg (선택적): 콜백 함수 내부에서 this로 사용할 값입니다.</li>
                </ul>
                <ul>
                    <li>배열의 각 요소에 대해 주어진 판별 함수를 실행하고, 그 결과가 true를 반환하는 모든 요소로 구성된 새로운 배열을 생성합니다. 원본 배열은 변경되지 않습니다.</li>
                    <li>판별 함수를 통과한 모든 요소로 구성된 새로운 배열입니다.</li>
                    <li>어떤 요소도 조건을 만족하지 못하면 빈 배열이 반환됩니다.</li>
                    <li>특정 조건을 만족하는 요소들만 추출하고 싶을 때 유용하게 사용됩니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const numbers = [1, 2, 3, 4, 5, 6];

        // 짝수만 필터링
        const evenNumbers = numbers.filter(function(number) {
            return number % 2 === 0;
        });
        
        console.log(evenNumbers); // [2, 4, 6]
}</code></pre>
                <ul>
                    <li>이 예제에서는 numbers 배열의 각 요소에 대해 주어진 판별 함수(짝수인지 확인하는 함수)를 실행합니다. 짝수인 요소들만 새로운 배열 evenNumbers로 반환되며,
                        원본 배열 numbers는 변경되지 않습니다.</li>
                </ul>
            </div>
            <!-- //sample14 -->
            <div id="sample15" class="sample">
                <h3>15. .every()</h3>
                <p class="notics">arr.every(callback(element[, index[, array]])[, thisArg])</p>
                <ul>
                    <li>callback: 각 요소에 대해 실행할 테스트 함수입니다. 이 함수는 최대 세 개의 인자를 받을 수 있습니다.</li>
                    <li>element: 처리 중인 현재 요소입니다.</li>
                    <li>index (선택적): 처리 중인 현재 요소의 인덱스입니다.</li>
                    <li>array (선택적): every 메서드가 호출된 배열입니다..</li>
                    <li>thisArg (선택적): callback을 실행할 때 this로 사용할 값입니다.</li>
                </ul>
                <ul>
                    <li>true: 배열의 모든 요소가 callback 함수의 테스트를 통과한 경우.</li>
                    <li>배열이 비어있는 경우, every() 메서드는 true를 반환합니다. 이는 논리적으로, 빈 집합이 모든 조건을 만족한다고 간주하기 때문입니다.</li>
                    <li>false: 하나 이상의 요소가 callback 함수의 테스트를 통과하지 못한 경우.</li>

                </ul>
                <ul>
                    <li>배열의 모든 요소가 주어진 테스트 함수를 만족하는지 여부를 확인합니다.</li>
                    <li>배열의 모든 요소가 주어진 함수에 의해 구현된 테스트 조건을 통과할 경우 true를 반환하고, 그렇지 않으면 false를 반환합니다.</li>
                    <li>배열을 순회하면서 각 요소에 대해 지정된 콜백 함수를 실행합니다.</li>
                    <li>원본 배열을 변경하지 않습니다.</li>
                    <li>조건을 만족하지 않는 요소를 찾는 즉시 순회를 중단합니다. 따라서 모든 요소를 확인하지 않아도 될 경우 효율적입니다.</li>
                    <li>배열의 일관성을 검사하거나, 모든 요소가 특정 조건을 만족하는지 확인할 때 유용하게 사용할 수 있습니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const array1 = [1, 30, 39, 29, 10, 13];

        const isBelowThreshold = (currentValue) => currentValue &lt; 40;
        
        console.log(array1.every(isBelowThreshold));
        // expected output: true
}</code></pre>
                <ul>
                    <li>이 예제에서는 numbers 배열의 각 요소에 대해 주어진 판별 함수(짝수인지 확인하는 함수)를 실행합니다. 짝수인 요소들만 새로운 배열 evenNumbers로 반환되며,
                        원본 배열 numbers는 변경되지 않습니다.</li>
                </ul>
            </div>
            <!-- //sample15 -->
            <div id="sample16" class="sample">
                <h3>16. .map()</h3>
                <p class="notics">const newArray = array.map(function(currentValue, index, array), thisArg)</p>
                <ul>
                    <li>function(currentValue, index, array): 배열의 각 요소에 대해 실행할 함수입니다. 이 함수는 다음 세 가지 인자를 받을 수 있습니다.</li>
                    <li>currentValue: 처리할 현재 요소의 값입니다.</li>
                    <li>index (선택적): 처리할 현재 요소의 인덱스입니다.</li>
                    <li>array (선택적): map 메서드가 호출된 배열입니다.</li>
                    <li>thisArg (선택적): 콜백 함수 내에서 this로 사용할 값입니다.</li>
                </ul>
                <ul>
                    <li>배열 내의 모든 요소에 대해 주어진 함수를 호출한 결과를 모아 새로운 배열을 생성합니다.</li>
                    <li>원본 배열을 변경하지 않고, 각 요소를 주어진 함수를 통해 처리한 결과를 새로운 배열로 반환합니다.</li>
                    <li>메서드는 데이터를 변환하거나 조작할 때 유용하게 사용됩니다.</li>
                    <li>주로 객체 배열에서 특정 속성만 추출하여 새 배열을 만들거나, 숫자 배열의 각 요소를 변환하는 등 다양한 상황에서 활용됩니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const numbers = [1, 2, 3, 4];
        const doubled = numbers.map(number => number * 2);
        
        console.log(doubled); // [2, 4, 6, 8]
}</code></pre>
                <ul>
                    <li>이 예시에서 numbers 배열의 각 요소는 2배로 증가된 값으로 변환되며, 이러한 결과들이 doubled라는 새로운 배열로 반환됩니다. 원본 numbers 배열은 변경되지
                        않습니다.</li>
                </ul>
            </div>
            <!-- //sample16 -->
            <div id="sample17" class="sample">
                <h3>17. .some()</h3>
                <p class="notics">arr.some(callback(element[, index[, array]])[, thisArg])</p>
                <ul>
                    <li>callback: 각 요소에 대해 실행할 함수로, 최대 세 가지 인자를 받을 수 있습니다.</li>
                    <li>element: 처리 중인 현재 요소.</li>
                    <li>index (선택적): 처리할 현재 요소의 인덱스입니다.</li>
                    <li>array(선택 사항): some 메서드가 호출된 배열.</li>
                    <li>thisArg(선택 사항): callback 실행 시 this로 사용할 값.</li>
                </ul>
                <ul>
                    <li>true: 배열의 적어도 하나의 요소가 callback 함수의 테스트를 통과하는 경우.</li>
                    <li>배열의 요소 중 하나라도 조건을 만족하는 즉시 some() 메서드는 검사를 중단하고 true를 반환합니다.</li>
                    <li>false: 모든 요소가 callback 함수의 테스트를 통과하지 않는 경우.</li>
                    <li>배열이 비어있는 경우, some() 메서드는 false를 반환합니다.</li>
                </ul>
                <ul>
                    <li>배열의 요소 중 적어도 하나 이상이 주어진 판별 함수의 조건을 만족하는지 검사합니다.</li>
                    <li>만약 배열의 어떤 요소라도 해당 함수를 통과한다면 true를 반환하고, 모든 요소가 함수 조건을 만족하지 않는다면 false를 반환합니다.</li>
                    <li>배열 내에서 특정 조건을 만족하는 요소가 있는지 빠르게 확인할 때 유용합니다.</li>
                    <li>원본 배열을 변경하지 않습니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const array = [1, 2, 3, 4, 5];

        const even = (element) => element % 2 === 0;
        
        console.log(array.some(even));  // 예상 출력: true
}</code></pre>
                <ul>
                    <li>이 예제에서는 배열 array의 요소 중 적어도 하나가 짝수인지 확인합니다. even 함수는 주어진 요소가 짝수인 경우 true를 반환합니다. 배열에는 2와 4라는 두 개의
                        짝수가 있으므로, some() 메서드는 true를 반환합니다.</li>
                </ul>
            </div>
            <!-- //sample17 -->
            <div id="sample18" class="sample">
                <h3>18. .includes()</h3>
                <p class="notics">arr.includes(배열에서 찾고자 하는 요소[, 검색을 시작할 인덱스])</p>
                <ul>
                    <li>배열이 특정 요소를 포함하고 있는지 판별하여, 그 결과를 불리언 값(true 또는 false)으로 반환합니다.</li>
                    <li>배열 내에서 주어진 요소를 찾을 때, 동등 비교 알고리즘을 사용합니다.</li>
                    <li>검색할 인덱스에 음수 값을 지정하면, 배열의 끝에서부터의 거리로 계산됩니다. 기본값은 0이며, 이 경우 배열 전체가 검색 대상이 됩니다.</li>
                    <li>특정 값이 배열에 포함되어 있는지 여부만을 확인할 때 매우 유용합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const fruits = ['사과', '바나나', '망고', '오렌지'];

        console.log(fruits.includes('바나나'));  // true
        console.log(fruits.includes('포도'));   // false
        console.log(fruits.includes('망고', 3)); // false, 인덱스 3부터 검색하기 때문에 '망고'는 포함되지 않음
}</code></pre>
                <ul>
                    <li>콘솔로그 첫번쨰 : 배열 안에 바나나가 있으므로 true가 출력됩니다.</li>
                    <li>콘솔로그 두번쨰 : 배열 안에 포도가 없으므로 false가 출력됩니다</li>
                    <li>콘솔로그 셋번쨰 : 배열 안에 망고가 있지만 검색의 시작 인덱스가 3(오렌지)이기때문에 false가 출력됩니다</li>
                </ul>
            </div>
            <!-- //sample18 -->
            <div id="sample19" class="sample">
                <h3>19. .indexOf()</h3>
                <p class="notics">arr.indexOf(배열에서 찾고자 하는 요소[, 검색을 시작할 인덱스])</p>
                <ul>
                    <li>배열에서 특정 요소를 찾고 그 요소의 첫 번째 인덱스를 반환합니다.</li>
                    <li>찾고자 하는 요소가 배열에 존재하지 않는다면, -1을 반환합니다.</li>
                    <li>주어진 요소를 배열의 시작부터 순차적으로 검색합니다. 기본값은 0이며, 이 경우 배열 전체가 검색 대상이 됩니다.</li>
                    <li>특정 요소의 존재 여부 및 위치를 파악할 때 유용합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const fruits = ['사과', '바나나', '망고', '오렌지'];

        console.log(fruits.indexOf('바나나'));  // 1
        console.log(fruits.indexOf('포도'));   // -1
        console.log(fruits.indexOf('사과', 2)); // -1
}</code></pre>
                <ul>
                    <li>콘솔로그 첫번쨰 : 배열 안에 바나나의 인덱스 값인 1을 출력합니다.</li>
                    <li>콘솔로그 두번쨰 : 배열 안에 포도가 없으므로 -1이 출력됩니다</li>
                    <li>콘솔로그 셋번쨰 : 배열 안에 사과가 있지만 검색의 시작 인덱스가 2(망고)이기때문에 -1이 출력됩니다</li>
                </ul>
            </div>
            <!-- //sample19 -->
            <div id="sample20" class="sample">
                <h3>20. .lastIndexOf()</h3>
                <p class="notics">arr.lastIndexOf(searchElement[, fromIndex])</p>
                <ul>
                    <li>searchElement: 배열 내에서 찾을 요소입니다.</li>
                    <li>fromIndex (선택적): 검색을 시작할 인덱스입니다. 기본값은 배열의 길이에서 1을 뺀 값입니다(즉, 기본적으로 배열의 마지막 요소에서 검색을 시작합니다).</li>
                </ul>
                <ul>
                    <li>배열의 요소를 역순으로 검색하여 주어진 값과 일치하는 첫 번째(가장 큰 인덱스 값을 가진) 요소의 인덱스를 반환합니다. </li>
                    <li>만약 일치하는 요소가 없으면 -1을 반환합니다.</li>
                    <li>배열에서 특정 요소의 마지막 위치를 찾고자 할 때 유용합니다.</li>
                    <li>음수 값이 제공되면, 그 값은 배열의 끝에서부터의 오프셋으로 계산됩니다.</li>
                    <li>fromIndex의 절대값이 배열의 길이보다 크거나 같은 경우, 전체 배열이 검색됩니다.</li>
                    <li>특정 요소의 마지막 출현 위치를 알고 싶을 때 매우 유용합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];

        console.log(animals.lastIndexOf('Dodo'));
        // expected output: 3
        
        console.log(animals.lastIndexOf('Tiger'));
        // expected output: 1
        
        console.log(animals.lastIndexOf('Giraffe'));
        // expected output: -1
}</code></pre>
                <P>첫 번째 lastIndexOf('Dodo') 호출</P>
                <ul>
                    <li>'Dodo' 문자열이 마지막으로 나타나는 인덱스인 3을 반환합니다.</li>
                </ul>
                <P>두 번째 호출 lastIndexOf('Tiger')</P>
                <ul>
                    <li>'Tiger' 문자열의 인덱스인 1을 반환합니다. 'Giraffe'는 배열에 존재하지 않으므로, -1이 반환됩니다.</li>
                </ul>
            </div>
            <!-- //sample20 -->
            <div id="sample21" class="sample">
                <h3>21. .join()</h3>
                <p class="notics">arr.join(["요소 사이에 삽입할 문자열을 지정"])</p>
                <ul>
                    <li>배열의 모든 요소를 연결하여 하나의 문자열로 만듭니다. 각 요소 사이에는 지정된 구분자가 삽입됩니다.</li>
                    <li>이 메서드는 원본 배열을 변경하지 않습니다.</li>
                    <li>요소 사이에 삽입할 문자열을 지정합니다. 이 인자는 선택 사항입니다. 기본값은 콤마(,)입니다.</li>
                    <li>빈 문자열('')을 지정하면 요소 사이에 아무것도 삽입되지 않습니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const fruits = ['사과', '바나나', '망고', '오렌지'];

        console.log(fruits.join());  // '사과,바나나,망고,오렌지'
        console.log(fruits.join('')); // '사과바나나망고오렌지'
        console.log(fruits.join('-')); // '사과-바나나-망고-오렌지'
}</code></pre>
                <ul>
                    <li>콘솔로그 첫번쨰 : ()안에 아무것도 없어 기본값인 "," 가 입력됩니다.</li>
                    <li>콘솔로그 두번쨰 : '' 안에 공복이 없어 출력된 값 역시 공백 없이 나옵니다.</li>
                    <li>콘솔로그 셋번쨰 : 배열들이 출력될때 배열 사에이 "-"가 추가되어 나옵니다.</li>
                </ul>
            </div>
            <!-- //sample21 -->
            <div id="sample22" class="sample">
                <h3>22. .pop()</h3>
                <p class="notics">let removedElement = array.pop()</p>
                <ul>
                    <li>removedElement: 배열에서 제거된 요소입니다.</li>
                </ul>
                <ul>
                    <li>배열의 마지막 요소를 제거하고, 그 제거된 요소를 반환합니다. </li>
                    <li>배열의 길이를 변경하며, 배열이 비어있을 경우 undefined를 반환합니다.</li>
                    <li>원본 배열을 변경합니다. 즉, 이 메서드를 사용하면 배열의 길이가 줄어듭니다.</li>
                    <li>배열의 마지막 요소만을 대상으로 작동하므로, 배열의 나머지 부분은 영향을 받지 않습니다.</li>
                </ul>
                <pre class="javascript"><code>{
        let fruits = ['사과', '바나나', '체리'];
        let lastFruit = fruits.pop();
        
        console.log(lastFruit); // '체리'
        console.log(fruits); // ['사과', '바나나']
}</code></pre>
                <P>이 예제에서 fruits 배열에는 처음에 세 개의 과일 이름이 저장되어 있습니다. pop() 메서드를 호출하면 배열의 마지막 요소인 'Cherry'가 제거되고, 이 요소는
                    lastFruit 변수에 저장됩니다.</P>
            </div>
            <!-- //sample22 -->
            <div id="sample23" class="sample">
                <h3>23. .push()</h3>
                <p class="notics">arr.push(배열의 끝에 추가할 요소1, 배열의 끝에 추가할 요소2, ..., 배열의 끝에 추가할 요소N)</p>
                <ul>
                    <li>배열의 끝에 하나 이상의 요소를 추가하고, 변경된 배열의 새로운 길이를 반환합니다.</li>
                    <li>원본 배열을 직접 수정합니다.</li>
                    <li>여러 요소를 한 번에 추가할 수 있습니다.</li>
                    <li>사용자 입력을 받아 배열에 추가하거나, 데이터 처리 과정 중에 새로운 데이터를 배열에 추가해야 할 경우에 유용하게 사용됩니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const fruits = ['사과', '바나나'];

        // '망고'와 '오렌지'를 fruits 배열에 추가
        const newLength = fruits.push('망고', '오렌지');
        
        console.log(fruits);  // ['사과', '바나나', '망고', '오렌지']
        console.log(newLength);  // 4
}</code></pre>
                <ul>
                    <li>콘솔로그 첫번쨰 : fruits 안에 있는 요소들을 출력합니다.</li>
                    <li>콘솔로그 두번쨰 : fruits의 인덱스 길이를 출력합니다.</li>
                </ul>
            </div>
            <!-- //sample23 -->
            <div id="sample24" class="sample">
                <h3>24. .reduce()</h3>
                <p class="notics">arr.reduce(callback[, initialValue])</p>
                <ul>
                    <li>callback: 배열의 각 요소에 대해 실행할 함수로, 네 개의 인자를 받습니다.</li>
                    <li>accumulator: 누적 계산의 결과값입니다. 이전 콜백 호출의 반환값이 여기에 할당됩니다.</li>
                    <li>currentValue: 처리할 현재 요소의 값입니다.</li>
                    <li>array: reduce()를 호출한 배열입니다</li>
                    <li>currentIndex (선택적): 처리할 현재 요소의 인덱스입니다. 초기값이 제공되면 0부터, 그렇지 않으면 1부터 시작합니다.</li>
                    <li>initialValue (선택적): accumulator에 처음 할당할 값입니다. 이 값이 제공되지 않으면 배열의 첫 번째 요소를 초기값으로 사용하며, 배열이
                        비어있고 initialValue가 제공되지 않으면 TypeError가 발생합니다.</li>
                </ul>
                <ul>
                    <li>배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 단 하나의 결과값을 반환합니다.</li>
                    <li>배열을 순회하며 각 요소에 대해 주어진 콜백 함수를 실행하고, 그 결과를 누적한 후 최종 결과를 반환합니다.</li>
                    <li>배열의 크기나 요소 상태와 관계없이 단일 값으로 축약(reduce)하는 작업을 수행합니다.</li>
                    <li>반환값은 함수가 배열을 모두 순회한 후의 최종 결과값입니다.</li>
                    <li>배열의 요소를 축약하여 단일 값으로 만들어야 할 때 유용하게 사용됩니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const numbers = [1, 2, 3, 4];
        const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
        
        console.log(sum); // 10
}</code></pre>
                <ul>
                    <li>이 예시에서 reduce() 메서드는 numbers 배열의 모든 숫자를 더하는 작업을 수행합니다. 여기서 accumulator는 누적 합계를,
                        currentValue는 현재 처리 중인 배열 요소의 값을 나타냅니다. 초기값 0이 accumulator의 시작값으로 설정되었으며, 배열의 모든 요소가 처리된
                        후 최종 합계인 10이 반환됩니다.
                    </li>
                </ul>
            </div>
            <!-- //sample24 -->
            <div id="sample25" class="sample">
                <h3>25. .reduceRight()</h3>
                <p class="notics">arr.reduceRight(callback(accumulator, currentValue, index, array), initialValue)</p>
                <ul>
                    <li>callback: 배열의 각 요소에 대해 실행할 함수로, 네 개의 인자를 받습니다.</li>
                    <li>accumulator: 누산기는 callback의 반환값이 누적되는 곳입니다. 이전 callback 호출의 반환값이 여기에 저장됩니다.</li>
                    <li>currentValue: 처리할 현재 요소입니다.</li>
                    <li>index (선택사항): 처리할 현재 요소의 인덱스입니다.</li>
                    <li>array (선택사항): reduceRight가 호출된 배열입니다.</li>
                    <li>initialValue (선택사항): accumulator의 첫 번째 호출에 제공되는 값입니다.</li>
                </ul>
                <ul>
                    <li>배열의 각 요소에 대해 주어진 reducer 함수를 실행하고, 단 하나의 결과값을 반환합니다.</li>
                    <li>배열을 축약하거나 축소하는 데에 주로 사용되며, 복잡한 데이터 구조를 단일 값으로 요약할 수 있습니다.</li>
                    <li>초기값을 제공하지 않으면 배열의 마지막 요소가 초기값으로 사용되며, 이 경우 배열의 마지막에서 두 번째 요소부터 callback 함수가 실행됩니다.</li>
                    <li>배열을 순회하면서 단일 값으로 축약하는 데 유용합니다.</li>
                    <li>배열이 비어있고 초기값도 제공되지 않으면 TypeError가 발생합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const array = [0, 1, 2, 3, 4];
        const reducer = (accumulator, currentValue) => accumulator + currentValue;
        
        // 0 + 1 + 2 + 3 + 4 = 10
        console.log(array.reduceRight(reducer, 0)); // 10
}</code></pre>
                <ul>
                    <li>이 예시에서, reduceRight() 메서드는 배열의 마지막 요소부터 시작하여 각 요소를 더하는 reducer 함수를 사용합니다. 초기값 0이 누산기의 시작값으로
                        사용되며, 최종적으로 총 합인 10을 반환합니다.</li>
                </ul>
            </div>
            <!-- //sample25 -->
            <div id="sample26" class="sample">
                <h3>26. reverse()</h3>
                <p class="notics">arr.reverse()</p>
                <ul>
                    <li>배열의 요소 순서를 반대로 뒤집습니다. 이 메서드는 배열 자체를 변형시키며, 변형된 배열을 반환합니다.</li>
                    <li>원본 배열이 변경되고, 변경된 배열이 반환값으로 제공됩니다.</li>
                    <li>배열의 순서를 뒤집을 때 유용하며, 시각적 표현이나 데이터 처리 시 특정 순서를 반대로 해야 할 경우에 자주 사용됩니다.</li>
                    <li>원본 배열을 유지하면서 순서를 뒤집고 싶은 경우, slice() 메서드로 배열을 복사한 후 reverse()를 사용할 수 있습니다.</li>
                    <li>반환값은 순서가 반대로 된 배열. 원본 배열이 수정되며, 수정된 배열이 반환됩니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const numbers = [1, 2, 3, 5, 5];
        const reversedNumbers = numbers.reverse();
        
        console.log(reversedNumbers); // [5, 4, 3, 2, 1]
        console.log(numbers); // [5, 4, 3, 2, 1], 원본 배열도 변형됩니다.
}</code></pre>
                <ul>
                    <li>이 예시에서 볼 수 있듯이, reverse() 메서드를 사용하여 numbers 배열의 요소 순서를 반대로 뒤집었습니다. reversedNumbers와 numbers 모두
                        변형된 배열을 참조하므로 두 출력은 같은 결과를 보여줍니다.
                    </li>
                </ul>
            </div>
            <!-- //sample26 -->
            <div id="sample27" class="sample">
                <h3>27. shift()</h3>
                <p class="notics">let removedElement = array.shift()</p>
                <ul>
                    <li>removedElement: 배열에서 제거된 첫 번째 요소입니다. </li>
                </ul>
                <ul>
                    <li>배열의 첫 번째 요소를 제거하고, 그 제거된 요소를 반환합니다.</li>
                    <li>배열의 길이를 변경하며, 배열이 비어 있을 경우 undefined를 반환합니다.</li>
                    <li>배열의 나머지 요소들은 그대로 유지되지만, 각 요소의 인덱스가 1씩 감소합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        let numbers = [1, 2, 3, 4, 5];
        let firstNumber = numbers.shift();
        
        console.log(firstNumber); // 1
        console.log(numbers); // [2, 3, 4, 5]
}</code></pre>
                <ul>
                    <li>이 예시에서 numbers 배열에는 처음에 1, 2, 3, 4, 5가 들어 있습니다. shift() 메서드를 호출하면 배열의 첫 번째 요소인 1이 제거되고, 이 값이
                        firstNumber 변수에 저장됩니다.</li>
                </ul>
            </div>
            <!-- //sample27 -->
            <div id="sample28" class="sample">
                <h3>28. unshift()</h3>
                <p class="notics">let newLength = array.unshift(element1[, ...[, elementN]])</p>
                <ul>
                    <li>element1, ..., elementN: 배열의 시작 부분에 추가할 요소들입니다.</li>
                    <li>newLength: 배열에 요소를 추가한 후의 새로운 길이입니다.</li>
                </ul>
                <ul>
                    <li>배열의 첫 번째 위치에 하나 이상의 요소를 추가하는 메서드입니다.</li>
                    <li>배열의 원본을 직접 변경합니다.</li>
                    <li>추가 후의 배열의 새로운 길이를 반환합니다.</li>
                    <li>unshift()는 배열의 원본을 변경하며, 추가된 요소들을 포함한 새로운 배열의 길이를 결과값으로 반환합니다.</li>
                    <li>배열의 시작 부분에 하나 이상의 요소를 추가합니다.</li>
                    <li>배열이 비어 있을 경우, 추가한 요소들만을 포함한 새로운 배열을 생성하고, 그 길이를 반환합니다.</li>
                </ul>
                <pre class="javascript"><code>{
        let fruits = ['바나나', '오렌지', '사과', '망고'];
        let newLength = fruits.unshift('딸기', '블루베리');
        
        console.log(newLength); // 6
        console.log(fruits); // ['딸기', '블루베리', '바나나', '오렌지', '사과', '망고']
}</code></pre>
                <ul>
                    <li>이 예제에서, fruits 배열은 초기에 '바나나', '오렌지', '사과', '망고' 네 가지 요소를 포함하고 있습니다. unshift() 메서드를
                        사용하여 '딸기'와 '블루베리'를 배열의 앞부분에 추가한 후, 배열의 새로운 길이인 6을 반환합니다.</li>
                </ul>
            </div>
            <!-- //sample28 -->
            <div id="sample29" class="sample">
                <h3>29. slice()</h3>
                <p class="notics">arr.slice([추출 시작점의 인덱스[, 추출을 종료할 지점의 인덱스]])</p>
                <ul>
                    <li>특정 부분을 선택하여 새로운 배열 객체로 반환합니다.</li>
                    <li>원본 배열을 변경하지 않고, 선택된 요소를 포함한 새로운 배열을 생성합니다.</li>
                    <li>만약 추출 시작점의 인덱스가 음수라면 배열의 끝에서부터의 길이를 나타냅니다.</li>
                    <li>만약 추출 시작점의 인덱스를 생략하거나 undefined로 설정할 경우, 0부터 슬라이스가 시작됩니다. </li>
                    <li>slice는 추출을 종료할 지점의 인덱스 이전까지의 요소를 추출합니다.</li>
                    <li>추출을 종료할 지점의 인덱스가 생략되거나 배열의 길이보다 크면 배열의 끝까지 추출합니다. 만약 추출을 종료할 지점의 인덱스가 음수라면 배열의 끝에서부터의 길이를 나타냅니다.
                    </li>
                    <li>반환 값은 원본 배열에서 선택된 요소를 포함하는 새로운 배열 입니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const fruits = ['바나나', '오렌지', '레몬', '사과', '망고'];

        const citrus = fruits.slice(1, 3);
        
        console.log(citrus);  // ['오렌지', '레몬']
        console.log(fruits);  // ['바나나', '오렌지', '레몬', '사과', '망고'], 원본 배열은 변경되지 않음
}</code></pre>
                <ul>
                    <li>이 예제에서, fruits 배열의 1번 인덱스부터 시작하여 3번 인덱스 이전까지(즉, 1번 및 2번 인덱스를 포함)의 요소를 선택하여 새로운 배열 citrus를 생성합니다.
                        slice()는 원본 배열 fruits를 변경하지 않습니다.
                    </li>
                </ul>
            </div>
            <!-- //sample29 -->
            <div id="sample30" class="sample">
                <h3>30. splice()</h3>
                <p class="notics">arr.splice(start[, deleteCount[, item1[, item2[, ...]]]])</p>
                <ul>
                    <li>start: 배열을 변경하기 시작할 인덱스입니다. 만약 음수라면 배열의 끝에서부터의 위치를 나타냅니다. (예: -2는 배열의 마지막에서 두 번째 요소를 지칭)</li>
                    <li>deleteCount (선택적): 배열에서 제거할 요소의 수입니다. 이 인자가 생략되거나 배열의 길이를 넘는 수가 지정되면, start부터 모든 요소가 제거됩니다. 0이나
                        음수가 지정되면 어떤 요소도 제거되지 않습니다.</li>
                    <li>item1, item2, ... (선택적): 배열에 추가될 요소들입니다. 이 인자가 지정되지 않으면, splice()는 오직 요소를 제거하기만 합니다.</li>
                </ul>
                <ul>
                    <li>배열의 내용을 제거하거나 기존 요소를 새 요소로 대체하거나 새 요소를 추가하여 배열을 변경하는 데 사용됩니다.</li>
                    <li>배열 자체를 변경하고, 제거된 요소들로 이루어진 새 배열을 반환합니다. 만약 요소가 제거되지 않았다면, 빈 배열을 반환합니다</li>
                    <li>제거된 요소를 담고 있는 배열을 반환합니다. 만약 요소가 제거되지 않았다면, 빈 배열을 반환합니다.</li>
                    <li>하나의 메서드 호출로 배열의 특정 위치에 요소를 추가하거나, 하나 또는 여러 요소를 삭제하고, 심지어 요소를 교체하는 등 다양한 작업을 수행할 수 있습니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const months = ['Jan', 'March', 'April', 'June'];
        // 'Feb'를 'Jan' 다음에 추가합니다.
        months.splice(1, 0, 'Feb');

        // months는 이제 ['Jan', 'Feb', 'March', 'April', 'June']입니다.
        
        // 'March'를 제거합니다.
        months.splice(2, 1);
        // months는 이제 ['Jan', 'Feb', 'April', 'June']입니다.
        
        // 'May'를 'April' 다음에 추가하면서 'June'을 제거합니다.
        months.splice(3, 1, 'May');
        // months는 이제 ['Jan', 'Feb', 'April', 'May']입니다.
}</code></pre>
                <p>1. 'Feb'를 'Jan' 다음에 추가하기</p>
                <ul>
                    <li>1은 'Feb'를 추가할 위치를 나타냅니다. 배열은 0부터 인덱싱되므로 1은 두 번째 위치, 즉 'Jan' 다음을 의미합니다.</li>
                    <li>첫 번째 splice() 호출에서는 'Jan' 다음에 'Feb'를 추가합니다. 이를 위해 splice(1, 0, 'Feb')를 사용합니다.</li>
                    <li>0은 삭제할 요소의 개수를 나타냅니다. 여기서는 요소를 삭제하지 않고 추가만 하려고 하기 때문에 0을 사용합니다.</li>
                    <li>'Feb'는 배열에 추가할 요소입니다.</li>
                    <li>결과적으로 원본 배열 months는 ['Jan', 'Feb', 'March', 'April', 'June']가 됩니다.</li>
                </ul>
                <p>2. 'March'를 제거하기</p>
                <ul>
                    <li>두 번째 splice() 호출에서는 'March'를 제거합니다. 이를 위해 splice(2, 1)을 사용합니다.</li>
                    <li>2는 삭제할 요소의 시작 위치를 나타냅니다. 여기서는 'March'의 위치입니다.</li>
                    <li>1은 삭제할 요소의 개수입니다. 여기서는 'March' 한 개만 삭제하려고 하므로 1을 사용합니다.</li>
                    <li>이 작업 후, 원본 배열 months는 ['Jan', 'Feb', 'April', 'June']이 됩니다.</li>
                </ul>
                <p>3. 'May'를 'April' 다음에 추가하면서 'June'을 제거하기</p>
                <ul>
                    <li>세 번째 splice() 호출에서는 'April' 다음에 'May'를 추가하면서 동시에 'June'을 제거합니다. 이를 위해 splice(3, 1, 'May')를
                        사용합니다.</li>
                    <li>3은 변경을 시작할 위치를 나타냅니다. 'April' 다음이므로 'June'의 위치입니다.</li>
                    <li>1은 삭제할 요소의 개수를 나타냅니다. 여기서는 'June' 한 개를 삭제합니다.</li>
                    <li>'May'는 배열에 추가할 요소입니다. 이는 'June'이 제거된 자리에 추가됩니다.</li>
                    <li>최종적으로, 원본 배열 months는 ['Jan', 'Feb', 'April', 'May']가 됩니다.</li>
                </ul>
            </div>
            <!-- //sample30 -->
            <div id="sample31" class="sample">
                <h3>31. sort()</h3>
                <p class="notics">arr.sort([compareFunction])</p>
                <ul>
                    <li>compareFunction (선택적): 요소를 정렬하는 방식을 정의하는 함수입니다. 이 함수는 두 요소 a, b를 비교하여 그 결과에 따라 정렬 순서를 결정합니다.
                    </li>
                </ul>
                <ul>
                    <li>배열의 요소를 적절한 위치에 정렬합니다. 기본적으로 문자열로 변환 후 유니코드 코드 포인트 순서대로 정렬합니다.</li>
                    <li>정렬된 배열을 반환합니다. 중요한 점은 sort() 메서드가 원본 배열 자체를 변경한다는 것입니다.</li>
                    <li>compareFunction이 제공되지 않으면, 요소를 문자열로 변환하고 유니코드 코드 포인트의 순서에 따라 정렬합니다.</li>
                    <li>compareFunction(a, b)이 0보다 작은 값을 반환하면, a를 b보다 낮은 인덱스로 정렬합니다. 0을 반환하면, a와 b의 순서를 변경하지 않습니다. 0보다 큰
                        값을 반환하면, b를 a보다 낮은 인덱스로 정렬합니다.
                    </li>
                </ul>
                <pre class="javascript"><code>{
        const numbers1 = [10, 5, 40, 25];
        numbers.sort(); // [10, 25, 40, 5]

        const numbers2 = [4, 2, 5, 1, 3];
        // 숫자를 오름차순으로 정렬합니다.
        numbers.sort((a, b) => a - b);

        // numbers는 이제 [1, 2, 3, 4, 5]입니다.
        
        // 숫자를 내림차순으로 정렬합니다.
        numbers.sort((a, b) => b - a);
        // numbers는 이제 [5, 4, 3, 2, 1]입니다.
}</code></pre>
                <p>비교함수</p>
                <ul>
                    <li>sort() 메서드는 선택적으로 비교 함수를 인자로 받을 수 있으며, 이를 통해 정렬 순서를 사용자가 정의할 수 있습니다. 비교 함수는 두 요소(a, b)를 인자로 받고,
                        다음 규칙에 따라 반환값을 정합니다.</li>
                    <li>함수가 반환하는 값이 0보다 작으면, a를 b보다 낮은 색인으로 정렬합니다.</li>
                    <li>함수가 반환하는 값이 0이면, a와 b의 순서를 변경하지 않습니다.</li>
                    <li>함수가 반환하는 값이 0보다 크면, b를 a보다 낮은 색인으로 정렬합니다.</li>
                </ul>
                <p>1. numbers1 이 정리가 되지 순서대로 정렬되지 않은 이유?</p>
                <ul>
                    <li> sort()가 각 숫자를 문자열로 변환하고, 문자열을 사전순으로 정렬하기 때문입니다.</li>
                </ul>
                <p>2. numbers2 오름차순대로 정렬하는 방법</p>
                <ul>
                    <li>compareFunction으로 (a, b) => a - b를 사용합니다. 이는 a가 b보다 작으면 음수를, 같으면 0을, 크면 양수를 반환하여 오름차순 정렬을 수행합니다.
                    </li>
                    <li>이 함수를 sort 메서드에 전달하면, numbers 배열은 오름차순으로 정렬됩니다.</li>
                </ul>
                <p>2. numbers2 내림차순대로 정렬하는 방법</p>
                <ul>
                    <li>compareFunction으로 (a, b) => b - a를 사용합니다. 이는 b가 a보다 작으면 음수를, 같으면 0을, 크면 양수를 반환하여 내림차순 정렬을 수행합니다.
                    </li>
                    <li>이 함수를 sort 메서드에 전달하면, numbers 배열은 내림차순으로 정렬됩니다.</li>
                </ul>
            </div>
            <!-- //sample31 -->
            <div id="sample32" class="sample">
                <h3>32. toLocaleString()</h3>
                <p class="notics">array.toLocaleString(locales, options)</p>
                <ul>
                    <li>locales (선택적): 사용할 로케일의 문자열 또는 문자열의 배열. 이 매개변수를 생략하면 기본 로케일이 사용됩니다.</li>
                    <li>options (선택적): 변환에 사용할 옵션을 지정하는 객체. 숫자 형식, 날짜 형식 등에 대한 세부 설정을 지정할 수 있습니다.</li>
                </ul>
                <ul>
                    <li>배열의 각 요소를 해당 로케일의 문자열 표현으로 변환하고, 이러한 로케일에 맞는 문자열을 합쳐서 반환합니다.</li>
                    <li>이 메서드는 날짜, 숫자 등의 요소를 포함하는 배열에서 특히 유용하며, 각 요소의 toLocaleString 메서드를 호출하여 로케일에 맞는 형식으로 변환합니다.</li>
                    <li>로케일과 옵션을 지정하여 다양한 형식의 문자열 변환을 제어할 수 있습니다.</li>
                    <li>배열이 비어있는 경우 빈 문자열("")을 반환합니다.</li>
                    <li>반환된 문자열은 배열의 각 요소를 로케일에 맞는 문자열로 변환하고, 이를 쉼표로 구분하여 합친 것입니다.</li>
                </ul>
                <pre class="javascript"><code>{
        let numberArray = [1234.56, 7890.12];
        let dateString = new Date(2024, 4, 6); // 5월 6일, 주의: 월은 0부터 시작합니다.
        let mixedArray = [dateString, ...numberArray];
        
        let localeString = mixedArray.toLocaleString('ko-KR', {style: 'currency', currency: 'KRW'});
        console.log(localeString);
}</code></pre>
                <p>위 예제에서는 날짜와 숫자를 포함하는 배열을 ko-KR 로케일(한국어)로 변환하여 문자열로 출력합니다. options 객체를 통해 화폐 형식으로 숫자를 변환하도록 지정합니다. 실제
                    출력 결과는 환경 설정과 브라우저, 또는 Node.js 버전에 따라 다를 수 있지만, 대략적으로 "2024. 5. 6. ₩1,234 ₩7,890"과 같은 형태로 출력될 것입니다.
                </p>
            </div>
            <!-- //sample32 -->
            <div id="sample33" class="sample">
                <h3>33. toString()</h3>
                <p class="notics">let arrayString = array.toString()</p>
                <ul>
                    <li>arrayString: 배열의 요소들이 쉼표로 구분된 하나의 문자열.</li>
                </ul>
                <ul>
                    <li>열의 모든 요소를 하나의 문자열로 변환하고, 이 문자열을 반환하는 메서드입니다.</li>
                    <li>배열 내의 각 요소는 쉼표(,)로 구분되어 문자열로 합쳐집니다.</li>
                    <li>원본 배열에 영향을 주지 않으며, 단지 배열의 요소를 문자열 형태로 표현한 결과만을 반환합니다.</li>
                    <li>배열이 비어있는 경우 빈 문자열("")을 반환합니다.</li>
                    <li>배열 내의 null이나 undefined와 같은 값들도 빈 문자열로 변환되어 포함됩니다.</li>
                    <li>배열 요소가 객체인 경우, 각 객체는 [object Object]와 같은 형태의 문자열로 변환됩니다.</li>
                </ul>
                <pre class="javascript"><code>{
        let fruits = ['사과', '바나나', '체리'];
        let fruitsString = fruits.toString();
        
        console.log(fruitsString); // "사과,바나나,체리"
}</code></pre>
                <p>이 예시에서 fruits 배열에는 세 가지 과일 이름이 포함되어 있습니다. toString() 메서드를 사용하면, 이 배열의 모든 요소가 쉼표로 구분된 단일 문자열
                    "사과,바나나,체리"로 변환되어 fruitsString 변수에 저장됩니다.</p>
            </div>
            <!-- //sample33 -->
            <div id="sample34" class="sample">
                <h3>34. values()</h3>
                <p class="notics">const iterator = array.values()</p>
                <ul>
                    <li>iterator: 배열의 각 요소를 순회하기 위한 Iterator 객체</li>
                </ul>
                <ul>
                    <li>Array 객체에서 사용할 수 있는 메서드로, 배열의 각 요소에 대한 값을 순차적으로 반환하는 데 사용됩니다.</li>
                    <li>이 메서드는 배열의 Iterator 객체를 반환하며, 이 Iterator는 배열의 각 요소를 순회할 때 사용할 수 있습니다.</li>
                    <li>values() 메서드는 배열의 각 요소에 대한 Iterator를 반환합니다.</li>
                    <li>반환된 Iterator를 사용하여 배열의 요소를 순차적으로 접근할 수 있습니다.</li>
                    <li>for...of 루프나 Iterator의 next() 메서드를 사용하여 순회할 수 있습니다.</li>
                </ul>
                <pre class="javascript"><code>{
        const fruits = ['사과', '바나나', '체리'];
        const iterator = fruits.values();
        
        for (const value of iterator) {
            console.log(value);
        }

        //사과
        //바나나
        //체리
}</code></pre>
                <p>이 예시에서는 fruits 배열의 각 요소를 for...of 루프를 사용하여 순회하고 있습니다</p>
            </div>
            <!-- //sample34 -->
        </div>
    </main>
    <!-- //main -->

    <footer id="footer">

    </footer>
    <!-- //footer -->

    <button onclick="topFunction()" id="scrollTopBtn" title="Go to top">목록</button>
    <script src="assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>

        //목록 클릭시 해당 본문으로 이동
        document.addEventListener("DOMContentLoaded", function () {
            // 메뉴 아이템 클릭 이벤트 리스너 추가
            document.querySelectorAll('.main__menu a').forEach(item => {
                item.addEventListener('click', function (e) {
                    e.preventDefault(); // 기본 이벤트 동작 방지

                    // 클릭된 메뉴 항목에 해당하는 샘플 섹션으로 이동
                    // 메뉴 항목 텍스트에서 숫자 추출
                    const itemText = this.innerText;
                    const match = itemText.match(/\d+/); // 숫자만 추출
                    if (match) {
                        const sampleId = `sample${match[0].padStart(2, '0')}`; // ID 형식에 맞춤
                        const sampleElement = document.getElementById(sampleId);
                        if (sampleElement) {
                            sampleElement.scrollIntoView({ behavior: 'smooth' }); // 스무스 스크롤
                        }
                    }
                });
            });
        })
        // 스크롤 감지해서 버튼 표시
        window.onscroll = function () { scrollFunction() };

        function scrollFunction() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                document.getElementById("scrollTopBtn").style.display = "block";
            } else {
                document.getElementById("scrollTopBtn").style.display = "none";
            }
        }

        // 맨 위로 스크롤
        function topFunction() {
            document.body.scrollTop = 0; // 사파리 브라우저를 위함
            document.documentElement.scrollTop = 0; // 크롬, 파이어폭스, IE, 오페라
        }
    </script>
    <script>
        {
            const fruits = ['apple', 'banana', 'mango', 'orange'];

            console.log(fruits.indexOf('mango'));  // 1
            console.log(fruits.indexOf('grape'));   // -1
            console.log(fruits.indexOf('apple', 2)); // -1, 'apple'은 인덱스 2 이후에는 존재하지 않음
        }
    </script>
    <!-- //공부 -->
</body>

</html>