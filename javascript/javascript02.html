<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 :: 데이터 불러오기</title>

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/default.min.css">
    <style>
        /* 맨 위로 올라가는 스크롤 버튼 */
        #scrollTopBtn {
            position: fixed;
            bottom: 20px;
            right: 30px;
            display: none;
            font-size: 18px;
            background-color: #555;
            color: white;
            cursor: pointer;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <header id="header">
        <h1>
            <a href="index.html">javascript</a>
        </h1>
        <nav>
            <ul>
                <li><a href="javascript01.html">데이터 저장하기</a></li>
                <li class="active"><a href="javascript02.html">데이터 불러오기</a></li>
                <li><a href="javascript03.html">데이터 실행하기</a></li>
                <li><a href="javascript04.html">데이터 제어하기</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="main__menu container">
            <ul>
                <li><a href="#">01. 변수 : 데이터 불러오기</a></li>

                <li><a href="#">02. 상수 : 데이터 불러오기</a></li>

                <li><a href="#">03. 배열 : 데이터 불러오기</a></li>
                <li><a href="#">04. 배열 : 데이터 불러오기 : 갯수</a></li>
                <li><a href="#">05. 배열 : 데이터 불러오기 : for()문</a></li>
                <li><a href="#">06. 배열 : 데이터 불러오기 : forEach()</a></li>
                <li><a href="#">07. 배열 : 데이터 불러오기 : for of</a></li>
                <li><a href="#">08. 배열 : 데이터 불러오기 : for in</a></li>
                <li><a href="#">09. 배열 : 데이터 불러오기 : map()</a></li>
                <li><a href="#">10. 배열 : 데이터 불러오기 : filter()</a></li>
                <li><a href="#">11. 배열: 데이터 불러오기: 배열 구조 분해 할당</a></li>
                <li><a href="#">12. 배열: 데이터 불러오기: 배열 펼침 연산자(Spread Operator)</a></li>

                <li><a href="#">13. 객체 : 데이터 불러오기 : 기본</a></li>
                <li><a href="#">14. 객체 : 데이터 불러오기 : object.keys()</a></li>
                <li><a href="#">15. 객체 : 데이터 불러오기 : object.values()</a></li>
                <li><a href="#">16. 객체 : 데이터 불러오기 : object.entries()</a></li>
                <li><a href="#">17. 객체 : 데이터 불러오기 : object.assign()</a></li>
                <li><a href="#">18. 객체 : 데이터 불러오기 : hasOwnProperty()</a></li>
                <li><a href="#">19. 객체 : 데이터 불러오기 : for in</a></li>
                <li><a href="#">20. 객체 : 데이터 불러오기 : 객체 구조 분해 할당</a></li>
                <li><a href="#">21. 객체 : 데이터 불러오기 : 객체 펼침 연산자(Object Spread Operator)</a></li>

                <li><a href="#">22. 서버 : 데이터 불러오기 : XMLHttpRequest</a></li>
                <li><a href="#">23. 서버 : 데이터 불러오기 : fetch API</a></li>
            </ul>
        </div>
        <!-- //main__menu -->

        <div class="main__sample container">
            <div id="sample01" class="sample">
                <h3>01. 변수 : 데이터 저장</h3>
                <p>
                    변수는 데이터를 저장하는 컨테이너로, 프로그램 내에서 데이터를 참조하고 조작할 때 사용됩니다. <br />
                    avaScript에서는 var, let, const 키워드를 사용하여 변수를 선언할 수 있으며, 각각의 키워드는 변수의 스코프(유효 범위)와 재할당 가능 여부에 차이를 가집니다.
                    여기서는 let 키워드를 사용하여 변수를 선언하고 있습니다.
                </p>
                <pre><code>{
        let x = 100, y = 200, z = "javascript";

        console.log(x, y, z);
}</code></pre>
                <p>
                    *변수 선언 및 초기화* <br />
                    1. let: let 키워드는 블록 스코프(block scope)를 가지는 지역 변수를 선언할 때 사용됩니다. let으로 선언된 변수는 선언된 블록, 문장 또는 표현식 내에서
                    유효하며,
                    이를 벗어나면 해당 변수는 접근할 수 없습니다. 또한, let으로 선언된 변수는 재할당이 가능하다는 특징을 가집니다. <br />
                    2. x = 100, y = 200, z = "javascript";: 이 부분에서는 세 개의 변수 x, y, z를 선언하고 각각의 초기값으로 100, 200,
                    "javascript"를
                    할당하고 있습니다. 변수에 값을 할당할 때는 = 연산자를 사용합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->
            <div id="sample02" class="sample">
                <h3>02.상수 : 데이터 불러오기</h3>
                <p>
                    이 예시에서는 const 키워드를 사용하여 상수를 선언하고, 이들 상수에 각각 숫자와 문자열 값을 할당한 후, 이들 값을 콘솔에 출력하는 과정을 보여주고 있습니다.
                    상수는 프로그램 실행 중 값을 변경할 필요가 없는 데이터를 저장하는 데 유용하게 사용됩니다.
                </p>
                <pre><code>{
        const x = 100, y = 200, z = "javascript";

        console.log(x, y, z);
}</code></pre>
                <p>
                    const 키워드는 상수를 선언할 때 사용됩니다. 상수는 선언과 동시에 초기화(값을 할당)되어야 하며, 그 이후에는 그 값이 변경될 수 없습니다.
                    만약 상수의 값을 변경하려고 시도하면, JavaScript는 오류를 발생시킵니다. <br />
                    상수는 한 번 할당된 값이 변경되지 않는 변수를 의미합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample02 -->
            <div id="sample03" class="sample">
                <h3>03.배열 : 데이터 불러오기</h3>
                <p>
                    const 키워드를 사용하여 arr이라는 이름의 상수 배열을 선언합니다.
                    상수 배열의 경우, 배열 자체를 재할당하는 것은 불가능하지만, 배열 내의 요소를 변경하는 것은 가능합니다.
                    여기서는 배열을 재할당하지 않고, 단지 배열 내부의 데이터를 불러오기만 하므로 const를 사용하는 것이 적절합니다.
                </p>
                <pre><code>{
        const arr = [100, 200, "javascript"]

        console.log("03.배열 : 데이터 불러오기")
        console.log(arr[0], arr[1], arr[2])
}</code></pre>
                <p>
                    두 번째 console.log(arr[0], arr[1], arr[2]);는 arr 배열의 첫 번째 요소(arr[0]), 두 번째 요소(arr[1]), 세 번째
                    요소(arr[2])를 콘솔에 출력합니다.
                    배열의 인덱스는 0부터 시작하므로, arr[0]은 배열의 첫 번째 요소, arr[1]은 두 번째 요소, arr[2]는 세 번째 요소를 의미합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample03 -->
            <div id="sample04" class="sample">
                <h3>04.배열 : 데이터 불러오기: 갯수</h3>
                <p>
                    JavaScript에서 배열의 길이(즉, 배열이 포함하고 있는 요소의 총 개수)를 확인하려면 .length 속성을 사용합니다.
                    예를 들어, arr.length는 배열 arr의 길이를 반환합니다. <br />
                    아래 코드에서 arr.length는 3을 반환합니다. 이는 배열 arr이 세 개의 요소(100, 200, "javascript")를 포함하고 있기 때문입니다.
                </p>
                <pre><code>{
        const arr = [100, 200, "javascript"]

        console.log(arr.length)    //배열 안에 객체의 갯수가 총 몇개 들어있는지 확인 하는 방법
}</code></pre>
                <p>
                    *배열 안의 객체 개수 확인하기* <br />
                    배열 안에 여러 타입의 요소가 포함되어 있고, 그 중에서 객체의 개수만 확인하고 싶다면, 배열을 반복하면서 각 요소의 타입을 확인해야 합니다. <br />
                    객체를 확인하는 한 가지 방법은 typeof 연산자를 사용하는 것입니다. 그러나 typeof는 배열이나 null에 대해서도 'object'를 반환하기 때문에, 보다 정확한 방법은
                    Array.isArray() 메서드와 null 체크를 함께 사용하는 것입니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>다른 확인 방법</summary>
                        <div>
                            <pre><code>const arrMixed = [{}, {a: 1}, 100, "string", null, []];
let objectCount = 0;

arrMixed.forEach(item => {
    if (typeof item === "object" && !Array.isArray(item) && item !== null) {
    objectCount++;
    }
});

console.log(objectCount); // 배열 안의 객체 개수 출력</code></pre>
                            <p>위 코드는 배열 arrMixed 안에서 객체만을 세어서 objectCount 변수에 저장한 다음, 그 값을 출력합니다. typeof item ===
                                "object"는 요소의 타입이 객체인지 확인합니다. !Array.isArray(item)은 요소가 배열이 아닌지 확인하고, item !== null은 요소가
                                null이 아닌지 확인합니다. 이 세 조건을 모두 만족하는 요소만이 객체로 간주됩니다. <br />
                                따라서, 배열 안에 객체의 개수를 확인하려면 배열을 반복하면서 각 요소가 객체인지를 확인하는 조건을 적용해야 합니다.</p>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample04 -->
            <div id="sample05" class="sample">
                <h3>05.배열 : 데이터 불러오기: 갯수</h3>
                <p>
                    이 코드는 JavaScript에서 for 반복문을 사용하여 배열의 모든 요소를 순회하고 출력하는 예시입니다.
                    for 반복문은 특정 조건이 만족될 때까지 코드 블록을 반복 실행하며,
                    주로 배열이나 유사 배열 객체의 요소를 순회할 때 사용됩니다. for 반복문은 세 부분으로 구성되어 있습니다
                    초깃값(initialization), 조건식(condition), 그리고 증감값(increment/decrement). 각 부분은 세미콜론(;)으로 구분됩니다.
                </p>
                <pre><code>{
        const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        console.log("05.배열 : 데이터 불러오기: for ()문")

        for (let i = 0; i &lt; arr.length; i++) {
            console.log(arr[i] + "번");
        }
}</code></pre>
                <p>
                <p>*초깃값 (Initialization)* <br />
                    정의: 반복문이 시작할 때 단 한 번 설정되는 값입니다. <br />
                    예제 코드: let i = 0 <br />
                    설명: 여기서 i 변수는 반복문의 카운터로 사용되며, 0부터 시작합니다. i는 배열의 인덱스를 참조하는 데 사용되며, 배열의 첫 번째 요소부터 접근을 시작합니다. <br />
                </p>
                <p>*조건식 (Condition)* <br />
                    정의: 반복문이 실행될 조건을 정의합니다. 이 조건이 true일 때 반복문은 계속 실행됩니다. <br />
                    예제 코드: i &lt; arr.length <br />
                    설명: arr.length는 배열 arr의 전체 길이(요소의 개수)를 반환합니다. 따라서 i
                    &lt; arr.length 조건은 i가 배열의 길이보다 작을 때까지 반복문이 실행되도록 합니다. 이는 배열의 모든 요소에 접근하되, 배열의 범위를 벗어나지 않도록 보장합니다.
                    <br />
                </p>
                <p>*증감값 (Increment/Decrement)* <br />
                    정의: 반복문의 각 실행 후에 적용되는 변수의 증가 또는 감소입니다. <br />
                    예제 코드: i++ <br />
                    설명: i++는 후위 증가 연산자로, i의 값을 1만큼 증가시킵니다. 즉, 각 반복의 끝에서 i의 값이 1씩 증가하여 다음 요소의 인덱스로 이동합니다.
                </p>

                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100번<br />
                            200번 <br />
                            300번 <br />
                            400번 <br />
                            500번 <br />
                            600번 <br />
                            700번 <br />
                            800번 <br />
                            900번 <br />
                        </div>
                    </details>
                    <details>
                        <summary>코드의 실행 과정</summary>
                        <div>
                            i는 0으로 초기화됩니다. <br />
                            조건 i &lt; arr.length가 평가됩니다. 만약 i가 arr.length보다 작으면, 반복문의 코드 블록이 실행됩니다. <br />
                            console.log(arr[i])는 현재 i에 해당하는 배열 요소를 출력합니다. <br />
                            i++는 i를 1만큼 증가시킵니다. 조건 i &lt; arr.length가 다시 평가됩니다. 조건이 여전히 true이면, 과정 3으로 돌아가 반복합니다. <br />
                            i가 arr.length와 같거나 크게 되면, 조건이 false가 되고 반복문은 종료됩니다. <br />
                            이 과정을 통해 배열 arr의 모든 요소가 순차적으로 출력됩니다. </div>
                    </details>
                </div>
            </div>
            <!-- //sample05 -->
            <div id="sample06" class="sample">
                <h3>06.배열 : 데이터 불러오기: forEach() *외우기*</h3>
                <p>
                    *forEach() 메소드는 배열의 각 요소에 대해 주어진 함수를 실행하는 메소드입니다.
                    이 메소드는 배열 내의 각 요소를 순회하면서 콜백 함수를 한 번씩 실행합니다.
                    콜백 함수는 최대 세 개의 인자를 받을 수 있으며, 이는 각각 현재 요소의 값, 현재 요소의 인덱스, 그리고 순회되는 배열 자체입니다. <br />
                    *forEach() 메소드는 배열을 순회하며 각 요소에 대해 특정 작업을 수행할 때 유용하게 사용됩니다.
                    그러나 이 메소드는 순회를 중간에 멈출 수 없다는 특징이 있습니다(즉, break나 return을 사용할 수 없습니다).
                    필요한 경우, 다른 반복문이나 배열 메소드(for, for...of, map, filter 등)를 사용할 수 있습니다.

                </p>
                <pre><code>{
        const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        //01
        arr.forEach(function (element) {                      
            console.log(element);
        })
        //02
        arr.forEach(function (element, index) {
            console.log(index);
        })
        //03
        arr.forEach(function (element, index, array) {
            console.log(array);
        })
}</code></pre>
                <p>
                <p>*01 - 요소의 값 출력하기* <br />
                    이 코드는 배열의 각 요소(element)를 순회하면서 그 값을 콘솔에 출력합니다.
                </p>
                <p>*02 - 요소의 인덱스 출력하기* <br />
                    이 코드는 배열의 각 요소를 순회하면서, 요소의 인덱스(index)를 콘솔에 출력합니다.
                </p>
                <p>*03 - 배열 전체 출력하기* <br />
                    이 코드는 배열의 각 요소를 순회할 때마다 전체 배열(array)을 콘솔에 출력합니다.
                </p>
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            <p>*01 - 요소의 값 출력하기*<br />
                                100 <br />
                                200 <br />
                                300 <br />
                                400 <br />
                                500 <br />
                                600 <br />
                                700 <br />
                                800 <br />
                                900 <br /></p>
                            <p>*02 - 요소의 인덱스 출력하기* <br />
                                0 <br />
                                1 <br />
                                2 <br />
                                3 <br />
                                4 <br />
                                5 <br />
                                6 <br />
                                7 <br />
                                8</p>
                            <p>*03 - 배열 전체 출력하기* <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />

                        </div>
                    </details>
                    <details>
                        <summary>화살표 함수 표기법</summary>
                        <div>
                            <pre><code>{
        //01
        arr.forEach((e) => {
            console.log(e);
        })

        //02
        arr.forEach(e => {
            console.log(e);
        })
        //03
        arr.forEach(e => console.log(e));
                        }</code></pre>
                    </details>
                </div>
            </div>
            <!-- //sample06 -->
            <div id="sample07" class="sample">
                <h3>07.배열 : 데이터 불러오기: for of (배열)</h3>
                <p>
                    for...of 문은 반복 가능한 객체(Array, Map, Set, String 등)를 순회하며 그 값을 변수에 할당합니다.
                    배열의 경우, 각 순회에서 배열의 요소 값이 변수에 할당됩니다.
                </p>
                <pre><code>{
        const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        for (let element of arr) {
            console.log(element);
        }
}</code></pre>
                <p>
                    이 코드에서 for of 문은
                    배열 arr의 각 요소를 순회하면서, 변수 element에 배열의 요소 값을 할당하고, 그 값을 콘솔에 출력합니다.
                    두 코드 예제는 결과적으로 같은 값을 출력하지만, 이들의 사용 목적과 적용 범위가 다르므로, 상황에 맞게 적절한 반복문을 선택하여 사용하는 것이 중요합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            400 <br />
                            500 <br />
                            600 <br />
                            700 <br />
                            800 <br />
                            900 <br />
                        </div>
                    </details>
                    <details>
                        <summary>for in 문과의 차이점</summary>
                        <div>

                            *목적과 사용법: for of는 반복 가능한 객체의 값을 직접 순회하기 위한 목적으로 사용되며, for...in은 객체의 모든 열거 가능한 속성(키 또는
                            인덱스)을
                            순회하기 위해 사용됩니다. <br />
                            *배열 사용 시: for of는 배열의 각 요소의 값에 접근하는 데 사용되며, for in은 배열의 인덱스를 순회합니다. for in을 배열에 사용할
                            경우, 배열의 인덱스가 문자열로 처리되며, 배열 이외의 열거 가능한 속성도 순회할 수 있기 때문에 예상치 못한 결과를 초래할 수 있습니다. 따라서 배열을 순회할 때는
                            주로 for of를 사용하는 것이 좋습니다. <br />
                            *객체 사용 시: for in은 객체의 속성을 순회할 때 주로 사용되며, 객체의 키(속성 이름)에 접근하기에 적합합니다. for of는 직접 객체에 사용할 수 없고,
                            객체가 반복 가능한 프로토콜을 구현한 경우(예: Map, Set)에만 사용 가능합니다. </div>
                    </details>
                </div>
            </div>
            <!-- //sample07 -->
            <div id="sample08" class="sample">
                <h3>08. 배열 : 데이터 불러오기: for in (객체)</h3>
                <p>
                    for in 문은 객체의 모든 열거 가능한 속성을 순회하며, 각 속성의 키(또는 인덱스)를 변수에 할당합니다.
                    배열을 순회할 때, 인덱스가 변수에 할당되며, 객체를 순회할 때는 키가 할당됩니다.
                </p>
                <pre><code>{
        const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        for (let element in arr) {
            console.log(arr[element]);
        }
}</code></pre>
                <p>
                    이 코드에서 for in 문은 배열 arr의 인덱스를 순회하면서, 변수 element에 인덱스를 할당하고, arr[element]를 통해 해당 인덱스의 배열 요소 값을 콘솔에
                    출력합니다. <br />
                    arr안에 배열 선언 없이 element만 입력시 키값만 불러옵니다. <br />
                    ex : (0 1 2 3 ...).
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            400 <br />
                            500 <br />
                            600 <br />
                            700 <br />
                            800 <br />
                            900 <br />
                        </div>
                    </details>
                    <details>
                        <summary>for in 문과의 차이점</summary>
                        <div>

                            *목적과 사용법: for of는 반복 가능한 객체의 값을 직접 순회하기 위한 목적으로 사용되며, for...in은 객체의 모든 열거 가능한 속성(키 또는
                            인덱스)을
                            순회하기 위해 사용됩니다. <br />
                            *배열 사용 시: for of는 배열의 각 요소의 값에 접근하는 데 사용되며, for in은 배열의 인덱스를 순회합니다. for in을 배열에 사용할
                            경우, 배열의 인덱스가 문자열로 처리되며, 배열 이외의 열거 가능한 속성도 순회할 수 있기 때문에 예상치 못한 결과를 초래할 수 있습니다. 따라서 배열을 순회할 때는
                            주로 for of를 사용하는 것이 좋습니다. <br />
                            *객체 사용 시: for in은 객체의 속성을 순회할 때 주로 사용되며, 객체의 키(속성 이름)에 접근하기에 적합합니다. for of는 직접 객체에 사용할 수 없고,
                            객체가 반복 가능한 프로토콜을 구현한 경우(예: Map, Set)에만 사용 가능합니다. </div>
                    </details>
                </div>
            </div>
            <!-- //sample08 -->
            <div id="sample09" class="sample">
                <h3>09. 배열: 데이터 불러오기: map()</h3>
                <p>
                    map() 메서드는 배열의 모든 요소에 대해 주어진 함수를 호출하고, 결과를 모아 새 배열로 반환합니다.
                    map()은 호출된 배열을 변형시키지 않으며, 원본 배열과 동일한 길이의 새 배열을 생성합니다.
                    map()의 기본 구조는 다음과 같습니다 <br />
                    element: 현재 처리하고 있는 요소의 값입니다. <br />
                    index: 현재 처리하고 있는 요소의 인덱스입니다. <br />
                    array: map() 메서드가 호출된 원 배열입니다. <br />
                </p>
                <pre><code>{
        const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        //01
        arr.map(function (element) {
            console.log(element)
        });    //[100~900]  배열안에 감싸져있는 상태로 나옴
        arr.map(function (element, index) {
            console.log(index)
        });
        arr.map(function (element, index, array) {
            console.log(array)
        });
}</code></pre>
                <p>
                    *forEach() 메서드와의 차이* <br />
                    forEach() 메서드도 배열의 각 요소에 대해 주어진 함수를 실행하지만, map()과 다르게 아무것도 반환하지 않습니다(undefined를 반환).
                    즉, forEach()는 순수하게 부작용(side effect)을 목적으로 하는 경우에 사용됩니다(예: 각 요소를 출력).
                    반면, map()은 배열의 각 요소를 변형하여 새로운 배열을 만들고자 할 때 사용됩니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            400 <br />
                            500 <br />
                            600 <br />
                            700 <br />
                            800 <br />
                            900 <br />
                        </div>
                    </details>
                    <details>
                        <summary>결론</summary>
                        <div>

                            *map(): 배열의 각 요소를 변형하여 새로운 배열을 만들고자 할 때 사용. 반환값은 변형된 요소를 포함하는 새 배열입니다. <br />
                            *forEach(): 배열의 각 요소에 대해 주어진 함수를 실행할 때 사용. 반환값은 없습니다(즉, undefined).
                    </details>
                </div>
            </div>
            <!-- //sample09 -->
            <div id="sample10" class="sample">
                <h3>10. 배열: 데이터 불러오기: filter()</h3>
                <p>
                    filter() 메소드는 JavaScript에서 배열의 각 요소에 대해 주어진 함수를 실행하고,
                    그 결과가 true를 반환하는 모든 요소를 새로운 배열로 만들어 반환하는 고차함수입니다.
                    이 메소드는 원본 배열을 변경하지 않으며, 조건에 맞는 요소만을 필터링하여 새 배열을
                    생성합니다.
                <p>*사용법* <br />
                    #currentElement: 처리 중인 현재 요소입니다. <br />
                    #index (선택적): 처리 중인 현재 요소의 인덱스입니다. <br />
                    #arr (선택적): filter가 호출된 배열입니다. <br />
                    #thisValue (선택적): function을 실행할 때 this로 사용할 값입니다. <br />
                </p>
                아래 두 코드는 JavaScript의 filter() 메소드를 사용하여 배열에서 특정 조건을 만족하는 요소만을 추출하는 예시입니다.
                두 코드는 동일한 작업을 수행하지만, 함수를 정의하는 방식에서 차이가 있습니다. <br />
                </p>
                <pre><code>{
        const num = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        const arr = num.filter(function (element) {         
                        return element > 500;
                        });
        console.log(arr)     //첫번째 코드//

        const arr = num.filter(e => e > 500);
        console.log(arr)    //두번째 코드//
}</code></pre>
                <p>

                    *첫번째 코드에서는 filter() 메소드에 익명 함수를 전달합니다.
                    이 함수는 매개변수로 element를 받고, element > 500 조건을 만족하는지 평가합니다. 조건을 만족하는 경우(true), 해당 요소는 새 배열에 포함됩니다.
                    결과적으로 arr 배열은 500보다 큰 모든 요소를 포함하게 됩니다. <br />
                    *두번째 코드는 첫 번째 코드와 동일한 작업을 수행하지만, 화살표 함수(=>)를 사용하여 함수를 더 간결하게 표현합니다. 화살표 함수는 e라는 매개변수를 받고, e > 500
                    조건을
                    만족하는지 평가합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            500 <br />
                            600 <br />
                            700 <br />
                            800 <br />
                            900 <br />
                        </div>
                    </details>
                    <details>
                        <summary>특징</summary>
                        <div>
                            *불변성(Immutability): filter() 메소드는 원본 배열을 변경하지 않습니다. 조건에 맞는 요소들로 구성된 새로운 배열을 반환합니다. <br />
                            *체이닝(Chaining): filter() 메소드는 배열을 반환하기 때문에, 반환된 배열에 대해 추가적인 배열 메소드(map, reduce 등)를 체인으로 연결할
                            수
                            있습니다. <br />
                            *사용 사례: filter()는 데이터를 필터링하거나, 특정 조건을 만족하는 요소들만을 추출할 때 유용하게 사용됩니다. 예를 들어, 사용자 목록에서 특정 나이 이상의
                            사용자만을 선택하거나, 특정 조건을 만족하는 상품 목록을 생성할 때 사용할 수 있습니다. <br />
                        </div>
                </div>
            </div>
            <!-- //sample10 -->
            <div id="sample11" class="sample">
                <h3>11. 배열: 데이터 불러오기: 배열 구조 분해 할당</h3>
                <p>구조 분해 할당은 배열이나 객체의 속성을 해체하여, 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식입니다</p>
                <p>*기본 변수 할당* <br />
                    arr 배열의 각 요소를 변수 a, b, c에 순서대로 할당합니다.</p>
                <pre><code>{
        //기본 변수 할당
        const arr = [100, 200, "javascript"];
        const [a, b, c] = arr;

        console.log(a)
        console.log(b)
        console.log(c)
}</code></pre>
                <p>*선언에서 분리한 할당* <br />
                    배열의 각 요소를 직접 변수 a, b, c에 할당합니다. 이 방식은 배열 선언과 동시에 구조 분해를 사용하는 것입니다.</p>

                <pre><code>{
        //선언에서 분리한 할당
        const [a, b, c] = [100, 200, "javascript"];

        console.log(a)
        console.log(b)
        console.log(c)
}</code></pre>
                <p>*기본값 할당* <br />
                    c 변수에 기본값 "javascript"가 할당됩니다. 배열에서 세 번째 요소가 없기 때문에, 기본값이 사용됩니다.</p>
                <pre><code> {
        //기본값 할당
        const [a, b, c = "javascript"] = [100, 200,];

        console.log(a)
        console.log(b)
        console.log(c)
                }</code></pre>
                <p>*배열 일부 요소 무시* <br />
                    두 번째 요소는 무시하고, 첫 번째와 세 번째 요소만 변수 a와 c에 할당합니다.</p>
                <pre><code>{
        //배열 일부 요소 무시
        const [a, , c] = [100, 200, "javascript"]

        console.log(a)
        console.log(c)
}</code></pre>
                <p>*나머지 값 할당 (...rest 사용)* <br />
                    처음 두 요소는 각각 a, b에 할당되고, 나머지 요소들은 rest 배열에 할당됩니다.
                    여기서 ...rest는 나머지 모든 요소를 배열로 모으는 데 사용됩니다.</p>
                <pre><code>{
        //나머지 값 할당 (...rest 사용)
        const [a, b, ...rest] = [100, 200, "javascript", "jqueyr"]

        console.log(a)  //100
        console.log(b)  //200
        console.log(...rest)  // javascript jqueyr 
}</code></pre>
                <p>*변수 값 교환* <br />
                    두 변수의 값을 교환합니다. a의 값을 b에, b의 값을 a에 할당함으로써 교환을 수행합니다.</p>
                <pre><code>{
        //변수 값 교환
        let a = 100, b = 200;
        [a, b] = [b, a];

        console.log(a);
        console.log(b);
                }</code></pre>
                <p>*다차원 배열 펼침연산자* <br />
                    다차원 배열에서도 구조 분해를 사용할 수 있습니다. 여기서 a는 첫 번째 요소에, b와 c는 중첩된 배열의 첫 번째와 두 번째 요소에 각각
                    할당됩니다.</p>
                <pre><code>{
        //다차원 배열 펼침연산자

        const [a, [b, c]] = [1, [2, "javascript"]];

        console.log(a)
        console.log(b)
        console.log(c)
                }</code></pre>
                <div class="result">
                    <details>
                        <summary>11-1 ~ 11-3, 11-7결과값</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>11-4 결과값</summary>
                        <div>
                            100 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>11-5 결과값</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript jqueyr> <br />
                        </div>
                    </details>
                    <details>
                        <summary>11-6 결과값</summary>
                        <div>
                            200 <br />
                            100 <br />
                        </div>
                    </details>
                    <details>
                        <summary>추가</summary>
                        <div>
                            예제들을 통해 구조 분해 할당이 배열의 요소를 변수에 효율적으로 할당하는 데 얼마나 유용한지 알 수 있습니다.
                            또한, 구조 분해 할당은 코드를 더 간결하고 읽기 쉽게 만들어 줍니다.
                        </div>
                </div>
            </div>
            <!-- //sample11 -->
            <div id="sample12" class="sample">
                <h3>12. 배열: 데이터 불러오기: 배열 펼침 연산자(Spread Operator)</h3>
                <p>
                    배열 펼침 연산자(Spread Operator)는 ...로 표현되며, 이 연산자를 사용하면 배열이나 문자열 같은 이터러블(iterable) 객체를 요소들로 펼쳐서(분해해서) 사용할
                    수 있습니다. 이 연산자는 함수 호출 시 인자 목록을 펼치거나, 배열 리터럴 내에서 배열 요소를 펼치는 데 사용될 수 있습니다.
                    또한 객체 리터럴에서도 사용될 수 있는데, 이 경우 객체의 속성을 펼칩니다.</p>
                <p>*배열 복사* <br />
                    배열 펼침 연산자를 사용하면 배열을 쉽게 복사할 수 있습니다.
                    이 때, 얕은 복사(shallow copy)가 수행되어, 배열 내의 객체와 같은 참조형 데이터는 원본 배열과 복사된 배열 간에 공유됩니다. <br />
                    copy는 arr 배열의 모든 요소를 포함하는 새 배열입니다. console.log(copy)를 통해 확인할 수 있듯이, arr 배열과 동일한 요소를 가집니다.</p>
                <pre><code>{
        //배열 복사
        const arr = [100, 200, "javascript"];
        const copy = [...arr];

        console.log(arr)           
        console.log(...arr)        
        console.log(copy)          
}</code></pre>
                <p>*배열 합치기* <br />
                    두 개 이상의 배열을 합칠 때, 배열 펼침 연산자를 사용하면 간편하게 배열을 하나로 합칠 수 있습니다. <br />
                    merged1은 arr1과 arr2의 모든 요소를 포함하는 새 배열입니다. 또한, 배열 합치는 과정에서 추가적인 요소를 삽입할 수도 있습니다. <br />
                    merged2는 arr1의 요소, 문자열 "javascript", arr2의 요소, 그리고 문자열 "jquery"를 순서대로 포함하는 새 배열입니다.
                </p>
                <pre><code>{
        //배열 합치기
        const arr1 = [100, 200];
        const arr2 = [300, 400];
        const merged1 = [...arr1, ...arr2];
        const merged2 = [...arr1, "javascript", ...arr2, "jquery"];

        console.log(arr1.concat(arr2));        
        console.log(merged1);           
        console.log(merged2);   
}</code></pre>
                <p>*함수 인자로 사용하기* <br />
                    함수를 호출할 때, 배열 펼침 연산자를 사용하여 배열 요소를 개별 인자로 전달할 수 있습니다.
                    아래 예제에서 numbers(...nums)는 nums 배열의 각 요소를 numbers 함수의 인자 a, b, c에 순서대로 전달합니다.</p>
                <pre><code> {
        //함수 인자로 사용하기
        function numbers(a, b, c) {
            return a + b + c;
        }
        // numbers(100, 200, 300)
        const nums = [100, 200, 300];
        console.log(numbers(...nums));
}</code></pre>
                <p>*문자열 배열로 변환하기* <br />
                    문자열도 이터러블 객체이므로, 배열 펼침 연산자를 사용하여 문자열의 각 문자를 배열의 요소로 변환할 수 있으며,
                    text2는 "javascript" 문자열의 각 문자를 요소로 하는 배열입니다. console.log(text2)를 통해 각 문자가 배열의 요소로 변환된 것을 확인할 수 있습니다.
                </p>
                <pre><code>{
        //문자열 배열로 변환하기
        const text1 = "javascript";
        const text2 = [...text1];

        console.log(text1)
        console.log(text2)
}</code></pre>
                <p>배열 펼침 연산자는 이처럼 다양한 상황에서 유용하게 사용될 수 있어, JavaScript 개발에서 매우 중요한 기능 중 하나입니다.</p>

                <div class="result">
                    <details>
                        <summary>배열 복사 결과값</summary>
                        <div>
                            [100, 200, 'javascript'] <br />
                            100 200 'javascript' <br />
                            [100, 200, 'javascript'] <br />
                        </div>
                    </details>
                    <details>
                        <summary>배열 합치기 결과값</summary>
                        <div>
                            [100, 200, 300, 400] <br />
                            [100, 200, 300, 400] <br />
                            [100, 200, javascript, 300, 400, jquery] <br />
                        </div>
                    </details>
                    <details>
                        <summary>함수 인자로 사용하기</summary>
                        <div>
                            600 <br />
                        </div>
                    </details>
                    <details>
                        <summary>문자열 배열로 변환하기 결과값</summary>
                        <div>
                            javascript <br />
                            ['j', 'a', 'v', 'a', 's', 'c', 'r', 'i', 'p', 't'] <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample12 -->
            <div id="sample13" class="sample">
                <h3>13. 객체: 데이터 불러오기: 기본</h3>
                <p>
                    JavaScript에서 객체는 키와 값을 가진 속성(property)의 집합입니다.
                    객체를 사용하여 관련 데이터와 함수를 그룹화하고, 이름이 있는 속성을 통해 이러한 데이터에 접근할 수 있습니다.
                    객체의 속성에 접근하기 위해서는 점 표기법이나 대괄호 표기법을 사용할 수 있습니다.</p>
                <p>*점 표기법(Dot Notation)* <br />
                    점 표기법은 객체의 속성에 접근할 때 가장 일반적으로 사용되는 방법입니다.
                    이 방법을 사용하려면 객체 이름 뒤에 점(.)을 붙이고, 그 뒤에 속성의 이름을 작성합니다.
                </p>
                <p>*대괄호 표기법(Bracket Notation)* <br />
                    대괄호 표기법은 객체 속성에 접근할 때 속성 이름을 문자열로 지정합니다.
                    이 방법은 속성 이름이 변수에 저장되어 있거나, 유효한 변수 이름으로 사용할 수 없는 문자를 포함하고 있을 때 유용합니다.</p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }

        // console.log(obj.a)
        // console.log(obj.b)
        // console.log(obj.c)

        console.log(obj["a"])
        console.log(obj["b"])        
        console.log(obj["c"])
}</code></pre>
                <p>

                    #두 방법의 차이점# <br />
                    *점 표기법은 보다 간결하고 읽기 쉬우며, 가장 일반적인 경우에 사용됩니다.
                    하지만, 속성 이름이 유효한 JavaScript 식별자(변수 이름 규칙을 따르는)일 때만 사용할 수 있습니다.<br />
                    *대괄호 표기법은 속성 이름이 문자열로 주어질 때 사용됩니다.
                    이 방법은 속성 이름이 변수에 저장되어 있거나, 유효한 식별자가 아닌 문자를 포함하고 있을 때 필요합니다. 또한,
                    대괄호 내부에는 계산된 속성 이름을 사용할 수 있어 더 유연합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>특징</summary>
                        <div>
                            *불변성(Immutability): filter() 메소드는 원본 배열을 변경하지 않습니다. 조건에 맞는 요소들로 구성된 새로운 배열을 반환합니다. <br />
                            *체이닝(Chaining): filter() 메소드는 배열을 반환하기 때문에, 반환된 배열에 대해 추가적인 배열 메소드(map, reduce 등)를 체인으로 연결할
                            수
                            있습니다. <br />
                            *사용 사례: filter()는 데이터를 필터링하거나, 특정 조건을 만족하는 요소들만을 추출할 때 유용하게 사용됩니다. 예를 들어, 사용자 목록에서 특정 나이 이상의
                            사용자만을 선택하거나, 특정 조건을 만족하는 상품 목록을 생성할 때 사용할 수 있습니다. <br />
                        </div>
                </div>
            </div>
            <!-- //sample13 -->
            <div id="sample14" class="sample">
                <h3>14. 객체: 데이터 불러오기: object.keys()</h3>
                <p>
                    Object.keys() 메소드는 JavaScript에서 객체의 모든 열거 가능한 속성의 이름들을 배열로 반환합니다. 이 메소드는 객체가 가진 키(속성 이름)만을 추출할 때
                    유용하게 사용됩니다.
                    Object.keys()는 객체를 인자로 받고, 그 객체의 모든 열거 가능한 키를 문자열 배열로 반환합니다.
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }

        console.log(Object.keys(obj))
}</code></pre>
                <p>

                    Object.keys() 메소드는 객체의 키를 기반으로 반복 작업을 수행할 때 유용합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            ["a", "b", "c"]
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample14 -->
            <div id="sample15" class="sample">
                <h3>15. 객체: 데이터 불러오기: object.values()</h3>
                <p>
                    Object.values() 메소드는 주어진 객체의 자체 열거 가능한 속성 값들을 배열로 반환합니다.
                    이 메소드는 객체가 가진 값만을 추출할 때 유용하게 사용됩니다. <br />
                    Object.values() 메소드는 주어진 객체의 자체 열거 가능한 속성 값들을 배열로 반환합니다.
                    이 메소드는 객체가 가진 값만을 추출할 때 유용하게 사용됩니다.
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }

        console.log(Object.values(obj))
}</code></pre>
                <p>

                    결과는 obj 객체 내의 모든 값(100, 200, "javascript")을 순서대로 담은 배열을 보여줍니다.
                    이 배열을 사용하여 객체의 값에 접근하거나, 객체의 값들을 순회하는 등의 작업을 할 수 있으며 Object.values() 메소드는 객체의 값들을 기반으로 반복 작업을 수행할 때
                    유용합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            [100, 200, "javascript"]
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample15 -->
            <div id="sample16" class="sample">
                <h3>16. 객체: 데이터 불러오기: object.entries()</h3>
                <p>
                    Object.entries() 메소드는 객체의 자체 열거 가능한 속성 [키, 값] 쌍의 배열을 반환합니다.
                    이 메소드는 객체의 속성을 순회하면서, 각 속성의 키와 값을 배열로
                    만들고, 그 배열들을 하나의 배열에 담아 반환합니다. 이 때 반환되는 배열의 순서는 객체의 속성 정의 순서를 따릅니다.
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }

        console.log(Object.entries(obj))
}</code></pre>
                <p>
                    Object.entries() 메소드는 객체의 속성을 순회하거나, 객체를 배열 형태로 변환하여 사용할 때 매우 유용합니다.
                    예를 들어, 객체의 각 속성에 대한 작업을 수행하고 싶다면, 다음과 같이 할 수 있습니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            ["a", 100], ["b", 200], ["c", "javascript"]
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample16 -->
            <div id="sample17" class="sample">
                <h3>17. 객체: 데이터 불러오기: object.assign()</h3>
                <p>
                    Object.assign() 메소드는 여러 소스 객체들의 열거 가능한 모든 속성을 타겟 객체에 복사하는 데 사용됩니다.
                    이 메소드의 첫 번째 인자는 타겟 객체이며, 이후 인자들은 하나 혹은 그 이상의 소스 객체들입니다. Object.assign()은 타겟 객체를 반환합니다.
                    소스 객체들의 속성이 타겟 객체에 복사되기 때문에, 타겟 객체는 이 메소드 호출 후 수정됩니다. <br />
                    코드에서는 obj1과 obj2 두 개의 객체가 있고, 이 두 객체를 Object.assign()을 사용하여 obj1에 병합하고 있습니다
                </p>
                <pre><code>{
        const obj1 = {
            a: 100,
            b: 200,
        }
        const obj2 = {
            c: 300,
            d: 400,
        }
        const obj3 = Object.assign(obj1, obj2)

        console.log(obj3)
}</code></pre>
                <p>
                    1. Object.assign(obj1, obj2) 호출* <br />

                    이 호출은 obj2의 모든 열거 가능한 속성들(c, d)을 obj1에 복사합니다.
                    복사 후 obj1은 수정되어 a, b, 그리고 새로 추가된 c, d 속성을 가지게 됩니다. <br />
                    2. 결과값 <br />
                    Object.assign() 메소드는 타겟 객체인 obj1을 수정한 후, 이 타겟 객체를 반환합니다.
                    따라서 obj3는 obj1에 대한 참조가 됩니다. 소스 객체 obj2는 변하지 않습니다.
                    console.log(obj3)를 실행하면, 병합된 객체가 출력됩니다

                    3. 타겟 객체(obj1)의 변화 <br />
                    Object.assign()은 타겟 객체를 직접 수정합니다. 따라서, obj3 뿐만 아니라 obj1 역시 같은 객체를 참조하고 있으므로, obj1도 동일한 변화를 겪습니다.
                    console.log(obj1)를 추가로 호출하면, obj3와 동일한 결과를 볼 수 있습니다:<br />
                    <br />
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            ["a", 100], ["b", 200], ["c", "javascript"]
                        </div>
                    </details>
                    <details>
                        <summary>정리</summary>
                        <div>
                            Object.assign() 메소드는 객체들을 병합하는 간편한 방법을 제공합니다.
                            이 메소드는 타겟 객체 자체를 수정하며, 수정된 타겟 객체를 반환합니다.
                            이런 특성 때문에 원본 객체를 변경하지 않고 새 객체를 생성하려면, 첫 번째 인자로 빈 객체 {}를 사용하는 것이 좋습니다.
                            예를 들어, const newObj = Object.assign({}, obj1, obj2);와 같이 사용할 수 있습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample17 -->
            <div id="sample18" class="sample">
                <h3>18. 객체: 데이터 불러오기: hasOwnProperty()</h3>
                <p>
                    hasOwnProperty() 메소드는 JavaScript에서 객체가 특정 속성을 직접 소유하고 있는지를 판단하는 데 사용됩니다.
                    이 메소드는 객체의 프로토타입 체인을 확인하지 않고, 오직 객체 자체에 해당 속성이 존재하는지만을 검사합니다.
                    만약 객체가 해당 속성을 소유하고 있으면 true를, 그렇지 않으면 false를 반환합니다.
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }

        console.log(obj.hasOwnProperty("a"));      //true
        console.log(obj.hasOwnProperty("b"));      //true
        console.log(obj.hasOwnProperty("c"));      //true
        console.log(obj.hasOwnProperty("d"));      //false

        //in연산자 (최신 방식)
        console.log("a" in obj)         //true
        console.log("b" in obj)         //true
        console.log("c" in obj)         //true
        console.log("d" in obj)         //false
}</code></pre>
                <p>
                    위 코드에서 객체 obj는 a, b, c 세 개의 속성을 가지고 있습니다. <br />
                    obj.hasOwnProperty("a"), obj.hasOwnProperty("b"), obj.hasOwnProperty("c")는 각각 true를 반환합니다. <br />
                    이는 obj 객체가 a, b, c 속성을 직접 소유하고 있음을 의미합니다. <br />
                    반면, obj.hasOwnProperty("d")는 false를 반환합니다. obj 객체는 d 속성을 소유하고 있지 않기 때문입니다. <br />
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            //true <br />
                            //true <br />
                            //true <br />
                            //false <br />
                        </div>
                    </details>
                    <details>
                        <summary>정리</summary>
                        <div>
                            hasOwnProperty() 메소드는 객체가 특정 속성을 직접 소유하고 있는지 여부를 확인하는 데 사용됩니다. <br />
                            in 연산자는 객체가 특정 속성을 소유하고 있거나 해당 속성이 객체의 프로토타입 체인 상에 존재하는 경우 true를 반환합니다. <br />
                            주어진 코드의 예상 결과는 hasOwnProperty()를 사용할 때와 in 연산자를 사용할 때 모두 d 속성에 대해 false를 반환하는 것이 정확합니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample18 -->
            <div id="sample19" class="sample">
                <h3>19. 객체: 데이터 불러오기: for in (객체로 불러옴)</h3>
                <p>
                    for in 문은 객체의 속성 이름들을 통해 반복 작업을 수행하며,
                    for in 루프는 객체의 모든 열거 가능한 속성들을 순회하는 데 사용됩니다. <br />
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }
        for (let e in obj) {
            console.log(e + ":" + obj[e])
        }
}</code></pre>
                <p>
                    *코드 설명* <br />

                    const obj = { a: 100, b: 200, c: "javascript" }: 여기서 obj는 세 개의 속성을 가진 객체입니다.
                    a와 b는 숫자 값을 가지며, c는 문자열 값을 가집니다. <br />
                    for (let e in obj) { ... }: 이 루프는 obj 객체의 모든 속성을 순회합니다.
                    각 반복에서 변수 e는 현재 속성의 키(속성 이름)를 나타냅니다. <br />
                    console.log(e + ":" + obj[e]): 각 속성의 키와 해당하는 값을 콘솔에 출력합니다.
                    여기서 obj[e]는 키 e에 해당하는 객체의 속성 값을 나타냅니다.
                    <br />
                    각 줄은 객체 obj의 각 속성을 나타냅니다.
                    for in 루프를 통해 객체의 모든 속성이 순회되며, 속성의 키와 값이 콜론(:)으로 구분되어 출력됩니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            a:100 <br />
                            b:200 <br />
                            c:javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>정리</summary>
                        <div>
                            for...in 루프는 객체의 속성을 탐색하고 작업을 수행할 때 유용합니다.
                            하지만, 객체의 프로토타입 체인(prototype chain)을 통해 상속된 속성들도 열거될 수 있기 때문에,
                            때로는 객체가 직접 소유한 속성인지를 확인하기 위해 Object.hasOwnProperty() 메소드를 함께 사용하는 것이 좋습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample19 -->
            <div id="sample20" class="sample">
                <h3>20. 객체 : 데이터 불러오기 : 객체 구조 분해 할당</h3>
                <p>
                    객체의 구조 분해 할당(또는 객체 비구조화 할당)은 객체 내의 속성들을 변수로 쉽게 추출할 수 있는 JavaScript의 편리한 기능이며,
                    이 기능을 사용하면 객체의 속성을 개별 변수로 할당할 수 있으며, 코드를 더 간결하고 읽기 쉽게 만들 수 있습니다.
                    아래 코드 블록들을 통해 이 기능의 다양한 사용 방법을 설명하겠습니다.</p>
                <p>*기본 사용법* <br />
                    이 코드에서는 객체 obj에서 속성 a, b, c를 직접 변수 a, b, c에 할당합니다. 이렇게 하면 각 변수는 객체의 해당 속성 값으로 초기화됩니다.</p>
                <pre><code>{
        //기본 사용법
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        };

        const { a, b, c } = obj;

        console.log(a)
        console.log(b)
        console.log(c)
}</code></pre>
                <p>*기본 값 할당* <br />
                    여기서는 속성 c가 객체 obj에 존재하지 않기 때문에, 구조 분해 할당 시 변수 c에 기본값 "javascript"가 할당됩니다.
                    이렇게 기본값을 지정함으로써, 속성이 객체에 없을 경우에도 변수에 기본값을 할당할 수 있습니다.</p>
                <pre><code>{
        //기본 값 할당
        const obj = {
            a: 100,
            b: 200,
        };
        const { a, b, c = "javascript" } = obj
        console.log(a)
        console.log(b)
        console.log(c)
}</code></pre>
                <p>*새로운 이름으로 변경* <br />
                    아래 예제에서는 객체 obj의 속성들을 다른 이름의 변수에 할당합니다.
                    예를 들어, 속성 a는 변수 x에, b는 y에, c는 z에 할당됩니다. 이 방법을 통해 원하는 변수 이름으로 속성 값을 할당할 수 있습니다.</p>
                <pre><code> {
        //새로운 이름으로 변경
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }
        const { a: x, b: y, c: z } = obj;

        console.log(x)
        console.log(y)
        console.log(z)
}</code></pre>
                <p>*중첩된 객체의 구조 분해 할당* <br />
                    이 코드는 중첩된 객체에서도 구조 분해 할당을 사용할 수 있음을 보여줍니다.
                    객체 obj의 속성 b는 또 다른 객체를 값으로 가지고 있으며, 이 내부 객체의 속성 c와 d를 직접 변수 c와 d에 할당합니다.
                    이렇게 하면 중첩된 객체의 속성도 쉽게 추출할 수 있습니다.</p>
                <pre><code>{
        //중첩된 객체의 구조 분해 할당
        const obj = {
            a: 100,
            b: { c: 200, d: "javascript" },
        }
        const { a, b: { c, d } } = obj
        console.log(a);
        console.log(c);
        console.log(d);
}</code></pre>
                <p>객체의 구조 분해 할당은 코드를 더 깔끔하게 만들고, 속성 값에 쉽게 접근할 수 있게 해주는 유용한 기능입니다.</p>

                <div class="result">
                    <details>
                        <summary>기본 사용법</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript
                        </div>
                    </details>
                    <details>
                        <summary>기본 값 할당</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript
                        </div>
                    </details>
                    <details>
                        <summary>새로운 이름으로 변경</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript
                        </div>
                    </details>
                    <details>
                        <summary>중첩된 객체의 구조 분해 할당</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample20 -->
            <div id="sample21" class="sample">
                <h3>21. 객체: 데이터 불러오기: 객체 펼침 연산자(Object Spread Operator)</h3>
                <p>
                    객체 펼침 연산자는 ES2018(ECMAScript 2018)에서 도입된 문법으로, 한 객체 내의 모든 열거 가능한 속성을 다른 객체 리터럴로 복사할 때 사용됩니다. <br />
                </p>
                <p>*객체 펼침 연산자 사용법* <br />
                    객체 펼침 연산자는 ... 기호를 사용합니다.
                    이를 통해 기존 객체의 모든 속성을 새 객체에 복사하거나, 두 객체를 병합할 수 있습니다. 또한, 새 속성을 추가하거나 기존 속성을 덮어쓸 때도 사용할 수 있습니다.

                </p>
                <pre><code>{
        const obj1 = { a: 100, b: 200, }
        const obj2 = { c: 300, d: 400, }
        const merge1 = { ...obj1, ...obj2 }
        const merge2 = { ...obj1, x: "javascript", ...obj2, y: "jquery" }

        console.log(obj1); 
        console.log(merge1);
        console.log(merge2);
}</code></pre>
                <p>
                    *코드 분석* <br />

                    1. merge1은 obj1과 obj2의 속성을 모두 포함하는 새 객체를 생성합니다. 결과적으로 { a: 100, b: 200, c: 300, d: 400 }의 형태를 가집니다.
                    <br />
                    2. merge2는 obj1의 속성을 기반으로 새 속성 x를 추가하고, obj2의 속성을 추가한 후, 마지막으로 새 속성 y를 추가하여 새 객체를 생성합니다.
                    최종적으로 { a: 100, b: 200, x: "javascript", c: 300, d: 400, y: "jquery" }의 형태를 가집니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            { a: 100, b: 200, } <br />
                            { a: 100, b: 200, c: 300, d: 400,} <br />
                            { a: 100, b: 200, javascript, c: 300, d: 400, jquery} <br />
                        </div>
                    </details>
                    <details>
                        <summary>정리</summary>
                        <div>
                            위의 코드를 통해 객체 펼침 연산자를 사용하여 기존 객체의 속성을 새 객체로 쉽게 복사하거나,
                            여러 객체를 하나로 병합하고, 새 속성을 추가할 수 있음을 알 수 있습니다.
                            이는 코드의 재사용성과 가독성을 높이는 데 유용한 기능입니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample21 -->
            <div id="sample22" class="sample">
                <h3>22. 서버: 데이터 불러오기: XMLHttpRequest</h3>
                <p>
                    아래 코드는 XMLHttpRequest 객체를 사용하여 서버로부터 데이터를 비동기적으로 불러오는 기본적인 예시입니다.
                    XMLHttpRequest는 웹 애플리케이션에서 HTTP를 통해 데이터를 주고받기 위해 사용되는 JavaScript의 객체입니다.
                    이를 통해 페이지 전체를 새로고침하지 않고도 서버로부터 데이터를 받아올 수 있어, 사용자 경험을 크게 향상시킵니다. <br />
                </p>
                <p>*XMLHttpRequest 객체의 주요 특징 및 메소드* <br />
                <p>1. open(method, url, async): 요청을 초기화합니다. method는 HTTP 요청 방식 (GET, POST 등),
                    url은 요청을 보낼 서버의 주소, async는 비동기적으로 요청할지 여부를 나타내며, 보통 true로 설정하여 비동기적으로 처리합니다. <br /></p>
                <p>2. onreadystatechange 이벤트 핸들러: XMLHttpRequest 객체의 readyState 속성 값이 변경될 때마다 호출됩니다.
                    이를 통해 서버 응답의 상태를 감지하고 처리할 수 있습니다. <br /></p>
                <p>3. readyState: 요청의 현재 상태를 나타내는 속성입니다. 0부터 4까지의 값을 가지며, 각각 요청이 초기화되지 않음,
                    서버 연결 설정됨, 요청 받음, 요청 처리 중, 요청 완료 및 응답 준비 완료 상태를 나타냅니다. <br /></p>
                <p>4. status: HTTP 응답 코드를 나타냅니다. 예를 들어, 200은 성공, 404는 찾을 수 없음 등을 의미합니다. <br /></p>
                <p>5. responseText 또는 responseXML: 서버로부터 응답받은 데이터를 문자열 또는 XML 문서 형태로 제공합니다.
                    JSON 형태의 데이터를 받았을 경우 JSON.parse() 메소드를 사용해 이를 JavaScript 객체로 변환할 수 있습니다. <br /></p>
                <p>6. send(): 실제로 서버로 요청을 보내는 메소드입니다. <br /></p>

                </p>
                <pre><code>{
        var xhr = new XMLHttpRequest();
        xhr.open("GET", "https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json", true);

        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                var responseData = xhr.responseText;
                var jsonData = JSON.parse(responseData);

                console.log(jsonData);
            } else if (xhr.readyState === 4) {
                console.error("데이터 불러오기 오류: " + xhr.status);
            }
        };

        xhr.send();
}</code></pre>
                <p>
                    *코드 분석* <br />

                    1. XMLHttpRequest 객체를 생성합니다.<br />
                    2. open() 메소드를 사용하여 HTTP GET 요청을 초기화합니다. 요청할 URL과 비동기적(true)으로 처리될 것임을 지정합니다.<br />
                    3. onreadystatechange 이벤트 핸들러를 설정합니다.
                    이 핸들러 내에서 readyState가 4(요청 완료 및 응답 준비 완료)이고 status가 200(성공)일 때, 응답받은 데이터(responseText)를 JSON 형태로
                    파싱하여 콘솔에 출력합니다.
                    만약 요청이 완료되었으나 다른 상태 코드를 받았다면, 오류 메시지를 콘솔에 출력합니다.<br />
                    4. send() 메소드를 호출하여 서버로 요청을 보냅니다.<br />
                </p>
                <div class="result">
                    <details>
                        <summary>정리</summary>
                        <div>
                            이 코드는 비동기적으로 서버로부터 JSON 데이터를 불러와 처리하는 간단한 예시를 보여줍니다.
                            이러한 방식은 웹 애플리케이션에서 동적인 데이터 처리를 위해 널리 사용됩니다.
                            그러나 현대 웹 개발에서는 XMLHttpRequest 대신 더 간결하고 현대적인 fetch API나 다양한 HTTP 클라이언트 라이브러리(예: Axios)를 사용하는
                            경향이 있습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample22 -->
            <div id="sample23" class="sample">
                <h3>23. 서버: 데이터 불러오기: fetch API</h3>
                <p>
                    fetch API는 JavaScript에서 서버로부터 리소스를 비동기적으로 가져오는 데 사용됩니다.
                    이는 Promise를 기반으로 하여, 네트워크 요청이 완료될 때까지 기다리지 않고 즉시 제어를 반환하며,
                    요청이 성공하거나 실패했을 때의 처리는 .then()과 .catch() 메소드를 사용하여 핸들링합니다.
                    fetch API는 현대 웹 개발에서 서버와의 비동기 통신을 구현하는 중요한 도구 중 하나입니다.<br />
                </p>
                <p>!기본 구조! <br />
                <p>* url: 리소스를 가져오고자 하는 URL입니다. <br />
                    * .then(): Promise가 성공적으로 완료되었을 때 실행될 콜백 함수를 등록합니다. 첫 번째 .then()은 응답(Response) 객체를 받고,
                    이 객체를 사용하여 응답의 본문을 실제 데이터로 변환합니다. <br />
                    * .catch(): 요청이 실패하거나 네트워크 문제가 발생했을 때 실행될 콜백 함수를 등록합니다.</p>
                <pre><code>{
        fetch("https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json")
        .then(Response => {
            return Response.json();
        })
        .then(data => {
            console.log(data);
        })
        .catch(error => {
            console.error("데이터 불러오기 오류", error);
        })
}</code></pre>
                <p>
                    *예제 설명* <br />

                    1. fetch() 함수가 "https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json" URL로 요청을
                    보냅니다.<br />
                    2. 서버로부터 응답이 돌아오면, 첫 번째 .then() 메소드가 실행됩니다. Response 객체의 .json() 메소드를 호출하여, 응답 본문을 JSON으로 파싱합니다.
                    .json() 메소드 또한 Promise를 반환하므로, 결과를 처리하기 위해 다음 .then()을 체인할 수 있습니다.<br />
                    3. JSON으로 변환된 데이터는 두 번째 .then() 메소드의 data 파라미터를 통해 접근할 수 있습니다. 여기서 받은 데이터를 콘솔에 출력합니다.<br />
                    4. 만약 요청이 실패하거나 네트워크 에러 등 어떤 이유로든 Promise가 거부(rejected)되면, .catch() 메소드가 실행되어 에러를 콘솔에 출력합니다.<br />
                </p>
                <div class="result">
                    <details>
                        <summary>주의 사항</summary>
                        <div>
                            * fetch API는 CORS(Cross-Origin Resource Sharing) 정책을 따릅니다.
                            따라서 다른 도메인의 리소스를 요청하는 경우, 서버 측에서 적절한 CORS 헤더를 설정해야 합니다. <br />
                            * fetch는 기본적으로 GET 요청을 보냅니다. POST, PUT, DELETE 등 다른 HTTP 메소드를 사용하려면 fetch의 두 번째 인자로 요청 옵션을
                            포함해야 합니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample23 -->
    </main>
    <!-- //main -->

    <footer id="footer">

    </footer>
    <!-- //footer -->

    <button onclick="topFunction()" id="scrollTopBtn" title="Go to top">목록</button>
    <script src="assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>
        //01.변수 : 데이터 불러오기
        {
            let a = 1, b = 2, c = "j";

            console.log("01.변수 : 데이터 불러오기");
            console.log(a, b, c);
        }
        //02.상수 : 데이터 불러오기
        {
            const x = 100, y = 200, z = "javascript";

            console.log("02.상수 : 데이터 불러오기");
            console.log(x, y, z);
        }
        //03.배열 : 데이터 불러오기
        {
            const arr = [100, 200, "javascript"]

            console.log("03.배열 : 데이터 불러오기")
            console.log(arr[0], arr[1], arr[2])
        }
        //04.배열 : 데이터 불러오기: 갯수
        {
            const arr = [100, 200, "javascript"]

            console.log("04.배열 : 데이터 불러오기: 갯수")
            console.log(arr.length)    //배열 안에 객체의 갯수가 총 몇개 들어있는지 확인 하는 방법
        }
        //05.배열 : 데이터 불러오기: for ()문    *외우기*
        {
            const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

            console.log("05.배열 : 데이터 불러오기: for ()문")

            for (let i = 0; i < arr.length; i++) {
                console.log(arr[i] + "번");
            }
        }
        //06.배열 : 데이터 불러오기: forEach()  *외우기*
        {
            const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

            console.log("06.배열 : 데이터 불러오기: forEach()")

            arr.forEach(function (element, index, array) {
                console.log(element);
            })

            //화살표 함수
            //01
            // arr.forEach((e) => {
            //     console.log(e);
            // })

            // //02
            // arr.forEach(e => {
            //     console.log(e);
            // })
            // //03
            // arr.forEach(e => console.log(e));
        }
        //07.배열 : 데이터 불러오기: for of (배열)
        {
            const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

            console.log("07.배열 : 데이터 불러오기: for of")
            for (let element of arr) {
                console.log(element);
            }
        }
        //08. 배열 : 데이터 불러오기: for in (객체)      //arr안에 배열 선언 없이 element만 입력시 키값만 불러옴(0 1 2 3 ...)
        {
            const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

            console.log("08. 배열 : 데이터 불러오기: for in");
            for (let element in arr) {
                console.log(arr[element]);
            }
        }
        //09. 배열: 데이터 불러오기: map()
        {
            //     const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];
            //     //01
            //     console.log("09. 배열: 데이터 불러오기: map()");
            //     arr.map(function (element) {
            //         console.log(element)
            //     });    //[100~900]  배열안에 감싸져있는 상태로 나옴
            //     arr.map(function (element, index) {
            //         console.log(index)
            //     });
            //     arr.map(function (element, index, array) {
            //         console.log(array)
            //     });

        }
        //10. 배열: 데이터 불러오기: filter()
        {
            const num = [100, 200, 300, 400, 500, 600, 700, 800, 900];
            console.log("10. 배열: 데이터 불러오기: filter()");

            // num.filter(function (element) {
            //     console.log(element)
            // })
            // num.filter(function (element, index) {       //안의 객체 수를 표시함
            //     console.log(index)
            // })
            // num.filter(function (element, index, array) {     //결과값을 배열 안에 있는 객체 수만큼 반복해서 표시함
            //     console.log(array)
            // })

            // const arr = num.filter(function (element) {         //실제로 쓰이는 방법
            //     return element > 500;
            // });
            // console.log(arr)

            // const arr = num.filter((element) => {       
            //     return element > 500;
            // });
            // console.log(arr)

            // const arr = num.filter(element => {        
            //     return element > 500;
            // });
            // console.log(arr)
            const arr = num.filter(e => e > 500);
            console.log(arr)
        }
        //11. 배열: 데이터 불러오기: 배열 구조 분해 할당
        {
            //기본 변수 할당
            const arr = [100, 200, "javascript"];
            const [a, b, c] = arr;

            console.log("11-1. 배열: 데이터 불러오기: 배열 펼침연산자");
            console.log(a)
            console.log(b)
            console.log(c)
        }
        {
            //선언에서 분리한 할당
            const [a, b, c] = [100, 200, "javascript"];

            console.log("11-2. 배열: 데이터 불러오기: 배열 펼침연산자");
            console.log(a)
            console.log(b)
            console.log(c)
        }
        {
            const [a, b, c = "javascript"] = [100, 200,];

            console.log("11-3. 배열: 데이터 불러오기: 배열 펼침연산자");
            console.log(a)
            console.log(b)
            console.log(c)
        }
        {
            //배열 이부 요소 무시
            const [a, , c] = [100, 200, "javascript"]

            console.log("11-4. 배열: 데이터 불러오기: 배열 펼침연산자");
            console.log(a)
            console.log(c)
        }
        {
            //나머지 값 할당
            const [a, b, ...rest] = [100, 200, "javascript", "jqueyr"]

            console.log("11-5. 배열: 데이터 불러오기: 배열 펼침연산자");
            console.log(a)  //100
            console.log(b)  //200
            console.log(...rest)  // javascript jqueyr 
        }
        {
            //변수 값 교환
            let a = 100, b = 200;
            [a, b] = [b, a];

            console.log("11-6. 배열: 데이터 불러오기: 배열 펼침연산자");
            console.log(a);
            console.log(b);
        }
        {
            //다차원 배열 펼침연산자

            const [a, [b, c]] = [1, [2, "javascript"]];

            console.log("11-7. 배열: 데이터 불러오기: 배열 펼침연산자");
            console.log(a)
            console.log(b)
            console.log(c)
        }
        //12. 배열: 데이터 불러오기: 배열 펼침 연산자(Spread Operator)
        {
            //배열 복사
            const arr = [100, 200, "javascript"];
            const copy = [...arr];


            console.log("12-1. 배열 복사");
            console.log(arr)           //[100, 200, "javascript"]
            console.log(...arr)        //100, 200, "javascript"
            console.log(copy)          //[100, 200, "javascript"]
        }
        {
            //배열 합치기
            const arr1 = [100, 200];
            const arr2 = [300, 400];
            const merged1 = [...arr1, ...arr2];
            const merged2 = [...arr1, "javascript", ...arr2, "jquery"];

            console.log("12-2. 배열 합치기")
            console.log(arr1.concat(arr2));        // [100, 200, 300, 400]
            console.log(merged1);            //[100, 200, 300, 400]
            console.log(merged2);    //[100, 200, 'javascript', 300, 400, 'jquery']

        }
        {
            //함수 인자로 사용하기
            console.log("12-3. 함수 인자로 사용하기")
            function numbers(a, b, c) {
                return a + b + c;
            }
            // numbers(100, 200, 300)
            const nums = [100, 200, 300];
            console.log(numbers(...nums));
        }
        {
            //문자열 배열로 변환하기
            const text1 = "javascript";
            const text2 = [...text1];

            console.log("12-4. 문자열 배열로 변환하기")
            console.log(text1)
            console.log(text2)

        }
        //13. 객체: 데이터 불러오기: 기본
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log("13. 객체: 데이터 불러오기: 기본")
            // console.log(obj.a)
            // console.log(obj.b)
            // console.log(obj.c)

            console.log(obj["a"])
            console.log(obj["b"])           //obj의 특징
            console.log(obj["c"])
        }
        //14. 객체: 데이터 불러오기: object.keys()    [배열 안으로 들어옴]
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log("14. 객체: 데이터 불러오기: object.keys()")
            console.log(Object.keys(obj));
            console.log(Object.keys(obj)[0]);
            console.log(Object.keys(obj)[1]);
            console.log(Object.keys(obj)[2]);
        }
        //15. 객체: 데이터 불러오기: object.values()
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log("15. 객체: 데이터 불러오기: object.values()")
            console.log(Object.values(obj))
        }
        //16. 객체: 데이터 불러오기: object.entries()
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log("16. 객체: 데이터 불러오기: object.entries()")
            console.log(Object.entries(obj))  //["a", 100], ["b", 200], ["c", "javascript"]
        }
        //17. 객체: 데이터 불러오기: object.assign()
        {
            const obj1 = {
                a: 100,
                b: 200,
            }
            const obj2 = {
                c: 300,
                d: 400,
            }
            const obj3 = Object.assign(obj1, obj2)

            console.log("17. 객체: 데이터 불러오기: object.assign()")
            console.log(obj3)
        }
        //18. 객체: 데이터 불러오기: hasOwnProperty()
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log("18. 객체: 데이터 불러오기: hasOwnProperty()")
            console.log(obj.hasOwnProperty("a"));      //true
            console.log(obj.hasOwnProperty("b"));      //true
            console.log(obj.hasOwnProperty("c"));      //true
            console.log(obj.hasOwnProperty("d"));      //false

            //in연산자 (최신 방식)
            console.log("a" in obj)         //true
            console.log("b" in obj)         //true
            console.log("c" in obj)         //true
            console.log("d" in obj)         //false
        }
        //19. 객체: 데이터 불러오기: for in   (객체로 불러옴)
        {
            console.log("19. 객체: 데이터 불러오기: for in   (객체로 불러옴)")
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }
            for (let e in obj) {
                console.log(e + ":" + obj[e])
            }
        }
        //20. 객체: 데이터 불러오기: 배열 구조 분해 할당
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            };

            const { a, b, c } = obj;

            console.log("20-1. 객체: 데이터 불러오기: 배열 구조 분해 할당")
            console.log(a)
            console.log(b)
            console.log(c)
        }
        {
            //기본 값 할당
            const obj = {
                a: 100,
                b: 200,
            };
            const { a, b, c = "javascript" } = obj
            console.log("20-2. 기본 값 할당")
            console.log(a)
            console.log(b)
            console.log(c)
        }
        {
            //새로운 이름으로 변경
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }
            const { a: x, b: y, c: z } = obj;

            console.log("20-3. 새로운 이름으로 변경")
            console.log(x)
            console.log(y)
            console.log(z)
        }
        {
            const obj = {
                a: 100,
                b: { c: 200, d: "javascript" },
            }
            const { a, b: { c, d } } = obj
            console.log("20-4. 객체: 데이터 불러오기: 배열 구조 분해 할당")
            console.log(a);
            console.log(c);
            console.log(d);
        }
        //21. 객체: 데이터 불러오기: 객체 펼침 연산자(Object Spread Operator)
        {
            const obj1 = { a: 100, b: 200, }
            const obj2 = { c: 300, d: 400, }
            const merge1 = { ...obj1, ...obj2 }
            const merge2 = { ...obj1, x: "javascript", ...obj2, y: "jquery" }

            console.log("21. 객체: 데이터 불러오기: 배열 펼침연산자");
            console.log(obj1);  // { a: 100, b: 200 }
            console.log(merge1); // { a: 100, b: 200, c: 300, d: 400 }
            console.log(merge2); // { a: 100, b: 200, x: "javascript", c: 300, d: 400, y: "jquery"}
        }
        //22. 서버: 데이터 불러오기: XMLHttpRequest
        {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", "https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json", true);

            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4 && xhr.status === 200) {
                    var responseData = xhr.responseText;
                    var jsonData = JSON.parse(responseData);

                    console.log(jsonData);
                } else if (xhr.readyState === 4) {
                    console.error("데이터 불러오기 오류: " + xhr.status);
                }
            };

            xhr.send();
        }
        //23. 서버: 데이터 불러오기: fetch API
        {
            fetch("https://webstoryboy.github.io/webs2024/json/gineungsaJC2011_05.json")
                .then(Response => {
                    return Response.json();
                })
                .then(data => {
                    console.log(data);
                })
                .catch(error => {
                    console.error("데이터 불러오기 오류", error);
                })
        }


        //목록 클릭시 해당 본문으로 이동
        document.addEventListener("DOMContentLoaded", function () {
            // 메뉴 아이템 클릭 이벤트 리스너 추가
            document.querySelectorAll('.main__menu a').forEach(item => {
                item.addEventListener('click', function (e) {
                    e.preventDefault(); // 기본 이벤트 동작 방지

                    // 클릭된 메뉴 항목에 해당하는 샘플 섹션으로 이동
                    // 메뉴 항목 텍스트에서 숫자 추출
                    const itemText = this.innerText;
                    const match = itemText.match(/\d+/); // 숫자만 추출
                    if (match) {
                        const sampleId = `sample${match[0].padStart(2, '0')}`; // ID 형식에 맞춤
                        const sampleElement = document.getElementById(sampleId);
                        if (sampleElement) {
                            sampleElement.scrollIntoView({ behavior: 'smooth' }); // 스무스 스크롤
                        }
                    }
                });
            });
        })

        // 스크롤 감지해서 버튼 표시
        window.onscroll = function () { scrollFunction() };

        function scrollFunction() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                document.getElementById("scrollTopBtn").style.display = "block";
            } else {
                document.getElementById("scrollTopBtn").style.display = "none";
            }
        }

        // 맨 위로 스크롤
        function topFunction() {
            document.body.scrollTop = 0; // 사파리 브라우저를 위함
            document.documentElement.scrollTop = 0; // 크롬, 파이어폭스, IE, 오페라
        }
    </script>
    <!-- //공부 -->
</body>

</html>