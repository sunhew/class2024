<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 :: 데이터 불러오기</title>

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/default.min.css">
</head>

<body>
    <header id="header">
        <h1>
            <a href="index.html">javascript</a>
        </h1>
        <nav>
            <ul>
                <li><a href="javascript01.html">데이터 저장하기</a></li>
                <li class="active"><a href="javascript02.html">데이터 불러오기</a></li>
                <li><a href="javascript03.html">데이터 실행하기</a></li>
                <li><a href="javascript04.html">데이터 제어하기</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="main__menu container">
            <ul>
                <li><a href="#">01. 변수 : 데이터 불러오기</a></li>

                <li><a href="#">02. 상수 : 데이터 불러오기</a></li>

                <li><a href="#">03. 배열 : 데이터 불러오기</a></li>
                <li><a href="#">04. 배열 : 데이터 불러오기 : 갯수</a></li>
                <li><a href="#">05. 배열 : 데이터 불러오기 : for()문</a></li>
                <li><a href="#">06. 배열 : 데이터 불러오기 : forEach()</a></li>
                <li><a href="#">07. 배열 : 데이터 불러오기 : for of</a></li>
                <li><a href="#">08. 배열 : 데이터 불러오기 : for in</a></li>
                <li><a href="#">09. 배열 : 데이터 불러오기 : map()</a></li>
                <li><a href="#">10. 배열 : 데이터 불러오기 : filter()</a></li>
                <li><a href="#">11. 배열 : 데이터 불러오기 : 배열 펼침연산자</a></li>
                <li><a href="#">12. 배열 : 데이터 불러오기 : 배열 구조 분해 할당</a></li>

                <li><a href="#">13. 객체 : 데이터 불러오기 : 기본</a></li>
                <li><a href="#">14. 객체 : 데이터 불러오기 : object.keys()</a></li>
                <li><a href="#">15. 객체 : 데이터 불러오기 : object.values()</a></li>
                <li><a href="#">16. 객체 : 데이터 불러오기 : object.entries()</a></li>
                <li><a href="#">17. 객체 : 데이터 불러오기 : object.assign()</a></li>
                <li><a href="#">18. 객체 : 데이터 불러오기 : hasOwnProperty()</a></li>
                <li><a href="#">19. 객체 : 데이터 불러오기 : for in</a></li>
                <li><a href="#">20. 객체 : 데이터 불러오기 : 배열 펼침연산자</a></li>
                <li><a href="#">21. 객체 : 데이터 불러오기 : 배열 구조 분해 할당</a></li>

                <li><a href="#">22. 서버 : 데이터 불러오기 : XMLHttpRequest</a></li>
                <li><a href="#">23. 서버 : 데이터 불러오기 : fetch API</a></li>
            </ul>
        </div>
        <!-- //main__menu -->

        <div class="main__sample container">
            <div id="sample01" class="sample">
                <h3>01. 변수 : 데이터 저장</h3>
                <p>
                    변수는 데이터를 저장하는 컨테이너로, 프로그램 내에서 데이터를 참조하고 조작할 때 사용됩니다. <br />
                    avaScript에서는 var, let, const 키워드를 사용하여 변수를 선언할 수 있으며, 각각의 키워드는 변수의 스코프(유효 범위)와 재할당 가능 여부에 차이를 가집니다.
                    여기서는 let 키워드를 사용하여 변수를 선언하고 있습니다.
                </p>
                <pre><code>{
        let x = 100, y = 200, z = "javascript";

        console.log(x, y, z);
}</code></pre>
                <p>
                    *변수 선언 및 초기화* <br />
                    1. let: let 키워드는 블록 스코프(block scope)를 가지는 지역 변수를 선언할 때 사용됩니다. let으로 선언된 변수는 선언된 블록, 문장 또는 표현식 내에서
                    유효하며,
                    이를 벗어나면 해당 변수는 접근할 수 없습니다. 또한, let으로 선언된 변수는 재할당이 가능하다는 특징을 가집니다. <br />
                    2. x = 100, y = 200, z = "javascript";: 이 부분에서는 세 개의 변수 x, y, z를 선언하고 각각의 초기값으로 100, 200,
                    "javascript"를
                    할당하고 있습니다. 변수에 값을 할당할 때는 = 연산자를 사용합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->
            <div id="sample02" class="sample">
                <h3>02.상수 : 데이터 불러오기</h3>
                <p>
                    이 예시에서는 const 키워드를 사용하여 상수를 선언하고, 이들 상수에 각각 숫자와 문자열 값을 할당한 후, 이들 값을 콘솔에 출력하는 과정을 보여주고 있습니다.
                    상수는 프로그램 실행 중 값을 변경할 필요가 없는 데이터를 저장하는 데 유용하게 사용됩니다.
                </p>
                <pre><code>{
        const x = 100, y = 200, z = "javascript";

        console.log(x, y, z);
}</code></pre>
                <p>
                    const 키워드는 상수를 선언할 때 사용됩니다. 상수는 선언과 동시에 초기화(값을 할당)되어야 하며, 그 이후에는 그 값이 변경될 수 없습니다.
                    만약 상수의 값을 변경하려고 시도하면, JavaScript는 오류를 발생시킵니다. <br />
                    상수는 한 번 할당된 값이 변경되지 않는 변수를 의미합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample02 -->
            <div id="sample03" class="sample">
                <h3>03.배열 : 데이터 불러오기</h3>
                <p>
                    const 키워드를 사용하여 arr이라는 이름의 상수 배열을 선언합니다.
                    상수 배열의 경우, 배열 자체를 재할당하는 것은 불가능하지만, 배열 내의 요소를 변경하는 것은 가능합니다.
                    여기서는 배열을 재할당하지 않고, 단지 배열 내부의 데이터를 불러오기만 하므로 const를 사용하는 것이 적절합니다.
                </p>
                <pre><code>{
        const arr = [100, 200, "javascript"]

        console.log("03.배열 : 데이터 불러오기")
        console.log(arr[0], arr[1], arr[2])
}</code></pre>
                <p>
                    두 번째 console.log(arr[0], arr[1], arr[2]);는 arr 배열의 첫 번째 요소(arr[0]), 두 번째 요소(arr[1]), 세 번째
                    요소(arr[2])를 콘솔에 출력합니다.
                    배열의 인덱스는 0부터 시작하므로, arr[0]은 배열의 첫 번째 요소, arr[1]은 두 번째 요소, arr[2]는 세 번째 요소를 의미합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample03 -->
            <div id="sample04" class="sample">
                <h3>04.배열 : 데이터 불러오기: 갯수</h3>
                <p>
                    JavaScript에서 배열의 길이(즉, 배열이 포함하고 있는 요소의 총 개수)를 확인하려면 .length 속성을 사용합니다.
                    예를 들어, arr.length는 배열 arr의 길이를 반환합니다. <br />
                    아래 코드에서 arr.length는 3을 반환합니다. 이는 배열 arr이 세 개의 요소(100, 200, "javascript")를 포함하고 있기 때문입니다.
                </p>
                <pre><code>{
        const arr = [100, 200, "javascript"]

        console.log(arr.length)    //배열 안에 객체의 갯수가 총 몇개 들어있는지 확인 하는 방법
}</code></pre>
                <p>
                    *배열 안의 객체 개수 확인하기* <br />
                    배열 안에 여러 타입의 요소가 포함되어 있고, 그 중에서 객체의 개수만 확인하고 싶다면, 배열을 반복하면서 각 요소의 타입을 확인해야 합니다. <br />
                    객체를 확인하는 한 가지 방법은 typeof 연산자를 사용하는 것입니다. 그러나 typeof는 배열이나 null에 대해서도 'object'를 반환하기 때문에, 보다 정확한 방법은
                    Array.isArray() 메서드와 null 체크를 함께 사용하는 것입니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>다른 확인 방법</summary>
                        <div>
                            <pre><code>const arrMixed = [{}, {a: 1}, 100, "string", null, []];
let objectCount = 0;

arrMixed.forEach(item => {
    if (typeof item === "object" && !Array.isArray(item) && item !== null) {
    objectCount++;
    }
});

console.log(objectCount); // 배열 안의 객체 개수 출력</code></pre>
                            <p>위 코드는 배열 arrMixed 안에서 객체만을 세어서 objectCount 변수에 저장한 다음, 그 값을 출력합니다. typeof item ===
                                "object"는 요소의 타입이 객체인지 확인합니다. !Array.isArray(item)은 요소가 배열이 아닌지 확인하고, item !== null은 요소가
                                null이 아닌지 확인합니다. 이 세 조건을 모두 만족하는 요소만이 객체로 간주됩니다. <br />
                                따라서, 배열 안에 객체의 개수를 확인하려면 배열을 반복하면서 각 요소가 객체인지를 확인하는 조건을 적용해야 합니다.</p>
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample04 -->
            <div id="sample05" class="sample">
                <h3>05.배열 : 데이터 불러오기: 갯수</h3>
                <p>
                    이 코드는 JavaScript에서 for 반복문을 사용하여 배열의 모든 요소를 순회하고 출력하는 예시입니다.
                    for 반복문은 특정 조건이 만족될 때까지 코드 블록을 반복 실행하며,
                    주로 배열이나 유사 배열 객체의 요소를 순회할 때 사용됩니다. for 반복문은 세 부분으로 구성되어 있습니다
                    초깃값(initialization), 조건식(condition), 그리고 증감값(increment/decrement). 각 부분은 세미콜론(;)으로 구분됩니다.
                </p>
                <pre><code>{
                    const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];
        
                    for (let i = 0; i &lt; arr.length; i++) {               
                        console.log(arr[i]);
                    }
}</code></pre>
                <p>
                <p>*초깃값 (Initialization)* <br />
                    정의: 반복문이 시작할 때 단 한 번 설정되는 값입니다. <br />
                    예제 코드: let i = 0 <br />
                    설명: 여기서 i 변수는 반복문의 카운터로 사용되며, 0부터 시작합니다. i는 배열의 인덱스를 참조하는 데 사용되며, 배열의 첫 번째 요소부터 접근을 시작합니다. <br />
                </p>
                <p>*조건식 (Condition)* <br />
                    정의: 반복문이 실행될 조건을 정의합니다. 이 조건이 true일 때 반복문은 계속 실행됩니다. <br />
                    예제 코드: i &lt; arr.length <br />
                    설명: arr.length는 배열 arr의 전체 길이(요소의 개수)를 반환합니다. 따라서 i
                    &lt; arr.length 조건은 i가 배열의 길이보다 작을 때까지 반복문이 실행되도록 합니다. 이는 배열의 모든 요소에 접근하되, 배열의 범위를 벗어나지 않도록 보장합니다.
                    <br />
                </p>
                <p>*증감값 (Increment/Decrement)* <br />
                    정의: 반복문의 각 실행 후에 적용되는 변수의 증가 또는 감소입니다. <br />
                    예제 코드: i++ <br />
                    설명: i++는 후위 증가 연산자로, i의 값을 1만큼 증가시킵니다. 즉, 각 반복의 끝에서 i의 값이 1씩 증가하여 다음 요소의 인덱스로 이동합니다.
                </p>

                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            400 <br />
                            500 <br />
                            600 <br />
                            700 <br />
                            800 <br />
                            900 <br />
                        </div>
                    </details>
                    <details>
                        <summary>코드의 실행 과정</summary>
                        <div>
                            i는 0으로 초기화됩니다. <br />
                            조건 i &lt; arr.length가 평가됩니다. 만약 i가 arr.length보다 작으면, 반복문의 코드 블록이 실행됩니다. <br />
                            console.log(arr[i])는 현재 i에 해당하는 배열 요소를 출력합니다. <br />
                            i++는 i를 1만큼 증가시킵니다. 조건 i &lt; arr.length가 다시 평가됩니다. 조건이 여전히 true이면, 과정 3으로 돌아가 반복합니다. <br />
                            i가 arr.length와 같거나 크게 되면, 조건이 false가 되고 반복문은 종료됩니다. <br />
                            이 과정을 통해 배열 arr의 모든 요소가 순차적으로 출력됩니다. </div>
                    </details>
                </div>
            </div>
            <!-- //sample05 -->
            <div id="sample06" class="sample">
                <h3>06.배열 : 데이터 불러오기: forEach() *외우기*</h3>
                <p>
                    *forEach() 메소드는 배열의 각 요소에 대해 주어진 함수를 실행하는 메소드입니다.
                    이 메소드는 배열 내의 각 요소를 순회하면서 콜백 함수를 한 번씩 실행합니다.
                    콜백 함수는 최대 세 개의 인자를 받을 수 있으며, 이는 각각 현재 요소의 값, 현재 요소의 인덱스, 그리고 순회되는 배열 자체입니다. <br />
                    *forEach() 메소드는 배열을 순회하며 각 요소에 대해 특정 작업을 수행할 때 유용하게 사용됩니다.
                    그러나 이 메소드는 순회를 중간에 멈출 수 없다는 특징이 있습니다(즉, break나 return을 사용할 수 없습니다).
                    필요한 경우, 다른 반복문이나 배열 메소드(for, for...of, map, filter 등)를 사용할 수 있습니다.

                </p>
                <pre><code>{
        const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        //01
        arr.forEach(function (element) {                      
            console.log(element);
        })
        //02
        arr.forEach(function (element, index) {
            console.log(index);
        })
        //03
        arr.forEach(function (element, index, array) {
            console.log(array);
        })
}</code></pre>
                <p>
                <p>*01 - 요소의 값 출력하기* <br />
                    이 코드는 배열의 각 요소(element)를 순회하면서 그 값을 콘솔에 출력합니다.
                </p>
                <p>*02 - 요소의 인덱스 출력하기* <br />
                    이 코드는 배열의 각 요소를 순회하면서, 요소의 인덱스(index)를 콘솔에 출력합니다.
                </p>
                <p>*03 - 배열 전체 출력하기* <br />
                    이 코드는 배열의 각 요소를 순회할 때마다 전체 배열(array)을 콘솔에 출력합니다.
                </p>
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            <p>*01 - 요소의 값 출력하기*<br />
                                100 <br />
                                200 <br />
                                300 <br />
                                400 <br />
                                500 <br />
                                600 <br />
                                700 <br />
                                800 <br />
                                900 <br /></p>
                            <p>*02 - 요소의 인덱스 출력하기* <br />
                                0 <br />
                                1 <br />
                                2 <br />
                                3 <br />
                                4 <br />
                                5 <br />
                                6 <br />
                                7 <br />
                                8</p>
                            <p>*03 - 배열 전체 출력하기* <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />
                                [100, 200, 300, 400, 500, 600, 700, 800, 900] <br />

                        </div>
                    </details>
                    <details>
                        <summary>화살표 함수 표기법</summary>
                        <div>
                            <pre><code>{
        //01
        arr.forEach((e) => {
            console.log(e);
        })

        //02
        arr.forEach(e => {
            console.log(e);
        })
        //03
        arr.forEach(e => console.log(e));
                        }</code></pre>
                    </details>
                </div>
            </div>
            <!-- //sample06 -->
            <div id="sample07" class="sample">
                <h3>07.배열 : 데이터 불러오기: for of (배열)</h3>
                <p>
                    for...of 문은 반복 가능한 객체(Array, Map, Set, String 등)를 순회하며 그 값을 변수에 할당합니다.
                    배열의 경우, 각 순회에서 배열의 요소 값이 변수에 할당됩니다.
                </p>
                <pre><code>{
        const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        for (let element of arr) {
            console.log(element);
        }
}</code></pre>
                <p>
                    이 코드에서 for of 문은
                    배열 arr의 각 요소를 순회하면서, 변수 element에 배열의 요소 값을 할당하고, 그 값을 콘솔에 출력합니다.
                    두 코드 예제는 결과적으로 같은 값을 출력하지만, 이들의 사용 목적과 적용 범위가 다르므로, 상황에 맞게 적절한 반복문을 선택하여 사용하는 것이 중요합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            400 <br />
                            500 <br />
                            600 <br />
                            700 <br />
                            800 <br />
                            900 <br />
                        </div>
                    </details>
                    <details>
                        <summary>for in 문과의 차이점</summary>
                        <div>

                            *목적과 사용법: for of는 반복 가능한 객체의 값을 직접 순회하기 위한 목적으로 사용되며, for...in은 객체의 모든 열거 가능한 속성(키 또는
                            인덱스)을
                            순회하기 위해 사용됩니다. <br />
                            *배열 사용 시: for of는 배열의 각 요소의 값에 접근하는 데 사용되며, for in은 배열의 인덱스를 순회합니다. for in을 배열에 사용할
                            경우, 배열의 인덱스가 문자열로 처리되며, 배열 이외의 열거 가능한 속성도 순회할 수 있기 때문에 예상치 못한 결과를 초래할 수 있습니다. 따라서 배열을 순회할 때는
                            주로 for of를 사용하는 것이 좋습니다. <br />
                            *객체 사용 시: for in은 객체의 속성을 순회할 때 주로 사용되며, 객체의 키(속성 이름)에 접근하기에 적합합니다. for of는 직접 객체에 사용할 수 없고,
                            객체가 반복 가능한 프로토콜을 구현한 경우(예: Map, Set)에만 사용 가능합니다. </div>
                    </details>
                </div>
            </div>
            <!-- //sample07 -->
            <div id="sample08" class="sample">
                <h3>08. 배열 : 데이터 불러오기: for in (객체)</h3>
                <p>
                    for in 문은 객체의 모든 열거 가능한 속성을 순회하며, 각 속성의 키(또는 인덱스)를 변수에 할당합니다.
                    배열을 순회할 때, 인덱스가 변수에 할당되며, 객체를 순회할 때는 키가 할당됩니다.
                </p>
                <pre><code>{
        const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        for (let element in arr) {
            console.log(arr[element]);
        }
}</code></pre>
                <p>
                    이 코드에서 for in 문은 배열 arr의 인덱스를 순회하면서, 변수 element에 인덱스를 할당하고, arr[element]를 통해 해당 인덱스의 배열 요소 값을 콘솔에
                    출력합니다. <br />
                    arr안에 배열 선언 없이 element만 입력시 키값만 불러옵니다. <br />
                    ex : (0 1 2 3 ...).
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            400 <br />
                            500 <br />
                            600 <br />
                            700 <br />
                            800 <br />
                            900 <br />
                        </div>
                    </details>
                    <details>
                        <summary>for in 문과의 차이점</summary>
                        <div>

                            *목적과 사용법: for of는 반복 가능한 객체의 값을 직접 순회하기 위한 목적으로 사용되며, for...in은 객체의 모든 열거 가능한 속성(키 또는
                            인덱스)을
                            순회하기 위해 사용됩니다. <br />
                            *배열 사용 시: for of는 배열의 각 요소의 값에 접근하는 데 사용되며, for in은 배열의 인덱스를 순회합니다. for in을 배열에 사용할
                            경우, 배열의 인덱스가 문자열로 처리되며, 배열 이외의 열거 가능한 속성도 순회할 수 있기 때문에 예상치 못한 결과를 초래할 수 있습니다. 따라서 배열을 순회할 때는
                            주로 for of를 사용하는 것이 좋습니다. <br />
                            *객체 사용 시: for in은 객체의 속성을 순회할 때 주로 사용되며, 객체의 키(속성 이름)에 접근하기에 적합합니다. for of는 직접 객체에 사용할 수 없고,
                            객체가 반복 가능한 프로토콜을 구현한 경우(예: Map, Set)에만 사용 가능합니다. </div>
                    </details>
                </div>
            </div>
            <!-- //sample08 -->
            <div id="sample09" class="sample">
                <h3>09. 배열: 데이터 불러오기: map()</h3>
                <p>
                    map() 메서드는 배열의 모든 요소에 대해 주어진 함수를 호출하고, 결과를 모아 새 배열로 반환합니다.
                    map()은 호출된 배열을 변형시키지 않으며, 원본 배열과 동일한 길이의 새 배열을 생성합니다.
                    map()의 기본 구조는 다음과 같습니다 <br />
                    element: 현재 처리하고 있는 요소의 값입니다. <br />
                    index: 현재 처리하고 있는 요소의 인덱스입니다. <br />
                    array: map() 메서드가 호출된 원 배열입니다. <br />
                </p>
                <pre><code>{
        const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        //01
        arr.map(function (element) {
            console.log(element)
        });    //[100~900]  배열안에 감싸져있는 상태로 나옴
        arr.map(function (element, index) {
            console.log(index)
        });
        arr.map(function (element, index, array) {
            console.log(array)
        });
}</code></pre>
                <p>
                    *forEach() 메서드와의 차이* <br />
                    forEach() 메서드도 배열의 각 요소에 대해 주어진 함수를 실행하지만, map()과 다르게 아무것도 반환하지 않습니다(undefined를 반환).
                    즉, forEach()는 순수하게 부작용(side effect)을 목적으로 하는 경우에 사용됩니다(예: 각 요소를 출력).
                    반면, map()은 배열의 각 요소를 변형하여 새로운 배열을 만들고자 할 때 사용됩니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            300 <br />
                            400 <br />
                            500 <br />
                            600 <br />
                            700 <br />
                            800 <br />
                            900 <br />
                        </div>
                    </details>
                    <details>
                        <summary>결론</summary>
                        <div>

                            *map(): 배열의 각 요소를 변형하여 새로운 배열을 만들고자 할 때 사용. 반환값은 변형된 요소를 포함하는 새 배열입니다. <br />
                            *forEach(): 배열의 각 요소에 대해 주어진 함수를 실행할 때 사용. 반환값은 없습니다(즉, undefined).
                    </details>
                </div>
            </div>
            <!-- //sample09 -->
            <div id="sample10" class="sample">
                <h3>10. 배열: 데이터 불러오기: filter()</h3>
                <p>
                    filter() 메소드는 JavaScript에서 배열의 각 요소에 대해 주어진 함수를 실행하고,
                    그 결과가 true를 반환하는 모든 요소를 새로운 배열로 만들어 반환하는 고차함수입니다.
                    이 메소드는 원본 배열을 변경하지 않으며, 조건에 맞는 요소만을 필터링하여 새 배열을
                    생성합니다.
                <p>*사용법* <br />
                    #currentElement: 처리 중인 현재 요소입니다. <br />
                    #index (선택적): 처리 중인 현재 요소의 인덱스입니다. <br />
                    #arr (선택적): filter가 호출된 배열입니다. <br />
                    #thisValue (선택적): function을 실행할 때 this로 사용할 값입니다. <br />
                </p>
                아래 두 코드는 JavaScript의 filter() 메소드를 사용하여 배열에서 특정 조건을 만족하는 요소만을 추출하는 예시입니다.
                두 코드는 동일한 작업을 수행하지만, 함수를 정의하는 방식에서 차이가 있습니다. <br />
                </p>
                <pre><code>{
        const num = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        const arr = num.filter(function (element) {         
                        return element > 500;
                        });
        console.log(arr)     //첫번째 코드//

        const arr = num.filter(e => e > 500);
        console.log(arr)    //두번째 코드//
}</code></pre>
                <p>

                    *첫번째 코드에서는 filter() 메소드에 익명 함수를 전달합니다.
                    이 함수는 매개변수로 element를 받고, element > 500 조건을 만족하는지 평가합니다. 조건을 만족하는 경우(true), 해당 요소는 새 배열에 포함됩니다.
                    결과적으로 arr 배열은 500보다 큰 모든 요소를 포함하게 됩니다. <br />
                    *두번째 코드는 첫 번째 코드와 동일한 작업을 수행하지만, 화살표 함수(=>)를 사용하여 함수를 더 간결하게 표현합니다. 화살표 함수는 e라는 매개변수를 받고, e > 500
                    조건을
                    만족하는지 평가합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            500 <br />
                            600 <br />
                            700 <br />
                            800 <br />
                            900 <br />
                        </div>
                    </details>
                    <details>
                        <summary>특징</summary>
                        <div>
                            *불변성(Immutability): filter() 메소드는 원본 배열을 변경하지 않습니다. 조건에 맞는 요소들로 구성된 새로운 배열을 반환합니다. <br />
                            *체이닝(Chaining): filter() 메소드는 배열을 반환하기 때문에, 반환된 배열에 대해 추가적인 배열 메소드(map, reduce 등)를 체인으로 연결할
                            수
                            있습니다. <br />
                            *사용 사례: filter()는 데이터를 필터링하거나, 특정 조건을 만족하는 요소들만을 추출할 때 유용하게 사용됩니다. 예를 들어, 사용자 목록에서 특정 나이 이상의
                            사용자만을 선택하거나, 특정 조건을 만족하는 상품 목록을 생성할 때 사용할 수 있습니다. <br />
                        </div>
                </div>
            </div>
            <!-- //sample10 -->
            <div id="sample13" class="sample">
                <h3>13. 객체: 데이터 불러오기: 기본</h3>
                <p>
                    JavaScript에서 객체는 키와 값을 가진 속성(property)의 집합입니다.
                    객체를 사용하여 관련 데이터와 함수를 그룹화하고, 이름이 있는 속성을 통해 이러한 데이터에 접근할 수 있습니다.
                    객체의 속성에 접근하기 위해서는 점 표기법이나 대괄호 표기법을 사용할 수 있습니다.</p>
                <p>*점 표기법(Dot Notation)* <br />
                    점 표기법은 객체의 속성에 접근할 때 가장 일반적으로 사용되는 방법입니다.
                    이 방법을 사용하려면 객체 이름 뒤에 점(.)을 붙이고, 그 뒤에 속성의 이름을 작성합니다.
                </p>
                <p>*대괄호 표기법(Bracket Notation)* <br />
                    대괄호 표기법은 객체 속성에 접근할 때 속성 이름을 문자열로 지정합니다.
                    이 방법은 속성 이름이 변수에 저장되어 있거나, 유효한 변수 이름으로 사용할 수 없는 문자를 포함하고 있을 때 유용합니다.</p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }

        // console.log(obj.a)
        // console.log(obj.b)
        // console.log(obj.c)

        console.log(obj["a"])
        console.log(obj["b"])        
        console.log(obj["c"])
}</code></pre>
                <p>

                    #두 방법의 차이점# <br />
                    *점 표기법은 보다 간결하고 읽기 쉬우며, 가장 일반적인 경우에 사용됩니다.
                    하지만, 속성 이름이 유효한 JavaScript 식별자(변수 이름 규칙을 따르는)일 때만 사용할 수 있습니다.<br />
                    *대괄호 표기법은 속성 이름이 문자열로 주어질 때 사용됩니다.
                    이 방법은 속성 이름이 변수에 저장되어 있거나, 유효한 식별자가 아닌 문자를 포함하고 있을 때 필요합니다. 또한,
                    대괄호 내부에는 계산된 속성 이름을 사용할 수 있어 더 유연합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            100 <br />
                            200 <br />
                            javascript <br />
                        </div>
                    </details>
                    <details>
                        <summary>특징</summary>
                        <div>
                            *불변성(Immutability): filter() 메소드는 원본 배열을 변경하지 않습니다. 조건에 맞는 요소들로 구성된 새로운 배열을 반환합니다. <br />
                            *체이닝(Chaining): filter() 메소드는 배열을 반환하기 때문에, 반환된 배열에 대해 추가적인 배열 메소드(map, reduce 등)를 체인으로 연결할
                            수
                            있습니다. <br />
                            *사용 사례: filter()는 데이터를 필터링하거나, 특정 조건을 만족하는 요소들만을 추출할 때 유용하게 사용됩니다. 예를 들어, 사용자 목록에서 특정 나이 이상의
                            사용자만을 선택하거나, 특정 조건을 만족하는 상품 목록을 생성할 때 사용할 수 있습니다. <br />
                        </div>
                </div>
            </div>
            <!-- //sample13 -->
            <div id="sample14" class="sample">
                <h3>14. 객체: 데이터 불러오기: object.keys()</h3>
                <p>
                    Object.keys() 메소드는 JavaScript에서 객체의 모든 열거 가능한 속성의 이름들을 배열로 반환합니다. 이 메소드는 객체가 가진 키(속성 이름)만을 추출할 때
                    유용하게 사용됩니다.
                    Object.keys()는 객체를 인자로 받고, 그 객체의 모든 열거 가능한 키를 문자열 배열로 반환합니다.
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }

        console.log(Object.keys(obj))
}</code></pre>
                <p>

                    Object.keys() 메소드는 객체의 키를 기반으로 반복 작업을 수행할 때 유용합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            ["a", "b", "c"]
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample14 -->
            <div id="sample15" class="sample">
                <h3>15. 객체: 데이터 불러오기: 기본</h3>
                <p>
                    Object.values() 메소드는 주어진 객체의 자체 열거 가능한 속성 값들을 배열로 반환합니다.
                    이 메소드는 객체가 가진 값만을 추출할 때 유용하게 사용됩니다. <br />
                    Object.values() 메소드는 주어진 객체의 자체 열거 가능한 속성 값들을 배열로 반환합니다.
                    이 메소드는 객체가 가진 값만을 추출할 때 유용하게 사용됩니다.
                </p>
                <pre><code>{
        const obj = {
            a: 100,
            b: 200,
            c: "javascript"
        }

        console.log(Object.values(obj))
}</code></pre>
                <p>

                    결과는 obj 객체 내의 모든 값(100, 200, "javascript")을 순서대로 담은 배열을 보여줍니다.
                    이 배열을 사용하여 객체의 값에 접근하거나, 객체의 값들을 순회하는 등의 작업을 할 수 있으며 Object.values() 메소드는 객체의 값들을 기반으로 반복 작업을 수행할 때
                    유용합니다.
                </p>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            [100, 200, "javascript"]
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample14 -->
    </main>
    <!-- //main -->

    <footer id="footer">

    </footer>
    <!-- //footer -->

    <script src="assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>
        //01.변수 : 데이터 불러오기
        {
            let a = 1, b = 2, c = "j";

            console.log("01.변수 : 데이터 불러오기");
            console.log(a, b, c);
        }
        //02.상수 : 데이터 불러오기
        {
            const x = 100, y = 200, z = "javascript";

            console.log("02.상수 : 데이터 불러오기");
            console.log(x, y, z);
        }
        //03.배열 : 데이터 불러오기
        {
            const arr = [100, 200, "javascript"]

            console.log("03.배열 : 데이터 불러오기")
            console.log(arr[0], arr[1], arr[2])
        }
        //04.배열 : 데이터 불러오기: 갯수
        {
            const arr = [100, 200, "javascript"]

            console.log("04.배열 : 데이터 불러오기: 갯수")
            console.log(arr.length)    //배열 안에 객체의 갯수가 총 몇개 들어있는지 확인 하는 방법
        }
        //05.배열 : 데이터 불러오기: for ()문    *외우기*
        {
            const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

            console.log("05.배열 : 데이터 불러오기: for ()문")

            for (i = 0; i < arr.length; i += 2) {                   //변수를 불러오는 let은 생략 가능
                console.log(arr[i])
            }
        }
        //06.배열 : 데이터 불러오기: forEach()  *외우기*
        {
            const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

            console.log("06.배열 : 데이터 불러오기: forEach()")

            arr.forEach(function (element, index, array) {
                console.log(element);
            })

            //화살표 함수
            //01
            // arr.forEach((e) => {
            //     console.log(e);
            // })

            // //02
            // arr.forEach(e => {
            //     console.log(e);
            // })
            // //03
            // arr.forEach(e => console.log(e));
        }
        //07.배열 : 데이터 불러오기: for of (배열)
        {
            const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

            console.log("07.배열 : 데이터 불러오기: for of")
            for (let element of arr) {
                console.log(element);
            }
        }
        //08. 배열 : 데이터 불러오기: for in (객체)      //arr안에 배열 선언 없이 element만 입력시 키값만 불러옴(0 1 2 3 ...)
        {
            const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];

            console.log("08. 배열 : 데이터 불러오기: for in");
            for (let element in arr) {
                console.log[element];
            }
        }
        //09. 배열: 데이터 불러오기: map()
        {
            //     const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];
            //     //01
            //     console.log("09. 배열: 데이터 불러오기: map()");
            //     arr.map(function (element) {
            //         console.log(element)
            //     });    //[100~900]  배열안에 감싸져있는 상태로 나옴
            //     arr.map(function (element, index) {
            //         console.log(index)
            //     });
            //     arr.map(function (element, index, array) {
            //         console.log(array)
            //     });

        }
        //10. 배열: 데이터 불러오기: filter()
        {
            const num = [100, 200, 300, 400, 500, 600, 700, 800, 900];
            console.log("10. 배열: 데이터 불러오기: filter()");

            // num.filter(function (element) {
            //     console.log(element)
            // })
            // num.filter(function (element, index) {       //안의 객체 수를 표시함
            //     console.log(index)
            // })
            // num.filter(function (element, index, array) {     //결과값을 배열 안에 있는 객체 수만큼 반복해서 표시함
            //     console.log(array)
            // })

            // const arr = num.filter(function (element) {         //실제로 쓰이는 방법
            //     return element > 500;
            // });
            // console.log(arr)

            // const arr = num.filter((element) => {       
            //     return element > 500;
            // });
            // console.log(arr)

            // const arr = num.filter(element => {        
            //     return element > 500;
            // });
            // console.log(arr)
            const arr = num.filter(e => e > 500);
            console.log(arr)
        }
        //11. 배열: 데이터 불러오기: 배열 펼침연산자
        {

        }
        //12. 배열: 데이터 불러오기: 배열 구조 분해 할당
        {

        }
        //13. 객체: 데이터 불러오기: 기본
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log("13. 객체: 데이터 불러오기: 기본")
            // console.log(obj.a)
            // console.log(obj.b)
            // console.log(obj.c)

            console.log(obj["a"])
            console.log(obj["b"])           //obj의 특징
            console.log(obj["c"])
        }
        //14. 객체: 데이터 불러오기: object.keys()    [배열 안으로 들어옴]
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log("14. 객체: 데이터 불러오기: 기본")
            console.log(Object.keys(obj))
        }
        //15. 객체: 데이터 불러오기: object.values()
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log("15. 객체: 데이터 불러오기: 기본")
            console.log(Object.values(obj))
        }
        //16. 객체: 데이터 불러오기: object.entries()
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log("16. 객체: 데이터 불러오기: 기본")
            console.log(Object.entries(obj))
        }
        //17. 객체: 데이터 불러오기: object.assign()
        {
            const obj1 = {
                a: 100,
                b: 200,
            }
            const obj2 = {
                c: 300,
                d: 400,
            }
            const obj3 = Object.assign(obj1, obj2)

            console.log("17. 객체: 데이터 불러오기: 기본")
            console.log(obj3)
        }
        //18. 객체: 데이터 불러오기: hasOwnProperty()
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }

            console.log(obj.hasOwnProperty("a"));      //true
            console.log(obj.hasOwnProperty("b"));      //true
            console.log(obj.hasOwnProperty("c"));      //true
            console.log(obj.hasOwnProperty("d"));      //false

            //in연산자 (최신 방식)
            console.log("a" in obj)         //true
            console.log("b" in obj)         //true
            console.log("c" in obj)         //true
            console.log("d" in obj)         //true
        }
        //19. 객체: 데이터 불러오기: for in   (객체로 불러옴)
        {
            const obj = {
                a: 100,
                b: 200,
                c: "javascript"
            }
            for (let e in obj) {
                console.log(e + ":" + obj[e])
            }
        }
        //20. 객체: 데이터 불러오기: 배열 펼침연산자
        {

        }
        //21. 객체: 데이터 불러오기: 배열 구조 분해 할당
        {

        }
        //22. 서버: 데이터 불러오기: XMLHttpRequest
        {

        }
        //23. 서버: 데이터 불러오기: fetch API
        {

        }
    </script>
    <!-- //공부 -->
</body>

</html>